!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ACL_T_NONE	ls.c	/^    ACL_T_NONE,$/;"	e	enum:acl_type	file:
ACL_T_SELINUX_ONLY	ls.c	/^    ACL_T_SELINUX_ONLY,$/;"	e	enum:acl_type	file:
ACL_T_YES	ls.c	/^    ACL_T_YES$/;"	e	enum:acl_type	file:
ADDITIONAL_SUFFIX_OPTION	split.c	/^  ADDITIONAL_SUFFIX_OPTION$/;"	e	enum:__anon72	file:
ADD_RANGE_PAIR	cut.c	60;"	d	file:
ALG_POLLARD_RHO	factor.c	/^enum alg_type { ALG_POLLARD_RHO = 1, ALG_SQUFOF = 2 };$/;"	e	enum:alg_type	file:
ALG_SQUFOF	factor.c	/^enum alg_type { ALG_POLLARD_RHO = 1, ALG_SQUFOF = 2 };$/;"	e	enum:alg_type	file:
ALL_OPTION	nproc.c	/^  ALL_OPTION = CHAR_MAX + 1,$/;"	e	enum:__anon26	file:
ALPHA_CMPBGE_0	longlong.h	231;"	d
AM_CFLAGS	local.mk	/^AM_CFLAGS = $(WERROR_CFLAGS)$/;"	m
AM_INSTALLCHECK_STD_OPTIONS_EXEMPT	local.mk	/^AM_INSTALLCHECK_STD_OPTIONS_EXEMPT = src\/false src\/test$/;"	m
AM_LDFLAGS	local.mk	/^AM_LDFLAGS = $(IGNORE_UNUSED_LIBRARIES_CFLAGS)$/;"	m
ANYWHERE	pr.c	337;"	d	file:
APPARENT_SIZE_OPTION	du.c	/^  APPARENT_SIZE_OPTION = CHAR_MAX + 1,$/;"	e	enum:__anon39	file:
APPEND_CHAR	dircolors.c	47;"	d	file:
APPEND_TWO_CHAR_STRING	dircolors.c	48;"	d	file:
ARCH_AUTHORS	uname.c	61;"	d	file:
ARRAY_CARDINALITY	dircolors.c	/^verify (ARRAY_CARDINALITY (slack_codes) == ARRAY_CARDINALITY (ls_codes));$/;"	v
ARRAY_CARDINALITY	od.c	/^verify (MAX_INTEGRAL_TYPE_SIZE < ARRAY_CARDINALITY (bytes_to_hex_digits));$/;"	p	file:
ARRAY_CARDINALITY	system.h	653;"	d
ASSERT	factor.c	166;"	d	file:
ASSIGN_BASENAME_STRDUPA	cp.c	42;"	d	file:
ASSIGN_STRDUPA	system.h	441;"	d
ASSIGN_STRDUPA	system.h	444;"	d
ATTRIBUTES_ONLY_OPTION	cp.c	/^  ATTRIBUTES_ONLY_OPTION = CHAR_MAX + 1,$/;"	e	enum:__anon56	file:
ATTRIBUTE_NORETURN	system.h	425;"	d
ATTRIBUTE_UNUSED	system.h	429;"	d
ATTRIBUTE_WARN_UNUSED_RESULT	system.h	433;"	d
ATTRIBUTE_WARN_UNUSED_RESULT	system.h	435;"	d
ATTRIBUTE_WARN_UNUSED_RESULT	system.h	437;"	d
AUTHORS	base64.c	40;"	d	file:
AUTHORS	basename.c	29;"	d	file:
AUTHORS	cat.c	47;"	d	file:
AUTHORS	chcon.c	35;"	d	file:
AUTHORS	chgrp.c	36;"	d	file:
AUTHORS	chmod.c	38;"	d	file:
AUTHORS	chown.c	35;"	d	file:
AUTHORS	chroot.c	34;"	d	file:
AUTHORS	cksum.c	40;"	d	file:
AUTHORS	comm.c	36;"	d	file:
AUTHORS	cp.c	55;"	d	file:
AUTHORS	csplit.c	40;"	d	file:
AUTHORS	cut.c	43;"	d	file:
AUTHORS	date.c	39;"	d	file:
AUTHORS	dd.c	43;"	d	file:
AUTHORS	df.c	41;"	d	file:
AUTHORS	dircolors.c	35;"	d	file:
AUTHORS	dirname.c	31;"	d	file:
AUTHORS	du.c	52;"	d	file:
AUTHORS	echo.c	25;"	d	file:
AUTHORS	env.c	31;"	d	file:
AUTHORS	expand.c	49;"	d	file:
AUTHORS	expr.c	150;"	d	file:
AUTHORS	factor.c	108;"	d	file:
AUTHORS	fmt.c	38;"	d	file:
AUTHORS	fold.c	36;"	d	file:
AUTHORS	getlimits.c	29;"	d	file:
AUTHORS	groups.c	34;"	d	file:
AUTHORS	head.c	44;"	d	file:
AUTHORS	hostid.c	33;"	d	file:
AUTHORS	hostname.c	33;"	d	file:
AUTHORS	id.c	37;"	d	file:
AUTHORS	install.c	50;"	d	file:
AUTHORS	join.c	40;"	d	file:
AUTHORS	kill.c	33;"	d	file:
AUTHORS	link.c	36;"	d	file:
AUTHORS	ln.c	40;"	d	file:
AUTHORS	logname.c	30;"	d	file:
AUTHORS	ls.c	122;"	d	file:
AUTHORS	md5sum.c	93;"	d	file:
AUTHORS	mkdir.c	36;"	d	file:
AUTHORS	mkfifo.c	33;"	d	file:
AUTHORS	mknod.c	34;"	d	file:
AUTHORS	mktemp.c	35;"	d	file:
AUTHORS	mv.c	40;"	d	file:
AUTHORS	nice.c	39;"	d	file:
AUTHORS	nl.c	39;"	d	file:
AUTHORS	nohup.c	37;"	d	file:
AUTHORS	nproc.c	33;"	d	file:
AUTHORS	numfmt.c	35;"	d	file:
AUTHORS	od.c	36;"	d	file:
AUTHORS	paste.c	51;"	d	file:
AUTHORS	pathchk.c	31;"	d	file:
AUTHORS	pinky.c	35;"	d	file:
AUTHORS	pr.c	329;"	d	file:
AUTHORS	printenv.c	43;"	d	file:
AUTHORS	printf.c	63;"	d	file:
AUTHORS	ptx.c	42;"	d	file:
AUTHORS	pwd.c	31;"	d	file:
AUTHORS	readlink.c	32;"	d	file:
AUTHORS	realpath.c	33;"	d	file:
AUTHORS	rm.c	40;"	d	file:
AUTHORS	rmdir.c	38;"	d	file:
AUTHORS	runcon.c	62;"	d	file:
AUTHORS	seq.c	39;"	d	file:
AUTHORS	setuidgid.c	38;"	d	file:
AUTHORS	shred.c	74;"	d	file:
AUTHORS	shuf.c	39;"	d	file:
AUTHORS	sleep.c	33;"	d	file:
AUTHORS	sort.c	65;"	d	file:
AUTHORS	split.c	48;"	d	file:
AUTHORS	stat.c	173;"	d	file:
AUTHORS	stdbuf.c	37;"	d	file:
AUTHORS	stty.c	66;"	d	file:
AUTHORS	sum.c	36;"	d	file:
AUTHORS	sync.c	31;"	d	file:
AUTHORS	tac.c	57;"	d	file:
AUTHORS	tail.c	68;"	d	file:
AUTHORS	tee.c	33;"	d	file:
AUTHORS	test.c	802;"	d	file:
AUTHORS	timeout.c	78;"	d	file:
AUTHORS	touch.c	40;"	d	file:
AUTHORS	tr.c	37;"	d	file:
AUTHORS	true.c	33;"	d	file:
AUTHORS	truncate.c	37;"	d	file:
AUTHORS	tsort.c	40;"	d	file:
AUTHORS	tty.c	43;"	d	file:
AUTHORS	uname.c	60;"	d	file:
AUTHORS	unexpand.c	50;"	d	file:
AUTHORS	uniq.c	40;"	d	file:
AUTHORS	unlink.c	36;"	d	file:
AUTHORS	uptime.c	44;"	d	file:
AUTHORS	users.c	34;"	d	file:
AUTHORS	wc.c	49;"	d	file:
AUTHORS	who.c	47;"	d	file:
AUTHORS	whoami.c	35;"	d	file:
AUTHORS	yes.c	32;"	d	file:
AUTHOR_OPTION	ls.c	/^  AUTHOR_OPTION = CHAR_MAX + 1,$/;"	e	enum:__anon66	file:
AVAIL_FIELD	df.c	/^  AVAIL_FIELD,  \/* FS size available *\/$/;"	e	enum:__anon51	file:
B64BLOCKSIZE	base64.c	95;"	d	file:
BEGIN_STATE	tr.c	54;"	d	file:
BIT	cksum.c	51;"	d	file:
BLOCK	ptx.c	/^BLOCK;$/;"	t	typeref:struct:__anon29	file:
BLOCKSIZE	base64.c	94;"	d	file:
BLOCK_FLD	df.c	/^  BLOCK_FLD, \/* Block values field *\/$/;"	e	enum:__anon52	file:
BLOCK_SIZE_OPTION	ls.c	/^  BLOCK_SIZE_OPTION,$/;"	e	enum:__anon66	file:
BTRFS_IOCTL_MAGIC	copy.c	228;"	d	file:
BTRFS_IOCTL_MAGIC	copy.c	229;"	d	file:
BTRFS_IOC_CLONE	copy.c	230;"	d	file:
BTRFS_IOC_CLONE	copy.c	231;"	d	file:
BUFFER_SIZE	tac-pipe.c	22;"	d	file:
BUFFER_SIZE	wc.c	54;"	d	file:
BUFLEN	cksum.c	115;"	d	file:
B_pair	tac-pipe.c	/^struct B_pair$/;"	s	file:
B_pair::one_past_end	tac-pipe.c	/^  char *one_past_end;$/;"	m	struct:B_pair	file:	access:public
B_pair::start	tac-pipe.c	/^  char *start;$/;"	m	struct:B_pair	file:	access:public
Body	nl.c	/^  Header, Body, Footer, Text$/;"	e	enum:section	file:
Buf	tac-pipe.c	/^struct Buf$/;"	s	file:
Buf	tac-pipe.c	/^typedef struct Buf Buf;$/;"	t	typeref:struct:Buf	file:
Buf::n_bufs	tac-pipe.c	/^  size_t n_bufs;$/;"	m	struct:Buf	file:	access:public
Buf::obs	tac-pipe.c	/^  struct obstack obs;$/;"	m	struct:Buf	typeref:struct:Buf::obstack	file:	access:public
Buf::p	tac-pipe.c	/^  struct B_pair *p;$/;"	m	struct:Buf	typeref:struct:Buf::B_pair	file:	access:public
CASE_OLD_ARG	od.c	1674;"	d	file:
CASE_OLD_ARG	od.c	1699;"	d	file:
CC_ALNUM	tr.c	/^    CC_ALNUM = 0, CC_ALPHA = 1, CC_BLANK = 2, CC_CNTRL = 3,$/;"	e	enum:Char_class	file:
CC_ALPHA	tr.c	/^    CC_ALNUM = 0, CC_ALPHA = 1, CC_BLANK = 2, CC_CNTRL = 3,$/;"	e	enum:Char_class	file:
CC_BLANK	tr.c	/^    CC_ALNUM = 0, CC_ALPHA = 1, CC_BLANK = 2, CC_CNTRL = 3,$/;"	e	enum:Char_class	file:
CC_CNTRL	tr.c	/^    CC_ALNUM = 0, CC_ALPHA = 1, CC_BLANK = 2, CC_CNTRL = 3,$/;"	e	enum:Char_class	file:
CC_DIGIT	tr.c	/^    CC_DIGIT = 4, CC_GRAPH = 5, CC_LOWER = 6, CC_PRINT = 7,$/;"	e	enum:Char_class	file:
CC_GRAPH	tr.c	/^    CC_DIGIT = 4, CC_GRAPH = 5, CC_LOWER = 6, CC_PRINT = 7,$/;"	e	enum:Char_class	file:
CC_LOWER	tr.c	/^    CC_DIGIT = 4, CC_GRAPH = 5, CC_LOWER = 6, CC_PRINT = 7,$/;"	e	enum:Char_class	file:
CC_NO_CLASS	tr.c	/^    CC_NO_CLASS = 9999$/;"	e	enum:Char_class	file:
CC_PRINT	tr.c	/^    CC_DIGIT = 4, CC_GRAPH = 5, CC_LOWER = 6, CC_PRINT = 7,$/;"	e	enum:Char_class	file:
CC_PUNCT	tr.c	/^    CC_PUNCT = 8, CC_SPACE = 9, CC_UPPER = 10, CC_XDIGIT = 11,$/;"	e	enum:Char_class	file:
CC_SPACE	tr.c	/^    CC_PUNCT = 8, CC_SPACE = 9, CC_UPPER = 10, CC_XDIGIT = 11,$/;"	e	enum:Char_class	file:
CC_UPPER	tr.c	/^    CC_PUNCT = 8, CC_SPACE = 9, CC_UPPER = 10, CC_XDIGIT = 11,$/;"	e	enum:Char_class	file:
CC_XDIGIT	tr.c	/^    CC_PUNCT = 8, CC_SPACE = 9, CC_UPPER = 10, CC_XDIGIT = 11,$/;"	e	enum:Char_class	file:
CDSUSP	stty.c	131;"	d	file:
CEOF	stty.c	87;"	d	file:
CEOL	stty.c	90;"	d	file:
CEOL2	stty.c	102;"	d	file:
CERASE	stty.c	81;"	d	file:
CFLUSHO	stty.c	164;"	d	file:
CHAR	od.c	/^    CHAR,$/;"	e	enum:size_spec	file:
CHARACTER	od.c	/^    CHARACTER$/;"	e	enum:output_format	file:
CHAR_SET_SIZE	ptx.c	45;"	d	file:
CHECK_OPTION	sort.c	/^  CHECK_OPTION = CHAR_MAX + 1,$/;"	e	enum:__anon80	file:
CHECK_ORDER_DEFAULT	comm.c	/^    CHECK_ORDER_DEFAULT,$/;"	e	enum:__anon92	file:
CHECK_ORDER_DEFAULT	join.c	/^    CHECK_ORDER_DEFAULT,$/;"	e	enum:__anon8	file:
CHECK_ORDER_DISABLED	comm.c	/^    CHECK_ORDER_DISABLED$/;"	e	enum:__anon92	file:
CHECK_ORDER_DISABLED	join.c	/^    CHECK_ORDER_DISABLED$/;"	e	enum:__anon8	file:
CHECK_ORDER_ENABLED	comm.c	/^    CHECK_ORDER_ENABLED,$/;"	e	enum:__anon92	file:
CHECK_ORDER_ENABLED	join.c	/^    CHECK_ORDER_ENABLED,$/;"	e	enum:__anon8	file:
CHECK_ORDER_OPTION	comm.c	/^  CHECK_ORDER_OPTION = CHAR_MAX + 1,$/;"	e	enum:__anon93	file:
CHECK_ORDER_OPTION	join.c	/^  CHECK_ORDER_OPTION = CHAR_MAX + 1,$/;"	e	enum:__anon9	file:
CHECK_TABLE	sort.c	563;"	d	file:
CHOWN_CORE_H	chown-core.h	19;"	d
CH_ATIME	touch.c	48;"	d	file:
CH_FAILED	chmod.c	/^  CH_FAILED,$/;"	e	enum:Change_status	file:
CH_FAILED	chown-core.h	/^  CH_FAILED,$/;"	e	enum:Change_status
CH_MTIME	touch.c	49;"	d	file:
CH_NOT_APPLIED	chmod.c	/^  CH_NOT_APPLIED,$/;"	e	enum:Change_status	file:
CH_NOT_APPLIED	chown-core.h	/^  CH_NOT_APPLIED = 1,$/;"	e	enum:Change_status
CH_NO_CHANGE_REQUESTED	chmod.c	/^  CH_NO_CHANGE_REQUESTED$/;"	e	enum:Change_status	file:
CH_NO_CHANGE_REQUESTED	chown-core.h	/^  CH_NO_CHANGE_REQUESTED$/;"	e	enum:Change_status
CH_SUCCEEDED	chmod.c	/^  CH_SUCCEEDED,$/;"	e	enum:Change_status	file:
CH_SUCCEEDED	chown-core.h	/^  CH_SUCCEEDED,$/;"	e	enum:Change_status
CINTR	stty.c	75;"	d	file:
CKILL	stty.c	84;"	d	file:
CLNEXT	stty.c	146;"	d	file:
CLOSED	pr.c	/^        CLOSED$/;"	e	enum:COLUMN::__anon11	file:
CMP_WITH_IGNORE	sort.c	2576;"	d	file:
COLOR_OPTION	ls.c	/^  COLOR_OPTION,$/;"	e	enum:__anon66	file:
COLUMN	pr.c	/^struct COLUMN$/;"	s	file:
COLUMN	pr.c	/^typedef struct COLUMN COLUMN;$/;"	t	typeref:struct:COLUMN	file:
COLUMN::CLOSED	pr.c	/^        CLOSED$/;"	e	enum:COLUMN::__anon11	file:
COLUMN::FF_FOUND	pr.c	/^        FF_FOUND,		\/* used with -b option, set with \\f, changed$/;"	e	enum:COLUMN::__anon11	file:
COLUMN::ON_HOLD	pr.c	/^        ON_HOLD,		\/* Hit a form feed. *\/$/;"	e	enum:COLUMN::__anon11	file:
COLUMN::OPEN	pr.c	/^        OPEN,$/;"	e	enum:COLUMN::__anon11	file:
COLUMN::char_func	pr.c	/^    void (*char_func) (char);$/;"	m	struct:COLUMN	file:	access:public
COLUMN::current_line	pr.c	/^    int current_line;		\/* Index of current place in line_vector. *\/$/;"	m	struct:COLUMN	file:	access:public
COLUMN::fp	pr.c	/^    FILE *fp;			\/* Input stream for this column. *\/$/;"	m	struct:COLUMN	file:	access:public
COLUMN::full_page_printed	pr.c	/^    bool full_page_printed;	\/* True means printed without a FF found. *\/$/;"	m	struct:COLUMN	file:	access:public
COLUMN::lines_stored	pr.c	/^    int lines_stored;		\/* Number of lines stored in buff. *\/$/;"	m	struct:COLUMN	file:	access:public
COLUMN::lines_to_print	pr.c	/^    int lines_to_print;		\/* No. lines stored or space left on page. *\/$/;"	m	struct:COLUMN	file:	access:public
COLUMN::name	pr.c	/^    char const *name;		\/* File name. *\/$/;"	m	struct:COLUMN	file:	access:public
COLUMN::numbered	pr.c	/^    bool numbered;$/;"	m	struct:COLUMN	file:	access:public
COLUMN::print_func	pr.c	/^    bool (*print_func) (struct COLUMN *);$/;"	m	struct:COLUMN	file:	access:public
COLUMN::start_position	pr.c	/^    int start_position;		\/* Horizontal position of first char. *\/$/;"	m	struct:COLUMN	file:	access:public
COLUMN::status	pr.c	/^    status;			\/* Status of the file pointer. *\/$/;"	m	struct:COLUMN	typeref:enum:COLUMN::__anon11	file:	access:public
COLUMNS_OPTION	pr.c	/^  COLUMNS_OPTION = CHAR_MAX + 1,$/;"	e	enum:__anon14	file:
COMPLEMENT_OPTION	cut.c	/^  COMPLEMENT_OPTION$/;"	e	enum:__anon1	file:
COMPRESS_PROGRAM_OPTION	sort.c	/^  COMPRESS_PROGRAM_OPTION,$/;"	e	enum:__anon80	file:
CONVERT_FIRST_ONLY_OPTION	unexpand.c	/^  CONVERT_FIRST_ONLY_OPTION = CHAR_MAX + 1$/;"	e	enum:__anon57	file:
COPY_A_BUFFER	tail.c	79;"	d	file:
COPY_CONTENTS_OPTION	cp.c	/^  COPY_CONTENTS_OPTION,$/;"	e	enum:__anon56	file:
COPY_FD_OK	head.c	/^    COPY_FD_OK = 0,$/;"	e	enum:Copy_fd_status	file:
COPY_FD_READ_ERROR	head.c	/^    COPY_FD_READ_ERROR,$/;"	e	enum:Copy_fd_status	file:
COPY_FD_UNEXPECTED_EOF	head.c	/^    COPY_FD_UNEXPECTED_EOF$/;"	e	enum:Copy_fd_status	file:
COPY_FD_WRITE_ERROR	head.c	/^    COPY_FD_WRITE_ERROR,$/;"	e	enum:Copy_fd_status	file:
COPY_H	copy.h	20;"	d
COPY_TO_EOF	tail.c	78;"	d	file:
COST	fmt.c	/^typedef long int COST;$/;"	t	file:
COUNT_LEADING_ZEROS_0	longlong.h	1080;"	d
COUNT_LEADING_ZEROS_0	longlong.h	1171;"	d
COUNT_LEADING_ZEROS_0	longlong.h	1190;"	d
COUNT_LEADING_ZEROS_0	longlong.h	1354;"	d
COUNT_LEADING_ZEROS_0	longlong.h	1454;"	d
COUNT_LEADING_ZEROS_0	longlong.h	2087;"	d
COUNT_LEADING_ZEROS_0	longlong.h	404;"	d
COUNT_LEADING_ZEROS_0	longlong.h	527;"	d
COUNT_LEADING_ZEROS_0	longlong.h	557;"	d
COUNT_LEADING_ZEROS_0	longlong.h	922;"	d
COUNT_LEADING_ZEROS_0	longlong.h	941;"	d
COUNT_LEADING_ZEROS_NEED_CLZ_TAB	longlong.h	2088;"	d
COUNT_LEADING_ZEROS_NEED_CLZ_TAB	longlong.h	2094;"	d
COUNT_LEADING_ZEROS_NEED_CLZ_TAB	longlong.h	216;"	d
COUNT_LEADING_ZEROS_NEED_CLZ_TAB	longlong.h	247;"	d
COUNT_LEADING_ZEROS_NEED_CLZ_TAB	longlong.h	921;"	d
COUNT_LEADING_ZEROS_SLOW	longlong.h	2089;"	d
CQUIT	stty.c	78;"	d	file:
CRPRNT	stty.c	137;"	d	file:
CRPRNT	stty.c	140;"	d	file:
CSTART	stty.c	93;"	d	file:
CSTATUS	stty.c	167;"	d	file:
CSTOP	stty.c	96;"	d	file:
CSUSP	stty.c	99;"	d	file:
CSWTCH	stty.c	113;"	d	file:
CSWTCH	stty.c	117;"	d	file:
CSWTCH	stty.c	123;"	d	file:
CSWTCH	stty.c	124;"	d	file:
CTRL_SIZE	csplit.c	67;"	d	file:
CTRL_SIZE	csplit.c	73;"	d	file:
CWERASE	stty.c	143;"	d	file:
C_ASCII	dd.c	/^    C_ASCII = 01,$/;"	e	enum:__anon88	file:
C_BLK	ls.c	/^    C_BLK, C_CHR, C_MISSING, C_ORPHAN, C_EXEC, C_DOOR, C_SETUID, C_SETGID,$/;"	e	enum:indicator_no	file:
C_BLOCK	dd.c	/^    C_BLOCK = 010,$/;"	e	enum:__anon88	file:
C_CAP	ls.c	/^    C_STICKY, C_OTHER_WRITABLE, C_STICKY_OTHER_WRITABLE, C_CAP, C_MULTIHARDLINK,$/;"	e	enum:indicator_no	file:
C_CHR	ls.c	/^    C_BLK, C_CHR, C_MISSING, C_ORPHAN, C_EXEC, C_DOOR, C_SETUID, C_SETGID,$/;"	e	enum:indicator_no	file:
C_CLR_TO_EOL	ls.c	/^    C_CLR_TO_EOL$/;"	e	enum:indicator_no	file:
C_DIR	ls.c	/^    C_LEFT, C_RIGHT, C_END, C_RESET, C_NORM, C_FILE, C_DIR, C_LINK,$/;"	e	enum:indicator_no	file:
C_DOOR	ls.c	/^    C_BLK, C_CHR, C_MISSING, C_ORPHAN, C_EXEC, C_DOOR, C_SETUID, C_SETGID,$/;"	e	enum:indicator_no	file:
C_EBCDIC	dd.c	/^    C_EBCDIC = 02,$/;"	e	enum:__anon88	file:
C_END	ls.c	/^    C_LEFT, C_RIGHT, C_END, C_RESET, C_NORM, C_FILE, C_DIR, C_LINK,$/;"	e	enum:indicator_no	file:
C_EXCL	dd.c	/^    C_EXCL = 020000,$/;"	e	enum:__anon88	file:
C_EXEC	ls.c	/^    C_BLK, C_CHR, C_MISSING, C_ORPHAN, C_EXEC, C_DOOR, C_SETUID, C_SETGID,$/;"	e	enum:indicator_no	file:
C_FDATASYNC	dd.c	/^    C_FDATASYNC = 040000,$/;"	e	enum:__anon88	file:
C_FIFO	ls.c	/^    C_FIFO, C_SOCK,$/;"	e	enum:indicator_no	file:
C_FILE	ls.c	/^    C_LEFT, C_RIGHT, C_END, C_RESET, C_NORM, C_FILE, C_DIR, C_LINK,$/;"	e	enum:indicator_no	file:
C_FSYNC	dd.c	/^    C_FSYNC = 0100000,$/;"	e	enum:__anon88	file:
C_IBM	dd.c	/^    C_IBM = 04,$/;"	e	enum:__anon88	file:
C_LCASE	dd.c	/^    C_LCASE = 040,$/;"	e	enum:__anon88	file:
C_LEFT	ls.c	/^    C_LEFT, C_RIGHT, C_END, C_RESET, C_NORM, C_FILE, C_DIR, C_LINK,$/;"	e	enum:indicator_no	file:
C_LINK	ls.c	/^    C_LEFT, C_RIGHT, C_END, C_RESET, C_NORM, C_FILE, C_DIR, C_LINK,$/;"	e	enum:indicator_no	file:
C_MISSING	ls.c	/^    C_BLK, C_CHR, C_MISSING, C_ORPHAN, C_EXEC, C_DOOR, C_SETUID, C_SETGID,$/;"	e	enum:indicator_no	file:
C_MULTIHARDLINK	ls.c	/^    C_STICKY, C_OTHER_WRITABLE, C_STICKY_OTHER_WRITABLE, C_CAP, C_MULTIHARDLINK,$/;"	e	enum:indicator_no	file:
C_NOCREAT	dd.c	/^    C_NOCREAT = 010000,$/;"	e	enum:__anon88	file:
C_NOERROR	dd.c	/^    C_NOERROR = 0400,$/;"	e	enum:__anon88	file:
C_NORM	ls.c	/^    C_LEFT, C_RIGHT, C_END, C_RESET, C_NORM, C_FILE, C_DIR, C_LINK,$/;"	e	enum:indicator_no	file:
C_NOTRUNC	dd.c	/^    C_NOTRUNC = 01000,$/;"	e	enum:__anon88	file:
C_ORPHAN	ls.c	/^    C_BLK, C_CHR, C_MISSING, C_ORPHAN, C_EXEC, C_DOOR, C_SETUID, C_SETGID,$/;"	e	enum:indicator_no	file:
C_OTHER_WRITABLE	ls.c	/^    C_STICKY, C_OTHER_WRITABLE, C_STICKY_OTHER_WRITABLE, C_CAP, C_MULTIHARDLINK,$/;"	e	enum:indicator_no	file:
C_RESET	ls.c	/^    C_LEFT, C_RIGHT, C_END, C_RESET, C_NORM, C_FILE, C_DIR, C_LINK,$/;"	e	enum:indicator_no	file:
C_RIGHT	ls.c	/^    C_LEFT, C_RIGHT, C_END, C_RESET, C_NORM, C_FILE, C_DIR, C_LINK,$/;"	e	enum:indicator_no	file:
C_SETGID	ls.c	/^    C_BLK, C_CHR, C_MISSING, C_ORPHAN, C_EXEC, C_DOOR, C_SETUID, C_SETGID,$/;"	e	enum:indicator_no	file:
C_SETUID	ls.c	/^    C_BLK, C_CHR, C_MISSING, C_ORPHAN, C_EXEC, C_DOOR, C_SETUID, C_SETGID,$/;"	e	enum:indicator_no	file:
C_SOCK	ls.c	/^    C_FIFO, C_SOCK,$/;"	e	enum:indicator_no	file:
C_SPARSE	dd.c	/^    C_SPARSE = 0200000$/;"	e	enum:__anon88	file:
C_STICKY	ls.c	/^    C_STICKY, C_OTHER_WRITABLE, C_STICKY_OTHER_WRITABLE, C_CAP, C_MULTIHARDLINK,$/;"	e	enum:indicator_no	file:
C_STICKY_OTHER_WRITABLE	ls.c	/^    C_STICKY, C_OTHER_WRITABLE, C_STICKY_OTHER_WRITABLE, C_CAP, C_MULTIHARDLINK,$/;"	e	enum:indicator_no	file:
C_SWAB	dd.c	/^    C_SWAB = 0200,$/;"	e	enum:__anon88	file:
C_SYNC	dd.c	/^    C_SYNC = 02000,$/;"	e	enum:__anon88	file:
C_TWOBUFS	dd.c	/^    C_TWOBUFS = 04000,$/;"	e	enum:__anon88	file:
C_UCASE	dd.c	/^    C_UCASE = 0100,$/;"	e	enum:__anon88	file:
C_UNBLOCK	dd.c	/^    C_UNBLOCK = 020,$/;"	e	enum:__anon88	file:
Change_status	chmod.c	/^enum Change_status$/;"	g	file:
Change_status	chown-core.h	/^enum Change_status$/;"	g
Char_class	tr.c	/^enum Char_class$/;"	g	file:
Chown_option	chown-core.h	/^struct Chown_option$/;"	s
Chown_option::affect_symlink_referent	chown-core.h	/^  bool affect_symlink_referent;$/;"	m	struct:Chown_option	access:public
Chown_option::force_silent	chown-core.h	/^  bool force_silent;$/;"	m	struct:Chown_option	access:public
Chown_option::group_name	chown-core.h	/^  char *group_name;$/;"	m	struct:Chown_option	access:public
Chown_option::recurse	chown-core.h	/^  bool recurse;$/;"	m	struct:Chown_option	access:public
Chown_option::root_dev_ino	chown-core.h	/^  struct dev_ino *root_dev_ino;$/;"	m	struct:Chown_option	typeref:struct:Chown_option::dev_ino	access:public
Chown_option::user_name	chown-core.h	/^  char *user_name;$/;"	m	struct:Chown_option	access:public
Chown_option::verbosity	chown-core.h	/^  enum Verbosity verbosity;$/;"	m	struct:Chown_option	typeref:enum:Chown_option::Verbosity	access:public
Control	stty.c	72;"	d	file:
Copy_fd_status	head.c	/^enum Copy_fd_status$/;"	g	file:
DATE_FMT_LANGINFO	date.c	111;"	d	file:
DATE_FMT_LANGINFO	date.c	113;"	d	file:
DEBUG_OPTION	numfmt.c	/^  DEBUG_OPTION,$/;"	e	enum:__anon43	file:
DEBUG_PROGRAM_OPTION	sort.c	/^  DEBUG_PROGRAM_OPTION,$/;"	e	enum:__anon80	file:
DECIMAL_DIGIT_ACCUMULATE	system.h	531;"	d
DEFAULT_BLOCKSIZE	dd.c	92;"	d	file:
DEFAULT_BYTES_PER_BLOCK	od.c	39;"	d	file:
DEFAULT_ECHO_TO_XPG	echo.c	/^enum { DEFAULT_ECHO_TO_XPG = false };$/;"	e	enum:__anon58	file:
DEFAULT_FOLLOW_MODE	tail.c	82;"	d	file:
DEFAULT_MAX_N_UNCHANGED_STATS_BETWEEN_OPENS	tail.c	199;"	d	file:
DEFAULT_MAX_THREADS	sort.c	/^enum { DEFAULT_MAX_THREADS = 8 };$/;"	e	enum:__anon75	file:
DEFAULT_MODE	df.c	/^  DEFAULT_MODE,$/;"	e	enum:__anon50	file:
DEFAULT_MODE	install.c	85;"	d	file:
DEFAULT_NUMBER	head.c	49;"	d	file:
DEFAULT_N_LINES	tail.c	75;"	d	file:
DEFAULT_PASSES	shred.c	/^enum { DEFAULT_PASSES = 3 };$/;"	e	enum:__anon33	file:
DEFAULT_PREFIX	csplit.c	45;"	d	file:
DEFAULT_SECTION_DELIMITERS	nl.c	/^static char const DEFAULT_SECTION_DELIMITERS[] = "\\\\:";$/;"	v	file:
DEFAULT_SUFFIX_LENGTH	split.c	160;"	d	file:
DEFAULT_TMPDIR	sort.c	103;"	d	file:
DEFAULT_TMPDIR	tac.c	71;"	d	file:
DEFINE_SORT_FUNCTIONS	ls.c	3335;"	d	file:
DEF_INDENT	fmt.c	52;"	d	file:
DELIM	factor.c	114;"	d	file:
DELIM	tsort.c	43;"	d	file:
DELIMITER_DEFAULT	numfmt.c	/^enum { DELIMITER_DEFAULT = CHAR_MAX + 1 };$/;"	e	enum:__anon44	file:
DELTA	ptx.c	/^typedef short int DELTA;	\/* to hold displacement within one context *\/$/;"	t	file:
DEREFERENCE_COMMAND_LINE_SYMLINK_TO_DIR_OPTION	ls.c	/^  DEREFERENCE_COMMAND_LINE_SYMLINK_TO_DIR_OPTION,$/;"	e	enum:__anon66	file:
DEREFERENCE_OPTION	chcon.c	/^  DEREFERENCE_OPTION = CHAR_MAX + 1,$/;"	e	enum:__anon25	file:
DEREFERENCE_OPTION	chgrp.c	/^  DEREFERENCE_OPTION = CHAR_MAX + 1,$/;"	e	enum:__anon18	file:
DEREFERENCE_OPTION	chown.c	/^  DEREFERENCE_OPTION = CHAR_MAX + 1,$/;"	e	enum:__anon28	file:
DEREF_ALWAYS	copy.h	/^  DEREF_ALWAYS$/;"	e	enum:Dereference_symlink
DEREF_ALWAYS	ls.c	/^    DEREF_ALWAYS			\/* -L *\/$/;"	e	enum:Dereference_symlink	file:
DEREF_COMMAND_LINE_ARGUMENTS	copy.h	/^  DEREF_COMMAND_LINE_ARGUMENTS,$/;"	e	enum:Dereference_symlink
DEREF_COMMAND_LINE_ARGUMENTS	ls.c	/^    DEREF_COMMAND_LINE_ARGUMENTS,	\/* -H *\/$/;"	e	enum:Dereference_symlink	file:
DEREF_COMMAND_LINE_SYMLINK_TO_DIR	ls.c	/^    DEREF_COMMAND_LINE_SYMLINK_TO_DIR,	\/* the default, in certain cases *\/$/;"	e	enum:Dereference_symlink	file:
DEREF_NEVER	copy.h	/^  DEREF_NEVER,$/;"	e	enum:Dereference_symlink
DEREF_NEVER	ls.c	/^    DEREF_NEVER,$/;"	e	enum:Dereference_symlink	file:
DEREF_UNDEFINED	copy.h	/^  DEREF_UNDEFINED = 1,$/;"	e	enum:Dereference_symlink
DEREF_UNDEFINED	ls.c	/^    DEREF_UNDEFINED = 1,$/;"	e	enum:Dereference_symlink	file:
DEST_INFO_INITIAL_CAPACITY	copy.c	107;"	d	file:
DEST_INFO_INITIAL_CAPACITY	ln.c	/^enum { DEST_INFO_INITIAL_CAPACITY = 61 };$/;"	e	enum:__anon87	file:
DEV_DEBUG_OPTION	factor.c	/^  DEV_DEBUG_OPTION = CHAR_MAX + 1$/;"	e	enum:__anon84	file:
DEV_DEBUG_OPTION	numfmt.c	/^  DEV_DEBUG_OPTION,$/;"	e	enum:__anon43	file:
DEV_DIR_LEN	pinky.c	208;"	d	file:
DEV_DIR_LEN	who.c	342;"	d	file:
DEV_DIR_WITH_TRAILING_SLASH	pinky.c	207;"	d	file:
DEV_DIR_WITH_TRAILING_SLASH	who.c	341;"	d	file:
DEV_INO_PUSH	ls.c	965;"	d	file:
DIGEST_ALIGN	md5sum.c	50;"	d	file:
DIGEST_ALIGN	md5sum.c	57;"	d	file:
DIGEST_ALIGN	md5sum.c	64;"	d	file:
DIGEST_ALIGN	md5sum.c	71;"	d	file:
DIGEST_ALIGN	md5sum.c	78;"	d	file:
DIGEST_ALIGN	md5sum.c	85;"	d	file:
DIGEST_BIN_BYTES	md5sum.c	91;"	d	file:
DIGEST_BITS	md5sum.c	48;"	d	file:
DIGEST_BITS	md5sum.c	55;"	d	file:
DIGEST_BITS	md5sum.c	62;"	d	file:
DIGEST_BITS	md5sum.c	69;"	d	file:
DIGEST_BITS	md5sum.c	76;"	d	file:
DIGEST_BITS	md5sum.c	83;"	d	file:
DIGEST_HEX_BYTES	md5sum.c	90;"	d	file:
DIGEST_REFERENCE	md5sum.c	49;"	d	file:
DIGEST_REFERENCE	md5sum.c	56;"	d	file:
DIGEST_REFERENCE	md5sum.c	63;"	d	file:
DIGEST_REFERENCE	md5sum.c	70;"	d	file:
DIGEST_REFERENCE	md5sum.c	77;"	d	file:
DIGEST_REFERENCE	md5sum.c	84;"	d	file:
DIGEST_STREAM	md5sum.c	47;"	d	file:
DIGEST_STREAM	md5sum.c	54;"	d	file:
DIGEST_STREAM	md5sum.c	61;"	d	file:
DIGEST_STREAM	md5sum.c	68;"	d	file:
DIGEST_STREAM	md5sum.c	75;"	d	file:
DIGEST_STREAM	md5sum.c	82;"	d	file:
DIGEST_TYPE_STRING	md5sum.c	46;"	d	file:
DIGEST_TYPE_STRING	md5sum.c	53;"	d	file:
DIGEST_TYPE_STRING	md5sum.c	60;"	d	file:
DIGEST_TYPE_STRING	md5sum.c	67;"	d	file:
DIGEST_TYPE_STRING	md5sum.c	74;"	d	file:
DIGEST_TYPE_STRING	md5sum.c	81;"	d	file:
DIRED_FPUTS	ls.c	925;"	d	file:
DIRED_FPUTS_LITERAL	ls.c	929;"	d	file:
DIRED_INDENT	ls.c	932;"	d	file:
DIRED_PUTCHAR	ls.c	922;"	d	file:
DIRFIRST_CHECK	ls.c	3318;"	d	file:
DISABLE_INOTIFY_OPTION	tail.c	/^  DISABLE_INOTIFY_OPTION$/;"	e	enum:__anon86	file:
DIVBLOCK	factor.c	812;"	d	file:
DItype	factor.c	/^typedef          int DItype     __attribute__ ((mode (DI)));$/;"	t	file:
DItype	factor.c	/^typedef long int DItype;$/;"	t	file:
DItype	factor.c	/^typedef long long int DItype;$/;"	t	file:
DM_NONE	uniq.c	/^  DM_NONE,$/;"	e	enum:delimit_method	file:
DM_PREPEND	uniq.c	/^  DM_PREPEND,$/;"	e	enum:delimit_method	file:
DM_SEPARATE	uniq.c	/^  DM_SEPARATE$/;"	e	enum:delimit_method	file:
DONT_UNLINK_WHILE_OPEN	tac.c	66;"	d	file:
DT_DIR	remove.c	58;"	d	file:
DT_DIR	remove.c	61;"	d	file:
DT_LNK	remove.c	59;"	d	file:
DT_LNK	remove.c	62;"	d	file:
DT_UNKNOWN	remove.c	57;"	d	file:
DT_UNKNOWN	remove.c	60;"	d	file:
DUMB_FORMAT	ptx.c	/^  DUMB_FORMAT,			\/* output for a dumb terminal *\/$/;"	e	enum:Format	file:
D_INO	system.h	128;"	d
D_INO	system.h	131;"	d
Dereference_symlink	copy.h	/^enum Dereference_symlink$/;"	g
Dereference_symlink	ls.c	/^enum Dereference_symlink$/;"	g	file:
ECHOCTL	stty.c	155;"	d	file:
ECHOCTL	stty.c	158;"	d	file:
ECHOKE	stty.c	161;"	d	file:
EMPTY	tac-pipe.c	25;"	d	file:
EMPTY_DELIM	paste.c	56;"	d	file:
END	dcgen	/^sub END$/;"	s
ENODATA	system.h	89;"	d
EQUAL_BLOCKS	od.c	1137;"	d	file:
EQUIV	fmt.c	70;"	d	file:
EXCLUDE_OPTION	du.c	/^  EXCLUDE_OPTION,$/;"	e	enum:__anon39	file:
EXIT_CANCELED	system.h	/^  EXIT_CANCELED = 125, \/* Internal error prior to exec attempt.  *\/$/;"	e	enum:__anon68
EXIT_CANNOT_INVOKE	system.h	/^  EXIT_CANNOT_INVOKE = 126, \/* Program located, but not usable.  *\/$/;"	e	enum:__anon68
EXIT_CONVERSION_WARNINGS	numfmt.c	/^enum { EXIT_CONVERSION_WARNINGS = 2 };$/;"	e	enum:__anon42	file:
EXIT_ENOENT	system.h	/^  EXIT_ENOENT = 127 \/* Could not find program to exec.  *\/$/;"	e	enum:__anon68
EXIT_STATUS	false.c	1;"	d	file:
EXIT_STATUS	true.c	24;"	d	file:
EXIT_TIMEDOUT	system.h	/^  EXIT_TIMEDOUT = 124, \/* Time expired before child completed.  *\/$/;"	e	enum:__anon68
EXPR_FAILURE	expr.c	/^    EXPR_FAILURE$/;"	e	enum:__anon60	file:
EXPR_INVALID	expr.c	/^    EXPR_INVALID = 2,$/;"	e	enum:__anon60	file:
EXTENT_SCAN_H	extent-scan.h	20;"	d
EXTRA_PROGRAMS	local.mk	/^EXTRA_PROGRAMS = \\$/;"	m
E_string	tr.c	/^struct E_string$/;"	s	file:
E_string::escaped	tr.c	/^  bool *escaped;$/;"	m	struct:E_string	file:	access:public
E_string::len	tr.c	/^  size_t len;$/;"	m	struct:E_string	file:	access:public
E_string::s	tr.c	/^  char *s;$/;"	m	struct:E_string	file:	access:public
FAIL_ONLY_ONE_WAY	split.c	1049;"	d	file:
FATAL_ERROR	cut.c	48;"	d	file:
FFS_MASK	dd.c	295;"	d	file:
FF_FOUND	pr.c	/^        FF_FOUND,		\/* used with -b option, set with \\f, changed$/;"	e	enum:COLUMN::__anon11	file:
FF_only	pr.c	/^static bool FF_only;$/;"	v	file:
FIELD_OPTION	numfmt.c	/^  FIELD_OPTION,$/;"	e	enum:__anon43	file:
FIEMAP_EXTENT_DATA_ENCRYPTED	fiemap.h	87;"	d
FIEMAP_EXTENT_DATA_INLINE	fiemap.h	93;"	d
FIEMAP_EXTENT_DATA_TAIL	fiemap.h	96;"	d
FIEMAP_EXTENT_DELALLOC	fiemap.h	81;"	d
FIEMAP_EXTENT_ENCODED	fiemap.h	84;"	d
FIEMAP_EXTENT_LAST	fiemap.h	75;"	d
FIEMAP_EXTENT_MERGED	fiemap.h	102;"	d
FIEMAP_EXTENT_NOT_ALIGNED	fiemap.h	90;"	d
FIEMAP_EXTENT_SHARED	fiemap.h	105;"	d
FIEMAP_EXTENT_UNKNOWN	fiemap.h	78;"	d
FIEMAP_EXTENT_UNWRITTEN	fiemap.h	99;"	d
FIEMAP_FLAGS_COMPAT	fiemap.h	72;"	d
FIEMAP_FLAG_SYNC	fiemap.h	67;"	d
FIEMAP_FLAG_XATTR	fiemap.h	70;"	d
FIEMAP_MAX_OFFSET	fiemap.h	64;"	d
FILES0_FROM_OPTION	du.c	/^  FILES0_FROM_OPTION,$/;"	e	enum:__anon39	file:
FILES0_FROM_OPTION	sort.c	/^  FILES0_FROM_OPTION,$/;"	e	enum:__anon80	file:
FILES0_FROM_OPTION	wc.c	/^  FILES0_FROM_OPTION = CHAR_MAX + 1$/;"	e	enum:__anon23	file:
FILETYPE_INDICATORS	ls.c	179;"	d	file:
FILE_OR_LINK_MODE	ls.c	328;"	d	file:
FILE_TYPE_INDICATOR_OPTION	ls.c	/^  FILE_TYPE_INDICATOR_OPTION,$/;"	e	enum:__anon66	file:
FILTER_OPTION	split.c	/^  FILTER_OPTION,$/;"	e	enum:__anon72	file:
FIRST_OMITTED_PRIME	primes.h	4013;"	d
FIRST_OMITTED_PRIME	primes.h	4014;"	d
FLAG_ALTERNATIVE	csplit.c	/^enum { FLAG_THOUSANDS = 1, FLAG_ALTERNATIVE = 2 };$/;"	e	enum:__anon24	file:
FLAG_THOUSANDS	csplit.c	/^enum { FLAG_THOUSANDS = 1, FLAG_ALTERNATIVE = 2 };$/;"	e	enum:__anon24	file:
FLOATING_POINT	od.c	/^    FLOATING_POINT,$/;"	e	enum:output_format	file:
FLOAT_DOUBLE	od.c	/^    FLOAT_DOUBLE,$/;"	e	enum:size_spec	file:
FLOAT_LONG_DOUBLE	od.c	/^    FLOAT_LONG_DOUBLE,$/;"	e	enum:size_spec	file:
FLOAT_SINGLE	od.c	/^    FLOAT_SINGLE,$/;"	e	enum:size_spec	file:
FMT_BYTES_ALLOCATED	od.c	/^    FMT_BYTES_ALLOCATED =$/;"	e	enum:__anon48	file:
FOREGROUND_OPTION	timeout.c	/^      FOREGROUND_OPTION = CHAR_MAX + 1,$/;"	e	enum:__anon17	file:
FORMAT_LEFT	nl.c	/^static char const FORMAT_LEFT[] = "%-*" PRIdMAX "%s";$/;"	v	file:
FORMAT_OPTION	ls.c	/^  FORMAT_OPTION,$/;"	e	enum:__anon66	file:
FORMAT_OPTION	numfmt.c	/^  FORMAT_OPTION,$/;"	e	enum:__anon43	file:
FORMAT_RIGHT_LZ	nl.c	/^static char const FORMAT_RIGHT_LZ[] = "%0*" PRIdMAX "%s";$/;"	v	file:
FORMAT_RIGHT_NOLZ	nl.c	/^static char const FORMAT_RIGHT_NOLZ[] = "%*" PRIdMAX "%s";$/;"	v	file:
FROM_OPTION	chown.c	/^  FROM_OPTION,$/;"	e	enum:__anon28	file:
FROM_OPTION	numfmt.c	/^  FROM_OPTION = CHAR_MAX + 1,$/;"	e	enum:__anon43	file:
FROM_UNIT_OPTION	numfmt.c	/^  FROM_UNIT_OPTION,$/;"	e	enum:__anon43	file:
FSTYPE_FIELD	df.c	/^  FSTYPE_FIELD, \/* FS type *\/$/;"	e	enum:__anon51	file:
FS_IOC_FIEMAP	extent-scan.c	84;"	d	file:
FTSENT_IS_DIRECTORY	chown-core.c	33;"	d	file:
FTS_CROSS_CHECK	du.c	59;"	d	file:
FTS_CROSS_CHECK	du.c	61;"	d	file:
FTS_DEBUG	du.c	/^  FTS_DEBUG,$/;"	e	enum:__anon39	file:
FULL_TIME_OPTION	ls.c	/^  FULL_TIME_OPTION,$/;"	e	enum:__anon66	file:
File_spec	tail.c	/^struct File_spec$/;"	s	file:
File_spec::basename_start	tail.c	/^  size_t basename_start;$/;"	m	struct:File_spec	file:	access:public
File_spec::blocking	tail.c	/^  int blocking;$/;"	m	struct:File_spec	file:	access:public
File_spec::dev	tail.c	/^  dev_t dev;$/;"	m	struct:File_spec	file:	access:public
File_spec::errnum	tail.c	/^  int errnum;$/;"	m	struct:File_spec	file:	access:public
File_spec::fd	tail.c	/^  int fd;$/;"	m	struct:File_spec	file:	access:public
File_spec::ignore	tail.c	/^  bool ignore;$/;"	m	struct:File_spec	file:	access:public
File_spec::ino	tail.c	/^  ino_t ino;$/;"	m	struct:File_spec	file:	access:public
File_spec::mode	tail.c	/^  mode_t mode;$/;"	m	struct:File_spec	file:	access:public
File_spec::mtime	tail.c	/^  struct timespec mtime;$/;"	m	struct:File_spec	typeref:struct:File_spec::timespec	file:	access:public
File_spec::n_unchanged_stats	tail.c	/^  uintmax_t n_unchanged_stats;$/;"	m	struct:File_spec	file:	access:public
File_spec::name	tail.c	/^  char *name;$/;"	m	struct:File_spec	file:	access:public
File_spec::parent_wd	tail.c	/^  int parent_wd;$/;"	m	struct:File_spec	file:	access:public
File_spec::remote	tail.c	/^  bool remote;$/;"	m	struct:File_spec	file:	access:public
File_spec::size	tail.c	/^  off_t size;$/;"	m	struct:File_spec	file:	access:public
File_spec::tailable	tail.c	/^  bool tailable;$/;"	m	struct:File_spec	file:	access:public
File_spec::wd	tail.c	/^  int wd;$/;"	m	struct:File_spec	file:	access:public
Follow_descriptor	tail.c	/^  Follow_descriptor = 2$/;"	e	enum:Follow_mode	file:
Follow_mode	tail.c	/^enum Follow_mode$/;"	g	file:
Follow_name	tail.c	/^  Follow_name = 1,$/;"	e	enum:Follow_mode	file:
Footer	nl.c	/^  Header, Body, Footer, Text$/;"	e	enum:section	file:
Format	ptx.c	/^enum Format$/;"	g	file:
GEN	cksum.c	61;"	d	file:
GETOPT_HELP_CHAR	system.h	/^  GETOPT_HELP_CHAR = (CHAR_MIN - 2),$/;"	e	enum:__anon70
GETOPT_HELP_OPTION_DECL	system.h	328;"	d
GETOPT_SELINUX_CONTEXT_OPTION_DECL	system.h	332;"	d
GETOPT_VERSION_CHAR	system.h	/^  GETOPT_VERSION_CHAR = (CHAR_MIN - 3)$/;"	e	enum:__anon70
GETOPT_VERSION_OPTION_DECL	system.h	330;"	d
GET_NICENESS	nice.c	42;"	d	file:
GET_NICENESS	nice.c	44;"	d	file:
GID_T_MAX	system.h	404;"	d
GID_T_MIN	getlimits.c	56;"	d	file:
GROUPING_OPTION	numfmt.c	/^  GROUPING_OPTION,$/;"	e	enum:__anon43	file:
GROUPS	chroot.c	/^  GROUPS = UCHAR_MAX + 1,$/;"	e	enum:__anon94	file:
GROUP_DIRECTORIES_FIRST_OPTION	ls.c	/^  GROUP_DIRECTORIES_FIRST_OPTION,$/;"	e	enum:__anon66	file:
G_buffer	tac.c	/^static char *G_buffer;$/;"	v	file:
G_buffer_size	tac.c	/^static size_t G_buffer_size;$/;"	v	file:
G_line	dircolors.h	/^static char const G_line[] =$/;"	v
HAVE_FCHOWN	copy.c	72;"	d	file:
HAVE_GMP	expr.c	50;"	d	file:
HAVE_HOST_CPU_FAMILY_powerpc	factor.c	181;"	d	file:
HAVE_LCHOWN	copy.c	77;"	d	file:
HAVE_MAJOR	system.h	61;"	d
HAVE_MAJOR	system.h	65;"	d
HAVE_MAJOR	system.h	68;"	d
HAVE_MAJOR	system.h	76;"	d
HAVE_SETHOSTNAME	hostname.c	46;"	d	file:
HAVE_STRUCT_STATXFS_F_TYPE	stat.c	79;"	d	file:
HAVE_STRUCT_STATXFS_F_TYPE	stat.c	90;"	d	file:
HAVE_STRUCT_STAT_ST_BLOCKS	copy.c	753;"	d	file:
HEADER_LINE_OPTION	join.c	/^  HEADER_LINE_OPTION$/;"	e	enum:__anon9	file:
HEADER_OPTION	numfmt.c	/^  HEADER_OPTION,$/;"	e	enum:__anon43	file:
HEAD_TAIL_PIPE_BYTECOUNT_THRESHOLD	head.c	217;"	d	file:
HEAD_TAIL_PIPE_READ_BUFSIZE	head.c	208;"	d	file:
HELP_OPTION_DESCRIPTION	system.h	348;"	d
HEXADECIMAL	od.c	/^    HEXADECIMAL,$/;"	e	enum:output_format	file:
HEXTOBIN	ptx.c	48;"	d	file:
HIDE_OPTION	ls.c	/^  HIDE_OPTION,$/;"	e	enum:__anon66	file:
HIGHBIT_TO_MASK	factor.c	395;"	d	file:
HT_RANGE_START_INDEX_INITIAL_CAPACITY	cut.c	151;"	d	file:
HUMAN_MODE	df.c	/^  HUMAN_MODE,$/;"	e	enum:__anon50	file:
HUMAN_SI_OPTION	du.c	/^  HUMAN_SI_OPTION,$/;"	e	enum:__anon39	file:
Header	nl.c	/^  Header, Body, Footer, Text$/;"	e	enum:section	file:
IAVAIL_FIELD	df.c	/^  IAVAIL_FIELD, \/* inodes available *\/$/;"	e	enum:__anon51	file:
IDLESTR_LEN	who.c	82;"	d	file:
IF_LINT	system.h	413;"	d
IF_LINT	system.h	415;"	d
IGNORE_DEFAULT	ls.c	/^  IGNORE_DEFAULT,$/;"	e	enum:__anon63	file:
IGNORE_DOT_AND_DOTDOT	ls.c	/^  IGNORE_DOT_AND_DOTDOT,$/;"	e	enum:__anon63	file:
IGNORE_FAIL_ON_NON_EMPTY_OPTION	rmdir.c	/^  IGNORE_FAIL_ON_NON_EMPTY_OPTION = CHAR_MAX + 1$/;"	e	enum:__anon54	file:
IGNORE_MINIMAL	ls.c	/^  IGNORE_MINIMAL$/;"	e	enum:__anon63	file:
IGNORE_OPTION	nproc.c	/^  IGNORE_OPTION$/;"	e	enum:__anon26	file:
INCR_SIZE	csplit.c	64;"	d	file:
INCR_SIZE	csplit.c	72;"	d	file:
INDICATOR_STYLE_OPTION	ls.c	/^  INDICATOR_STYLE_OPTION,$/;"	e	enum:__anon66	file:
INITIAL_READSIZE	tac.c	75;"	d	file:
INITIAL_TABLE_SIZE	cp-hash.c	48;"	d	file:
INITIAL_TABLE_SIZE	ls.c	287;"	d	file:
INIT_PROCTAB_SIZE	sort.c	/^enum { INIT_PROCTAB_SIZE = 47 };$/;"	e	enum:__anon82	file:
INODES_MODE	df.c	/^  INODES_MODE,$/;"	e	enum:__anon50	file:
INODE_FLD	df.c	/^  INODE_FLD, \/* Inode values field *\/$/;"	e	enum:__anon52	file:
INPUT_BLOCK_SLOP	dd.c	97;"	d	file:
INPUT_FILE_SIZE_GUESS	sort.c	329;"	d	file:
INSTALL_PROGRAM	local.mk	/^INSTALL_PROGRAM = $(cu_install_program)$/;"	m
INT	od.c	/^    INT,$/;"	e	enum:size_spec	file:
INTERACTIVE_OPTION	rm.c	/^  INTERACTIVE_OPTION = CHAR_MAX + 1,$/;"	e	enum:__anon47	file:
INVALID_OPTION	numfmt.c	/^  INVALID_OPTION$/;"	e	enum:__anon43	file:
IO_BLKSIZE_OPTION	split.c	/^  IO_BLKSIZE_OPTION,$/;"	e	enum:__anon72	file:
IO_BUFSIZE	ioblksize.h	/^enum { IO_BUFSIZE = 64*1024 };$/;"	e	enum:__anon16
IPCENT_FIELD	df.c	/^  IPCENT_FIELD, \/* inodes used in percent *\/$/;"	e	enum:__anon51	file:
ISDIGIT	system.h	156;"	d
ISODIGIT	ptx.c	47;"	d	file:
ISPEC_TO_FORMAT	od.c	659;"	d	file:
ISWHITE	md5sum.c	221;"	d	file:
IS_DIR_TYPE	du.c	186;"	d	file:
IS_TAILABLE_FILE_TYPE	tail.c	98;"	d	file:
ITOTAL_FIELD	df.c	/^  ITOTAL_FIELD, \/* inode total *\/$/;"	e	enum:__anon51	file:
IUSED_FIELD	df.c	/^  IUSED_FIELD,  \/* inodes used *\/$/;"	e	enum:__anon51	file:
I_ALWAYS_NO	copy.h	/^  I_ALWAYS_NO,$/;"	e	enum:Interactive
I_ALWAYS_YES	copy.h	/^  I_ALWAYS_YES = 1,$/;"	e	enum:Interactive
I_ASK_USER	copy.h	/^  I_ASK_USER,$/;"	e	enum:Interactive
I_UNSPECIFIED	copy.h	/^  I_UNSPECIFIED$/;"	e	enum:Interactive
Interactive	copy.h	/^enum Interactive$/;"	g
LBRACKET	lbracket.c	1;"	d	file:
LBRACKET	test.c	36;"	d	file:
LDADD	local.mk	/^LDADD = src\/libver.a lib\/libcoreutils.a $(LIBINTL) lib\/libcoreutils.a$/;"	m
LEEWAY	fmt.c	48;"	d	file:
LEN	tac-pipe.c	24;"	d	file:
LEN_STR_PAIR	ls.c	225;"	d	file:
LIB_NAME	stdbuf.c	35;"	d	file:
LIKELY	factor.c	715;"	d	file:
LIKELY	factor.c	718;"	d	file:
LINE_COST	fmt.c	79;"	d	file:
LINE_COUNTER_BUF_LEN	cat.c	60;"	d	file:
LINE_CREDIT	fmt.c	106;"	d	file:
LIST_SORTFUNCTION_VARIANTS	ls.c	3457;"	d	file:
LOG_EQ	df.c	707;"	d	file:
LONG	od.c	/^    LONG,$/;"	e	enum:size_spec	file:
LONGEST_SYMBOL	dd.c	264;"	d	file:
LONGLONG_STANDALONE	factor.c	165;"	d	file:
LONG_FOLLOW_OPTION	tail.c	/^  LONG_FOLLOW_OPTION,$/;"	e	enum:__anon86	file:
LONG_LONG	od.c	/^    LONG_LONG,$/;"	e	enum:size_spec	file:
LOOKUP_OPTION	who.c	/^  LOOKUP_OPTION = CHAR_MAX + 1$/;"	e	enum:__anon21	file:
LOOP_DETECT	ls.c	298;"	d	file:
LS_FAILURE	ls.c	/^    LS_FAILURE = 2$/;"	e	enum:__anon65	file:
LS_LONG_FORMAT	ls.h	8;"	d
LS_LS	ls.h	2;"	d
LS_MINOR_PROBLEM	ls.c	/^    LS_MINOR_PROBLEM = 1,$/;"	e	enum:__anon65	file:
LS_MULTI_COL	ls.h	5;"	d
Line_ptr	tac-pipe.c	/^struct Line_ptr$/;"	s	file:
Line_ptr	tac-pipe.c	/^typedef struct Line_ptr Line_ptr;$/;"	t	typeref:struct:Line_ptr	file:
Line_ptr::i	tac-pipe.c	/^  size_t i;$/;"	m	struct:Line_ptr	file:	access:public
Line_ptr::ptr	tac-pipe.c	/^  char *ptr;$/;"	m	struct:Line_ptr	file:	access:public
List_element	tr.c	/^struct List_element$/;"	s	file:
List_element::__anon3::__anon4::first_char	tr.c	/^            unsigned char first_char;$/;"	m	struct:List_element::__anon3::__anon4	file:	access:public
List_element::__anon3::__anon4::last_char	tr.c	/^            unsigned char last_char;$/;"	m	struct:List_element::__anon3::__anon4	file:	access:public
List_element::__anon3::__anon5::repeat_count	tr.c	/^            count repeat_count;$/;"	m	struct:List_element::__anon3::__anon5	file:	access:public
List_element::__anon3::__anon5::the_repeated_char	tr.c	/^            unsigned char the_repeated_char;$/;"	m	struct:List_element::__anon3::__anon5	file:	access:public
List_element::__anon3::char_class	tr.c	/^        enum Char_class char_class;$/;"	m	union:List_element::__anon3	typeref:enum:List_element::__anon3::Char_class	file:	access:public
List_element::__anon3::equiv_code	tr.c	/^        unsigned char equiv_code;$/;"	m	union:List_element::__anon3	file:	access:public
List_element::__anon3::normal_char	tr.c	/^        unsigned char normal_char;$/;"	m	union:List_element::__anon3	file:	access:public
List_element::__anon3::range	tr.c	/^        range;$/;"	m	union:List_element::__anon3	typeref:struct:List_element::__anon3::__anon4	file:	access:public
List_element::__anon3::repeated_char	tr.c	/^        repeated_char;$/;"	m	union:List_element::__anon3	typeref:struct:List_element::__anon3::__anon5	file:	access:public
List_element::next	tr.c	/^    struct List_element *next;$/;"	m	struct:List_element	typeref:struct:List_element::List_element	file:	access:public
List_element::type	tr.c	/^    enum Range_element_type type;$/;"	m	struct:List_element	typeref:enum:List_element::Range_element_type	file:	access:public
List_element::u	tr.c	/^    u;$/;"	m	struct:List_element	typeref:union:List_element::__anon3	file:	access:public
MAGIC11	factor.c	1833;"	d	file:
MAGIC63	factor.c	1831;"	d	file:
MAGIC64	factor.c	1830;"	d	file:
MAGIC65	factor.c	1832;"	d	file:
MALLOC_FUNC_CHECK	ptx.c	55;"	d	file:
MAX	system.h	378;"	d
MAXCHARS	fmt.c	116;"	d	file:
MAXCOST	fmt.c	67;"	d	file:
MAXGID	chroot.c	37;"	d	file:
MAXWORDS	fmt.c	115;"	d	file:
MAX_ACCEPTABLE_DIGITS	numfmt.c	/^enum { MAX_ACCEPTABLE_DIGITS = 27 };$/;"	e	enum:__anon46	file:
MAX_ADDRESS_LENGTH	od.c	178;"	d	file:
MAX_BLOCKSIZE	dd.c	105;"	d	file:
MAX_FORK_TRIES_COMPRESS	sort.c	/^    MAX_FORK_TRIES_COMPRESS = 4,$/;"	e	enum:__anon77	file:
MAX_FORK_TRIES_DECOMPRESS	sort.c	/^    MAX_FORK_TRIES_DECOMPRESS = 9$/;"	e	enum:__anon77	file:
MAX_FP_TYPE_SIZE	od.c	259;"	d	file:
MAX_INTEGRAL_TYPE_SIZE	od.c	75;"	d	file:
MAX_MERGE	sort.c	109;"	d	file:
MAX_MON_WIDTH	ls.c	/^enum { MAX_MON_WIDTH = 5 };$/;"	e	enum:__anon67	file:
MAX_NFACTS	factor.c	215;"	d	file:
MAX_UNCHANGED_STATS_OPTION	tail.c	/^  MAX_UNCHANGED_STATS_OPTION,$/;"	e	enum:__anon86	file:
MAX_UNSCALED_DIGITS	numfmt.c	/^enum { MAX_UNSCALED_DIGITS = 18 };$/;"	e	enum:__anon45	file:
MEGABYTES_OPTION	df.c	/^  MEGABYTES_OPTION  \/* FIXME: remove long opt in Aug 2013 *\/$/;"	e	enum:__anon53	file:
MERGE_END	sort.c	/^    MERGE_END = 0,$/;"	e	enum:__anon78	file:
MERGE_ROOT	sort.c	/^    MERGE_ROOT = 1$/;"	e	enum:__anon78	file:
MIGHT_BE_J1_ARG	join.c	/^    MIGHT_BE_J1_ARG,$/;"	e	enum:operand_status	file:
MIGHT_BE_J2_ARG	join.c	/^    MIGHT_BE_J2_ARG,$/;"	e	enum:operand_status	file:
MIGHT_BE_O_ARG	join.c	/^    MIGHT_BE_O_ARG$/;"	e	enum:operand_status	file:
MIN	factor.c	1952;"	d	file:
MIN	system.h	382;"	d
MIN_COLUMN_WIDTH	ls.c	912;"	d	file:
MIN_DIGEST_LINE_LENGTH	md5sum.c	100;"	d	file:
MIN_MERGE_BUFFER_SIZE	sort.c	310;"	d	file:
MIN_SORT_SIZE	sort.c	313;"	d	file:
MODE_RW_UGO	system.h	34;"	d
MONTHS_PER_YEAR	sort.c	286;"	d	file:
MR_REPS	factor.c	712;"	d	file:
MT_SAME_POSITION	dd.c	1494;"	d	file:
MULTIPLE_BITS_SET	dd.c	339;"	d	file:
MUST_BE_OPERAND	join.c	/^    MUST_BE_OPERAND,$/;"	e	enum:operand_status	file:
NAMED_CHARACTER	od.c	/^    NAMED_CHARACTER,$/;"	e	enum:output_format	file:
NAME_MAX_MINIMUM	pathchk.c	44;"	d	file:
NAME_MAX_MINIMUM	pathchk.c	46;"	d	file:
NEW_ELEMENT	tr.c	61;"	d	file:
NMERGE_DEFAULT	sort.c	307;"	d	file:
NMERGE_OPTION	sort.c	/^  NMERGE_OPTION,$/;"	e	enum:__anon80	file:
NOBREAK_COST	fmt.c	97;"	d	file:
NOCHECK_ORDER_OPTION	comm.c	/^  NOCHECK_ORDER_OPTION,$/;"	e	enum:__anon93	file:
NOCHECK_ORDER_OPTION	join.c	/^  NOCHECK_ORDER_OPTION,$/;"	e	enum:__anon9	file:
NONZERO	sort.c	173;"	d	file:
NOT_AN_INODE_NUMBER	system.h	/^  NOT_AN_INODE_NUMBER = 0$/;"	e	enum:__anon69
NO_PRESERVE_ATTRIBUTES_OPTION	cp.c	/^  NO_PRESERVE_ATTRIBUTES_OPTION,$/;"	e	enum:__anon56	file:
NO_PRESERVE_ROOT	chcon.c	/^  NO_PRESERVE_ROOT,$/;"	e	enum:__anon25	file:
NO_PRESERVE_ROOT	chgrp.c	/^  NO_PRESERVE_ROOT,$/;"	e	enum:__anon18	file:
NO_PRESERVE_ROOT	chmod.c	/^  NO_PRESERVE_ROOT = CHAR_MAX + 1,$/;"	e	enum:__anon38	file:
NO_PRESERVE_ROOT	chown.c	/^  NO_PRESERVE_ROOT,$/;"	e	enum:__anon28	file:
NO_PRESERVE_ROOT	rm.c	/^  NO_PRESERVE_ROOT,$/;"	e	enum:__anon47	file:
NO_SIZE	od.c	/^    NO_SIZE,$/;"	e	enum:size_spec	file:
NO_SYNC_OPTION	df.c	/^  NO_SYNC_OPTION = CHAR_MAX + 1,$/;"	e	enum:__anon53	file:
NZERO	nice.c	48;"	d	file:
NZERO	nice.c	53;"	d	file:
NZERO	nice.c	54;"	d	file:
N_	system.h	176;"	d
N_CHARS	tr.c	/^enum { N_CHARS = UCHAR_MAX + 1 };$/;"	e	enum:__anon2	file:
N_SIZE_SPECS	od.c	/^    N_SIZE_SPECS$/;"	e	enum:size_spec	file:
N_SIZE_SPECS	od.c	/^verify (ARRAY_CARDINALITY (width_bytes) == N_SIZE_SPECS);$/;"	v
OBS	tac-pipe.c	56;"	d	file:
OCCURS	ptx.c	/^OCCURS;$/;"	t	typeref:struct:__anon32	file:
OCTAL	od.c	/^    OCTAL,$/;"	e	enum:output_format	file:
OCTTOBIN	ptx.c	50;"	d	file:
OFD_APPEND	split.c	/^  OFD_APPEND = -2$/;"	e	enum:__anon73	file:
OFD_NEW	split.c	/^  OFD_NEW = -1,$/;"	e	enum:__anon73	file:
OFF_T_MAX	system.h	396;"	d
OFF_T_MIN	system.h	392;"	d
OMIT	stty.c	192;"	d	file:
ONE_FILE_SYSTEM	rm.c	/^  ONE_FILE_SYSTEM,$/;"	e	enum:__anon47	file:
ONE_PAST_END	tac-pipe.c	27;"	d	file:
ON_HOLD	pr.c	/^        ON_HOLD,		\/* Hit a form feed. *\/$/;"	e	enum:COLUMN::__anon11	file:
OPEN	pr.c	/^        OPEN,$/;"	e	enum:COLUMN::__anon11	file:
OPEN_MAX	sort.c	86;"	d	file:
OPEN_MAX	sort.c	89;"	d	file:
ORPHAN_COST	fmt.c	87;"	d	file:
OTHER_FLD	df.c	/^  OTHER_FLD  \/* Neutral field, e.g. target *\/$/;"	e	enum:__anon52	file:
OUTPUT_BLOCK_SLOP	dd.c	98;"	d	file:
OUTPUT_DELIMITER_OPTION	comm.c	/^  OUTPUT_DELIMITER_OPTION$/;"	e	enum:__anon93	file:
OUTPUT_DELIMITER_OPTION	cut.c	/^  OUTPUT_DELIMITER_OPTION = CHAR_MAX + 1,$/;"	e	enum:__anon1	file:
OUTPUT_MODE	df.c	/^  OUTPUT_MODE$/;"	e	enum:__anon50	file:
OUTPUT_OPTION	df.c	/^  OUTPUT_OPTION,$/;"	e	enum:__anon53	file:
OUT_NAMEMAX	stat.c	138;"	d	file:
OUT_NAMEMAX	stat.c	142;"	d	file:
O_CIO	dd.c	71;"	d	file:
O_COUNT_BYTES	dd.c	/^    O_COUNT_BYTES = FFS_MASK (v3),$/;"	e	enum:__anon90	file:
O_FULLBLOCK	dd.c	/^    O_FULLBLOCK = FFS_MASK (v),$/;"	e	enum:__anon90	file:
O_NOCACHE	dd.c	/^    O_NOCACHE = FFS_MASK (v2),$/;"	e	enum:__anon90	file:
O_NOCACHE	dd.c	76;"	d	file:
O_SEEK_BYTES	dd.c	/^    O_SEEK_BYTES = FFS_MASK (v5)$/;"	e	enum:__anon90	file:
O_SKIP_BYTES	dd.c	/^    O_SKIP_BYTES = FFS_MASK (v4),$/;"	e	enum:__anon90	file:
Options	shred.c	/^struct Options$/;"	s	file:
Options::exact	shred.c	/^  bool exact;		\/* -x flag: Do not round up file size *\/$/;"	m	struct:Options	file:	access:public
Options::force	shred.c	/^  bool force;		\/* -f flag: chmod files if necessary *\/$/;"	m	struct:Options	file:	access:public
Options::n_iterations	shred.c	/^  size_t n_iterations;	\/* -n flag: Number of iterations *\/$/;"	m	struct:Options	file:	access:public
Options::remove_file	shred.c	/^  bool remove_file;	\/* -u flag: remove file after shredding *\/$/;"	m	struct:Options	file:	access:public
Options::size	shred.c	/^  off_t size;		\/* -s flag: size of file *\/$/;"	m	struct:Options	file:	access:public
Options::verbose	shred.c	/^  bool verbose;		\/* -v flag: Print progress *\/$/;"	m	struct:Options	file:	access:public
Options::zero_fill	shred.c	/^  bool zero_fill;	\/* -z flag: Add a final zero pass *\/$/;"	m	struct:Options	file:	access:public
P	factor.c	655;"	d	file:
P	factor.c	660;"	d	file:
P	factor.c	665;"	d	file:
P	factor.c	670;"	d	file:
P	factor.c	677;"	d	file:
P	factor.c	682;"	d	file:
PADDING_OPTION	numfmt.c	/^  PADDING_OPTION,$/;"	e	enum:__anon43	file:
PAGES_OPTION	pr.c	/^  PAGES_OPTION$/;"	e	enum:__anon14	file:
PARALLEL_OPTION	sort.c	/^  PARALLEL_OPTION$/;"	e	enum:__anon80	file:
PARENTS_OPTION	cp.c	/^  PARENTS_OPTION,$/;"	e	enum:__anon56	file:
PAREN_BONUS	fmt.c	100;"	d	file:
PASS_NAME_SIZE	shred.c	257;"	d	file:
PATH_MAX	system.h	50;"	d
PATH_MAX_MINIMUM	pathchk.c	49;"	d	file:
PATH_MAX_MINIMUM	pathchk.c	51;"	d	file:
PA_DESCEND_INTO_DIR	remove.c	/^    PA_DESCEND_INTO_DIR = 2,$/;"	e	enum:Prompt_action	file:
PA_REMOVE_DIR	remove.c	/^    PA_REMOVE_DIR$/;"	e	enum:Prompt_action	file:
PCENT_FIELD	df.c	/^  PCENT_FIELD,  \/* percent used *\/$/;"	e	enum:__anon51	file:
PIDSTR_DECL_AND_INIT	who.c	85;"	d	file:
PIDSTR_DECL_AND_INIT	who.c	89;"	d	file:
PID_OPTION	tail.c	/^  PID_OPTION,$/;"	e	enum:__anon86	file:
PID_T_MAX	system.h	408;"	d
PID_T_MIN	getlimits.c	44;"	d	file:
PORTABILITY_OPTION	pathchk.c	/^  PORTABILITY_OPTION = CHAR_MAX + 1$/;"	e	enum:__anon71	file:
POSIX_MODE	df.c	/^  POSIX_MODE,$/;"	e	enum:__anon50	file:
POSIX_NOHUP_FAILURE	nohup.c	/^    POSIX_NOHUP_FAILURE = 127$/;"	e	enum:__anon91	file:
POS_AFTER_TAB	pr.c	602;"	d	file:
PRESERVE_ATTRIBUTES_OPTION	cp.c	/^  PRESERVE_ATTRIBUTES_OPTION,$/;"	e	enum:__anon56	file:
PRESERVE_CONTEXT_OPTION	install.c	/^  PRESERVE_CONTEXT_OPTION = CHAR_MAX + 1,$/;"	e	enum:__anon15	file:
PRESERVE_ROOT	chcon.c	/^  PRESERVE_ROOT,$/;"	e	enum:__anon25	file:
PRESERVE_ROOT	chgrp.c	/^  PRESERVE_ROOT,$/;"	e	enum:__anon18	file:
PRESERVE_ROOT	chmod.c	/^  PRESERVE_ROOT,$/;"	e	enum:__anon38	file:
PRESERVE_ROOT	chown.c	/^  PRESERVE_ROOT,$/;"	e	enum:__anon28	file:
PRESERVE_ROOT	rm.c	/^  PRESERVE_ROOT,$/;"	e	enum:__anon47	file:
PRESERVE_STATUS_OPTION	timeout.c	/^      PRESERVE_STATUS_OPTION$/;"	e	enum:__anon17	file:
PRESUME_INPUT_PIPE_OPTION	head.c	/^  PRESUME_INPUT_PIPE_OPTION = CHAR_MAX + 1$/;"	e	enum:__anon55	file:
PRESUME_INPUT_PIPE_OPTION	tail.c	/^  PRESUME_INPUT_PIPE_OPTION,$/;"	e	enum:__anon86	file:
PRESUME_INPUT_TTY_OPTION	rm.c	/^  PRESUME_INPUT_TTY_OPTION$/;"	e	enum:__anon47	file:
PRIMES_PTAB_ENTRIES	factor.c	662;"	d	file:
PRINTENV_FAILURE	printenv.c	/^enum { PRINTENV_FAILURE = 2 };$/;"	e	enum:__anon6	file:
PRINTF_OPTION	stat.c	/^  PRINTF_OPTION = CHAR_MAX + 1$/;"	e	enum:__anon22	file:
PRINT_FIELDS	od.c	397;"	d	file:
PRINT_FLOATTYPE	od.c	418;"	d	file:
PRINT_FLOATTYPE	od.c	437;"	d	file:
PRINT_HARDWARE_PLATFORM	uname.c	83;"	d	file:
PRINT_KERNEL_NAME	uname.c	65;"	d	file:
PRINT_KERNEL_RELEASE	uname.c	71;"	d	file:
PRINT_KERNEL_VERSION	uname.c	74;"	d	file:
PRINT_MACHINE	uname.c	77;"	d	file:
PRINT_NODENAME	uname.c	68;"	d	file:
PRINT_OPERATING_SYSTEM	uname.c	86;"	d	file:
PRINT_PROCESSOR	uname.c	80;"	d	file:
PRINT_TYPE	od.c	415;"	d	file:
PRINT_TYPE	od.c	436;"	d	file:
PROGRAM_NAME	base64.c	38;"	d	file:
PROGRAM_NAME	basename.c	27;"	d	file:
PROGRAM_NAME	cat.c	45;"	d	file:
PROGRAM_NAME	chcon.c	33;"	d	file:
PROGRAM_NAME	chgrp.c	34;"	d	file:
PROGRAM_NAME	chmod.c	36;"	d	file:
PROGRAM_NAME	chown.c	33;"	d	file:
PROGRAM_NAME	chroot.c	32;"	d	file:
PROGRAM_NAME	cksum.c	38;"	d	file:
PROGRAM_NAME	comm.c	34;"	d	file:
PROGRAM_NAME	cp.c	53;"	d	file:
PROGRAM_NAME	csplit.c	38;"	d	file:
PROGRAM_NAME	cut.c	41;"	d	file:
PROGRAM_NAME	date.c	37;"	d	file:
PROGRAM_NAME	dd.c	41;"	d	file:
PROGRAM_NAME	df.c	39;"	d	file:
PROGRAM_NAME	dircolors.c	33;"	d	file:
PROGRAM_NAME	dirname.c	29;"	d	file:
PROGRAM_NAME	du.c	50;"	d	file:
PROGRAM_NAME	echo.c	23;"	d	file:
PROGRAM_NAME	env.c	29;"	d	file:
PROGRAM_NAME	expand.c	47;"	d	file:
PROGRAM_NAME	expr.c	148;"	d	file:
PROGRAM_NAME	factor.c	106;"	d	file:
PROGRAM_NAME	fmt.c	36;"	d	file:
PROGRAM_NAME	fold.c	34;"	d	file:
PROGRAM_NAME	getlimits.c	27;"	d	file:
PROGRAM_NAME	groups.c	32;"	d	file:
PROGRAM_NAME	head.c	42;"	d	file:
PROGRAM_NAME	hostid.c	31;"	d	file:
PROGRAM_NAME	hostname.c	31;"	d	file:
PROGRAM_NAME	id.c	35;"	d	file:
PROGRAM_NAME	install.c	48;"	d	file:
PROGRAM_NAME	join.c	38;"	d	file:
PROGRAM_NAME	kill.c	31;"	d	file:
PROGRAM_NAME	link.c	34;"	d	file:
PROGRAM_NAME	ln.c	38;"	d	file:
PROGRAM_NAME	logname.c	28;"	d	file:
PROGRAM_NAME	ls.c	118;"	d	file:
PROGRAM_NAME	md5sum.c	45;"	d	file:
PROGRAM_NAME	md5sum.c	52;"	d	file:
PROGRAM_NAME	md5sum.c	59;"	d	file:
PROGRAM_NAME	md5sum.c	66;"	d	file:
PROGRAM_NAME	md5sum.c	73;"	d	file:
PROGRAM_NAME	md5sum.c	80;"	d	file:
PROGRAM_NAME	mkdir.c	34;"	d	file:
PROGRAM_NAME	mkfifo.c	31;"	d	file:
PROGRAM_NAME	mknod.c	32;"	d	file:
PROGRAM_NAME	mktemp.c	33;"	d	file:
PROGRAM_NAME	mv.c	38;"	d	file:
PROGRAM_NAME	nice.c	37;"	d	file:
PROGRAM_NAME	nl.c	37;"	d	file:
PROGRAM_NAME	nohup.c	35;"	d	file:
PROGRAM_NAME	nproc.c	31;"	d	file:
PROGRAM_NAME	numfmt.c	33;"	d	file:
PROGRAM_NAME	od.c	34;"	d	file:
PROGRAM_NAME	paste.c	49;"	d	file:
PROGRAM_NAME	pathchk.c	29;"	d	file:
PROGRAM_NAME	pinky.c	33;"	d	file:
PROGRAM_NAME	pr.c	327;"	d	file:
PROGRAM_NAME	printenv.c	41;"	d	file:
PROGRAM_NAME	printf.c	61;"	d	file:
PROGRAM_NAME	ptx.c	37;"	d	file:
PROGRAM_NAME	pwd.c	29;"	d	file:
PROGRAM_NAME	readlink.c	30;"	d	file:
PROGRAM_NAME	realpath.c	31;"	d	file:
PROGRAM_NAME	rm.c	38;"	d	file:
PROGRAM_NAME	rmdir.c	36;"	d	file:
PROGRAM_NAME	runcon.c	60;"	d	file:
PROGRAM_NAME	seq.c	37;"	d	file:
PROGRAM_NAME	setuidgid.c	34;"	d	file:
PROGRAM_NAME	shred.c	72;"	d	file:
PROGRAM_NAME	shuf.c	37;"	d	file:
PROGRAM_NAME	sleep.c	31;"	d	file:
PROGRAM_NAME	sort.c	63;"	d	file:
PROGRAM_NAME	split.c	46;"	d	file:
PROGRAM_NAME	stat.c	171;"	d	file:
PROGRAM_NAME	stdbuf.c	34;"	d	file:
PROGRAM_NAME	stty.c	64;"	d	file:
PROGRAM_NAME	sum.c	34;"	d	file:
PROGRAM_NAME	sync.c	29;"	d	file:
PROGRAM_NAME	tac.c	55;"	d	file:
PROGRAM_NAME	tail.c	66;"	d	file:
PROGRAM_NAME	tee.c	31;"	d	file:
PROGRAM_NAME	test.c	41;"	d	file:
PROGRAM_NAME	test.c	43;"	d	file:
PROGRAM_NAME	timeout.c	76;"	d	file:
PROGRAM_NAME	touch.c	38;"	d	file:
PROGRAM_NAME	tr.c	35;"	d	file:
PROGRAM_NAME	true.c	28;"	d	file:
PROGRAM_NAME	true.c	30;"	d	file:
PROGRAM_NAME	truncate.c	35;"	d	file:
PROGRAM_NAME	tsort.c	38;"	d	file:
PROGRAM_NAME	tty.c	41;"	d	file:
PROGRAM_NAME	uname.c	58;"	d	file:
PROGRAM_NAME	unexpand.c	48;"	d	file:
PROGRAM_NAME	uniq.c	38;"	d	file:
PROGRAM_NAME	unlink.c	34;"	d	file:
PROGRAM_NAME	uptime.c	42;"	d	file:
PROGRAM_NAME	users.c	32;"	d	file:
PROGRAM_NAME	wc.c	47;"	d	file:
PROGRAM_NAME	who.c	45;"	d	file:
PROGRAM_NAME	whoami.c	33;"	d	file:
PROGRAM_NAME	yes.c	30;"	d	file:
PROG_FPRINTF_H	prog-fprintf.h	18;"	d
PS_2	ls.c	/^    PS_2,$/;"	e	enum:parse_state	file:
PS_3	ls.c	/^    PS_3,$/;"	e	enum:parse_state	file:
PS_4	ls.c	/^    PS_4,$/;"	e	enum:parse_state	file:
PS_DONE	ls.c	/^    PS_DONE,$/;"	e	enum:parse_state	file:
PS_FAIL	ls.c	/^    PS_FAIL$/;"	e	enum:parse_state	file:
PS_START	ls.c	/^    PS_START = 1,$/;"	e	enum:parse_state	file:
PUNCT_BONUS	fmt.c	103;"	d	file:
PUSH_CURRENT_DIRED_POS	ls.c	951;"	d	file:
Prompt_action	remove.c	/^enum Prompt_action$/;"	g	file:
QUEUE_SIZE	factor.c	1946;"	d	file:
QUIET_OPTION	md5sum.c	/^  QUIET_OPTION,$/;"	e	enum:__anon7	file:
QUOTING_STYLE_OPTION	ls.c	/^  QUOTING_STYLE_OPTION,$/;"	e	enum:__anon66	file:
Q_FREQ_SIZE	factor.c	1949;"	d	file:
RAGGED_COST	fmt.c	76;"	d	file:
RANDOM_SOURCE_OPTION	shred.c	/^  RANDOM_SOURCE_OPTION = CHAR_MAX + 1$/;"	e	enum:__anon37	file:
RANDOM_SOURCE_OPTION	shuf.c	/^  RANDOM_SOURCE_OPTION = CHAR_MAX + 1$/;"	e	enum:__anon10	file:
RANDOM_SOURCE_OPTION	sort.c	/^  RANDOM_SOURCE_OPTION,$/;"	e	enum:__anon80	file:
RCH_status	chown-core.c	/^enum RCH_status$/;"	g	file:
RC_do_ordinary_chown	chown-core.c	/^    RC_do_ordinary_chown,$/;"	e	enum:RCH_status	file:
RC_error	chown-core.c	/^    RC_error$/;"	e	enum:RCH_status	file:
RC_excluded	chown-core.c	/^    RC_excluded,$/;"	e	enum:RCH_status	file:
RC_inode_changed	chown-core.c	/^    RC_inode_changed,$/;"	e	enum:RCH_status	file:
RC_ok	chown-core.c	/^    RC_ok = 2,$/;"	e	enum:RCH_status	file:
READDIR_LIES_ABOUT_MOUNTPOINT_D_INO	ls.c	144;"	d	file:
READ_BUFSIZE	head.c	210;"	d	file:
REAPED	sort.c	/^enum { UNCOMPRESSED, UNREAPED, REAPED };$/;"	e	enum:__anon81	file:
REFERENCE_FILE_OPTION	chcon.c	/^  REFERENCE_FILE_OPTION$/;"	e	enum:__anon25	file:
REFERENCE_FILE_OPTION	chgrp.c	/^  REFERENCE_FILE_OPTION$/;"	e	enum:__anon18	file:
REFERENCE_FILE_OPTION	chmod.c	/^  REFERENCE_FILE_OPTION$/;"	e	enum:__anon38	file:
REFERENCE_FILE_OPTION	chown.c	/^  REFERENCE_FILE_OPTION$/;"	e	enum:__anon28	file:
REFLINK_ALWAYS	copy.h	/^  REFLINK_ALWAYS$/;"	e	enum:Reflink_type
REFLINK_AUTO	copy.h	/^  REFLINK_AUTO,$/;"	e	enum:Reflink_type
REFLINK_NEVER	copy.h	/^  REFLINK_NEVER,$/;"	e	enum:Reflink_type
REFLINK_OPTION	cp.c	/^  REFLINK_OPTION,$/;"	e	enum:__anon56	file:
RELATIVE_BASE_OPTION	realpath.c	/^  RELATIVE_BASE_OPTION$/;"	e	enum:__anon27	file:
RELATIVE_TO_OPTION	realpath.c	/^  RELATIVE_TO_OPTION = CHAR_MAX + 1,$/;"	e	enum:__anon27	file:
RELEASE_YEAR	local.mk	/^RELEASE_YEAR = \\$/;"	m
RELIABLE_D_INO	ls.c	148;"	d	file:
RELIABLE_D_INO	ls.c	150;"	d	file:
REMOVE_H	remove.h	19;"	d
REPEAT_COUNT_MAXIMUM	tr.c	65;"	d	file:
RETRY_OPTION	tail.c	/^  RETRY_OPTION = CHAR_MAX + 1,$/;"	e	enum:__anon86	file:
REV	stty.c	191;"	d	file:
RE_CHAR_CLASS	tr.c	/^    RE_CHAR_CLASS,$/;"	e	enum:Range_element_type	file:
RE_EQUIV_CLASS	tr.c	/^    RE_EQUIV_CLASS,$/;"	e	enum:Range_element_type	file:
RE_NORMAL_CHAR	tr.c	/^    RE_NORMAL_CHAR,$/;"	e	enum:Range_element_type	file:
RE_RANGE	tr.c	/^    RE_RANGE,$/;"	e	enum:Range_element_type	file:
RE_REPEATED_CHAR	tr.c	/^    RE_REPEATED_CHAR$/;"	e	enum:Range_element_type	file:
RFC_3339_OPTION	date.c	/^  RFC_3339_OPTION = CHAR_MAX + 1$/;"	e	enum:__anon95	file:
RMI_ALWAYS	remove.h	/^  RMI_ALWAYS = 3,$/;"	e	enum:rm_interactive
RMI_NEVER	remove.h	/^  RMI_NEVER$/;"	e	enum:rm_interactive
RMI_SOMETIMES	remove.h	/^  RMI_SOMETIMES,$/;"	e	enum:rm_interactive
RM_ERROR	remove.h	/^  RM_ERROR,$/;"	e	enum:RM_status
RM_NONEMPTY_DIR	remove.h	/^  RM_NONEMPTY_DIR$/;"	e	enum:RM_status
RM_OK	remove.h	/^  RM_OK = 2,$/;"	e	enum:RM_status
RM_USER_DECLINED	remove.h	/^  RM_USER_DECLINED,$/;"	e	enum:RM_status
RM_status	remove.h	/^enum RM_status$/;"	g
ROFF_FORMAT	ptx.c	/^  ROFF_FORMAT,			\/* output for 'troff' or 'nroff' *\/$/;"	e	enum:Format	file:
ROUND_OPTION	numfmt.c	/^  ROUND_OPTION,$/;"	e	enum:__anon43	file:
Range_element_type	tr.c	/^enum Range_element_type$/;"	g	file:
Reflink_type	copy.h	/^enum Reflink_type$/;"	g
SAME_GROUP	copy.c	96;"	d	file:
SAME_OWNER	copy.c	95;"	d	file:
SAME_OWNER_AND_GROUP	copy.c	97;"	d	file:
SANE_SET	stty.c	189;"	d	file:
SANE_UNSET	stty.c	190;"	d	file:
SA_NOCLDSTOP	dd.c	51;"	d	file:
SA_NOCLDSTOP	ls.c	68;"	d	file:
SA_NOCLDSTOP	sort.c	76;"	d	file:
SA_RESETHAND	dd.c	61;"	d	file:
SA_RESTART	ls.c	81;"	d	file:
SA_RESTART	timeout.c	73;"	d	file:
SBIT	cksum.c	52;"	d	file:
SB_F_NAMEMAX	stat.c	141;"	d	file:
SB_F_NAMEMAX	stat.c	81;"	d	file:
SB_F_NAMEMAX	stat.c	92;"	d	file:
SECCLASS_PROCESS	runcon.c	51;"	d	file:
SECTOR_MASK	shred.c	/^enum { SECTOR_MASK = SECTOR_SIZE - 1 };$/;"	e	enum:__anon36	file:
SECTOR_SIZE	shred.c	/^enum { SECTOR_SIZE = 512 };$/;"	e	enum:__anon35	file:
SENTENCE_BONUS	fmt.c	90;"	d	file:
SETUIDGID_FAILURE	setuidgid.c	40;"	d	file:
SET_COMPONENT	chcon.c	105;"	d	file:
SFO_NEW	uniq.c	/^    SFO_NEW$/;"	e	enum:Skip_field_option_type	file:
SFO_NONE	uniq.c	/^    SFO_NONE,$/;"	e	enum:Skip_field_option_type	file:
SFO_OBSOLETE	uniq.c	/^    SFO_OBSOLETE,$/;"	e	enum:Skip_field_option_type	file:
SHELL_SYNTAX_BOURNE	dircolors.c	/^  SHELL_SYNTAX_BOURNE,$/;"	e	enum:Shell_syntax	file:
SHELL_SYNTAX_C	dircolors.c	/^  SHELL_SYNTAX_C,$/;"	e	enum:Shell_syntax	file:
SHELL_SYNTAX_UNKNOWN	dircolors.c	/^  SHELL_SYNTAX_UNKNOWN$/;"	e	enum:Shell_syntax	file:
SHORT	od.c	/^    SHORT,$/;"	e	enum:size_spec	file:
SHORT_COST	fmt.c	73;"	d	file:
SHOW_CONTROL_CHARS_OPTION	ls.c	/^  SHOW_CONTROL_CHARS_OPTION,$/;"	e	enum:__anon66	file:
SIGINFO	dd.c	65;"	d	file:
SIGNED_DECIMAL	od.c	/^    SIGNED_DECIMAL,$/;"	e	enum:output_format	file:
SIZE_FIELD	df.c	/^  SIZE_FIELD,   \/* FS size *\/$/;"	e	enum:__anon51	file:
SIZE_MIN	getlimits.c	50;"	d	file:
SI_OPTION	ls.c	/^  SI_OPTION,$/;"	e	enum:__anon66	file:
SItype	factor.c	/^typedef          int SItype     __attribute__ ((mode (SI)));$/;"	t	file:
SItype	factor.c	/^typedef          long SItype;$/;"	t	file:
SKIP_NON_WHITE	ptx.c	173;"	d	file:
SKIP_SOMETHING	ptx.c	185;"	d	file:
SKIP_WHITE	ptx.c	177;"	d	file:
SKIP_WHITE_BACKWARDS	ptx.c	181;"	d	file:
SMUL_TIME	longlong.h	1379;"	d
SMUL_TIME	longlong.h	1385;"	d
SMUL_TIME	longlong.h	1479;"	d
SORT_FAILURE	sort.c	/^    SORT_FAILURE = 2$/;"	e	enum:__anon76	file:
SORT_OPTION	ls.c	/^  SORT_OPTION,$/;"	e	enum:__anon66	file:
SORT_OPTION	sort.c	/^  SORT_OPTION,$/;"	e	enum:__anon80	file:
SORT_OUT_OF_ORDER	sort.c	/^    SORT_OUT_OF_ORDER = 1,$/;"	e	enum:__anon76	file:
SORT_TABLE	sort.c	581;"	d	file:
SOURCE_FIELD	df.c	/^  SOURCE_FIELD, \/* file system *\/$/;"	e	enum:__anon51	file:
SPARSE_ALWAYS	copy.h	/^  SPARSE_ALWAYS$/;"	e	enum:Sparse_type
SPARSE_AUTO	copy.h	/^  SPARSE_AUTO,$/;"	e	enum:Sparse_type
SPARSE_NEVER	copy.h	/^  SPARSE_NEVER,$/;"	e	enum:Sparse_type
SPARSE_OPTION	cp.c	/^  SPARSE_OPTION,$/;"	e	enum:__anon56	file:
SPARSE_UNUSED	copy.h	/^  SPARSE_UNUSED,$/;"	e	enum:Sparse_type
SQR	fmt.c	69;"	d	file:
SSE_INVALID_NUMBER	numfmt.c	/^  SSE_INVALID_NUMBER,$/;"	e	enum:simple_strtod_error	file:
SSE_INVALID_SUFFIX	numfmt.c	/^  SSE_INVALID_SUFFIX,$/;"	e	enum:simple_strtod_error	file:
SSE_MISSING_I_SUFFIX	numfmt.c	/^  SSE_MISSING_I_SUFFIX$/;"	e	enum:simple_strtod_error	file:
SSE_OK	numfmt.c	/^  SSE_OK = 0,$/;"	e	enum:simple_strtod_error	file:
SSE_OK_PRECISION_LOSS	numfmt.c	/^  SSE_OK_PRECISION_LOSS,$/;"	e	enum:simple_strtod_error	file:
SSE_OVERFLOW	numfmt.c	/^  SSE_OVERFLOW,$/;"	e	enum:simple_strtod_error	file:
SSE_VALID_BUT_FORBIDDEN_SUFFIX	numfmt.c	/^  SSE_VALID_BUT_FORBIDDEN_SUFFIX,$/;"	e	enum:simple_strtod_error	file:
SSIZE_MAX	system.h	388;"	d
SSIZE_MIN	getlimits.c	40;"	d	file:
START_SIZE	csplit.c	61;"	d	file:
START_SIZE	csplit.c	71;"	d	file:
STATFS	stat.c	84;"	d	file:
STATFS	stat.c	86;"	d	file:
STATFS	stat.c	94;"	d	file:
STATFS_FRSIZE	stat.c	125;"	d	file:
STATFS_FRSIZE	stat.c	130;"	d	file:
STATFS_FRSIZE	stat.c	132;"	d	file:
STATFS_FRSIZE	stat.c	88;"	d	file:
STATUS_LAST	dd.c	/^    STATUS_LAST = STATUS_NOCOUNTS,$/;"	e	enum:__anon89	file:
STATUS_NOCOUNTS	dd.c	/^    STATUS_NOCOUNTS = 02,$/;"	e	enum:__anon89	file:
STATUS_NONE	dd.c	/^    STATUS_NONE = STATUS_LAST | (STATUS_LAST - 1)$/;"	e	enum:__anon89	file:
STATUS_NOXFER	dd.c	/^    STATUS_NOXFER = 01,$/;"	e	enum:__anon89	file:
STATUS_OPTION	md5sum.c	/^  STATUS_OPTION = CHAR_MAX + 1,$/;"	e	enum:__anon7	file:
STATXFS_FILE_SYSTEM_TYPE_MEMBER_NAME	stat.c	146;"	d	file:
STATXFS_FILE_SYSTEM_TYPE_MEMBER_NAME	stat.c	149;"	d	file:
STATXFS_FILE_SYSTEM_TYPE_MEMBER_NAME	stat.c	151;"	d	file:
STAT_SQUFOF	factor.c	117;"	d	file:
STREQ	system.h	189;"	d
STREQ_LEN	system.h	190;"	d
STRICT_OPTION	md5sum.c	/^  STRICT_OPTION,$/;"	e	enum:__anon7	file:
STRIP_PROGRAM_OPTION	install.c	/^  STRIP_PROGRAM_OPTION$/;"	e	enum:__anon15	file:
STRIP_TRAILING_SLASHES_OPTION	cp.c	/^  STRIP_TRAILING_SLASHES_OPTION,$/;"	e	enum:__anon56	file:
STRIP_TRAILING_SLASHES_OPTION	mv.c	/^  STRIP_TRAILING_SLASHES_OPTION = CHAR_MAX + 1$/;"	e	enum:__anon40	file:
STRNCMP_LIT	system.h	195;"	d
STRPREFIX	system.h	191;"	d
STRTOX	printf.c	155;"	d	file:
STRUCT_STATVFS	stat.c	123;"	d	file:
STRUCT_STATVFS	stat.c	127;"	d	file:
STRUCT_STATVFS	stat.c	77;"	d	file:
STRUCT_STATXFS_F_FSID_IS_INTEGER	stat.c	124;"	d	file:
STRUCT_STATXFS_F_FSID_IS_INTEGER	stat.c	128;"	d	file:
STRUCT_STATXFS_F_FSID_IS_INTEGER	stat.c	78;"	d	file:
SUBTHREAD_LINES_HEURISTIC	sort.c	/^enum { SUBTHREAD_LINES_HEURISTIC = 128 * 1024 };$/;"	e	enum:__anon74	file:
SUFFIX_OPTION	mktemp.c	/^  SUFFIX_OPTION = CHAR_MAX + 1,$/;"	e	enum:__anon83	file:
SUFFIX_OPTION	numfmt.c	/^  SUFFIX_OPTION,$/;"	e	enum:__anon43	file:
SUPPORT_OLD_MBRTOWC	wc.c	284;"	d	file:
SWAB_ALIGN_OFFSET	dd.c	21;"	d	file:
SWAPLINES	join.c	44;"	d	file:
SWAP_LINES	uniq.c	44;"	d	file:
SYNC_OPTION	df.c	/^  SYNC_OPTION,$/;"	e	enum:__anon53	file:
S_MAGIC_ADFS	fs.h	6;"	d
S_MAGIC_AFFS	fs.h	7;"	d
S_MAGIC_AFS	fs.h	8;"	d
S_MAGIC_ANON_INODE_FS	fs.h	9;"	d
S_MAGIC_AUFS	fs.h	10;"	d
S_MAGIC_AUTOFS	fs.h	11;"	d
S_MAGIC_BDEVFS	fs.h	13;"	d
S_MAGIC_BEFS	fs.h	12;"	d
S_MAGIC_BFS	fs.h	14;"	d
S_MAGIC_BINFMTFS	fs.h	15;"	d
S_MAGIC_BTRFS	fs.h	16;"	d
S_MAGIC_CEPH	fs.h	17;"	d
S_MAGIC_CGROUP	fs.h	18;"	d
S_MAGIC_CIFS	fs.h	19;"	d
S_MAGIC_CODA	fs.h	20;"	d
S_MAGIC_COH	fs.h	21;"	d
S_MAGIC_CRAMFS	fs.h	22;"	d
S_MAGIC_CRAMFS_WEND	fs.h	23;"	d
S_MAGIC_DEBUGFS	fs.h	24;"	d
S_MAGIC_DEVFS	fs.h	25;"	d
S_MAGIC_DEVPTS	fs.h	26;"	d
S_MAGIC_ECRYPTFS	fs.h	27;"	d
S_MAGIC_EFS	fs.h	28;"	d
S_MAGIC_EXT	fs.h	29;"	d
S_MAGIC_EXT2	fs.h	30;"	d
S_MAGIC_EXT2_OLD	fs.h	31;"	d
S_MAGIC_FAT	fs.h	32;"	d
S_MAGIC_FHGFS	fs.h	33;"	d
S_MAGIC_FUSEBLK	fs.h	34;"	d
S_MAGIC_FUSECTL	fs.h	35;"	d
S_MAGIC_FUTEXFS	fs.h	36;"	d
S_MAGIC_GFS	fs.h	37;"	d
S_MAGIC_GPFS	fs.h	38;"	d
S_MAGIC_HFS	fs.h	39;"	d
S_MAGIC_HPFS	fs.h	40;"	d
S_MAGIC_HUGETLBFS	fs.h	41;"	d
S_MAGIC_INOTIFYFS	fs.h	43;"	d
S_MAGIC_ISOFS	fs.h	44;"	d
S_MAGIC_ISOFS_R_WIN	fs.h	45;"	d
S_MAGIC_ISOFS_WIN	fs.h	46;"	d
S_MAGIC_JFFS	fs.h	47;"	d
S_MAGIC_JFFS2	fs.h	48;"	d
S_MAGIC_JFS	fs.h	49;"	d
S_MAGIC_KAFS	fs.h	50;"	d
S_MAGIC_LUSTRE	fs.h	51;"	d
S_MAGIC_MINIX	fs.h	52;"	d
S_MAGIC_MINIX_30	fs.h	53;"	d
S_MAGIC_MINIX_V2	fs.h	54;"	d
S_MAGIC_MINIX_V2_30	fs.h	55;"	d
S_MAGIC_MINIX_V3	fs.h	56;"	d
S_MAGIC_MQUEUE	fs.h	57;"	d
S_MAGIC_MSDOS	fs.h	58;"	d
S_MAGIC_MTD_INODE_FS	fs.h	42;"	d
S_MAGIC_NCP	fs.h	59;"	d
S_MAGIC_NFS	fs.h	60;"	d
S_MAGIC_NFSD	fs.h	61;"	d
S_MAGIC_NILFS	fs.h	62;"	d
S_MAGIC_NTFS	fs.h	63;"	d
S_MAGIC_OCFS2	fs.h	65;"	d
S_MAGIC_OPENPROM	fs.h	64;"	d
S_MAGIC_PANFS	fs.h	66;"	d
S_MAGIC_PIPEFS	fs.h	67;"	d
S_MAGIC_PROC	fs.h	68;"	d
S_MAGIC_PSTOREFS	fs.h	69;"	d
S_MAGIC_QNX4	fs.h	70;"	d
S_MAGIC_QNX6	fs.h	71;"	d
S_MAGIC_RAMFS	fs.h	72;"	d
S_MAGIC_REISERFS	fs.h	73;"	d
S_MAGIC_ROMFS	fs.h	74;"	d
S_MAGIC_RPC_PIPEFS	fs.h	75;"	d
S_MAGIC_SECURITYFS	fs.h	76;"	d
S_MAGIC_SELINUX	fs.h	77;"	d
S_MAGIC_SMB	fs.h	78;"	d
S_MAGIC_SOCKFS	fs.h	79;"	d
S_MAGIC_SQUASHFS	fs.h	80;"	d
S_MAGIC_SYSFS	fs.h	81;"	d
S_MAGIC_SYSV2	fs.h	82;"	d
S_MAGIC_SYSV4	fs.h	83;"	d
S_MAGIC_TMPFS	fs.h	84;"	d
S_MAGIC_UDF	fs.h	85;"	d
S_MAGIC_UFS	fs.h	86;"	d
S_MAGIC_UFS_BYTESWAPPED	fs.h	87;"	d
S_MAGIC_USBDEVFS	fs.h	88;"	d
S_MAGIC_V9FS	fs.h	89;"	d
S_MAGIC_VMHGFS	fs.h	90;"	d
S_MAGIC_VXFS	fs.h	91;"	d
S_MAGIC_VZFS	fs.h	92;"	d
S_MAGIC_XENFS	fs.h	93;"	d
S_MAGIC_XENIX	fs.h	94;"	d
S_MAGIC_XFS	fs.h	95;"	d
S_MAGIC_XIAFS	fs.h	96;"	d
S_MAGIC_ZFS	fs.h	97;"	d
Shell_syntax	dircolors.c	/^enum Shell_syntax$/;"	g	file:
Skip_field_option_type	uniq.c	/^enum Skip_field_option_type$/;"	g	file:
Sparse_type	copy.h	/^enum Sparse_type$/;"	g
Spec_list	tr.c	/^struct Spec_list$/;"	s	file:
Spec_list::has_char_class	tr.c	/^    bool has_char_class;$/;"	m	struct:Spec_list	file:	access:public
Spec_list::has_equiv_class	tr.c	/^    bool has_equiv_class;$/;"	m	struct:Spec_list	file:	access:public
Spec_list::has_restricted_char_class	tr.c	/^    bool has_restricted_char_class;$/;"	m	struct:Spec_list	file:	access:public
Spec_list::head	tr.c	/^    struct List_element *head;$/;"	m	struct:Spec_list	typeref:struct:Spec_list::List_element	file:	access:public
Spec_list::indefinite_repeat_element	tr.c	/^    struct List_element *indefinite_repeat_element;$/;"	m	struct:Spec_list	typeref:struct:Spec_list::List_element	file:	access:public
Spec_list::length	tr.c	/^    count length;$/;"	m	struct:Spec_list	file:	access:public
Spec_list::n_indefinite_repeats	tr.c	/^    size_t n_indefinite_repeats;$/;"	m	struct:Spec_list	file:	access:public
Spec_list::state	tr.c	/^    count state;$/;"	m	struct:Spec_list	file:	access:public
Spec_list::tail	tr.c	/^    struct List_element *tail;$/;"	m	struct:Spec_list	typeref:struct:Spec_list::List_element	file:	access:public
Split_type	split.c	/^enum Split_type$/;"	g	file:
Src_to_dest	cp-hash.c	/^struct Src_to_dest$/;"	s	file:
Src_to_dest::name	cp-hash.c	/^  char *name;$/;"	m	struct:Src_to_dest	file:	access:public
Src_to_dest::st_dev	cp-hash.c	/^  dev_t st_dev;$/;"	m	struct:Src_to_dest	file:	access:public
Src_to_dest::st_ino	cp-hash.c	/^  ino_t st_ino;$/;"	m	struct:Src_to_dest	file:	access:public
TABWIDTH	fmt.c	126;"	d	file:
TAB_DEFAULT	sort.c	/^enum { TAB_DEFAULT = CHAR_MAX + 1 };$/;"	e	enum:__anon79	file:
TAB_WIDTH	fold.c	31;"	d	file:
TAB_WIDTH	pr.c	598;"	d	file:
TAG_OPTION	md5sum.c	/^  TAG_OPTION$/;"	e	enum:__anon7	file:
TARGET_FIELD	df.c	/^  TARGET_FIELD  \/* mount point *\/$/;"	e	enum:__anon51	file:
TEST_FAILURE	test.c	/^enum { TEST_TRUE, TEST_FALSE, TEST_FAILURE };$/;"	e	enum:__anon59	file:
TEST_FALSE	test.c	/^enum { TEST_TRUE, TEST_FALSE, TEST_FAILURE };$/;"	e	enum:__anon59	file:
TEST_STANDALONE	test.c	33;"	d	file:
TEST_TRUE	test.c	/^enum { TEST_TRUE, TEST_FALSE, TEST_FAILURE };$/;"	e	enum:__anon59	file:
TEX_FORMAT	ptx.c	/^  TEX_FORMAT			\/* output for 'TeX' or 'LaTeX' *\/$/;"	e	enum:Format	file:
TIME_OPTION	du.c	/^  TIME_OPTION,$/;"	e	enum:__anon39	file:
TIME_OPTION	ls.c	/^  TIME_OPTION,$/;"	e	enum:__anon66	file:
TIME_OPTION	touch.c	/^  TIME_OPTION = CHAR_MAX + 1$/;"	e	enum:__anon62	file:
TIME_SPEC_DATE	date.c	/^  TIME_SPEC_DATE,$/;"	e	enum:Time_spec	file:
TIME_SPEC_HOURS	date.c	/^  TIME_SPEC_HOURS,$/;"	e	enum:Time_spec	file:
TIME_SPEC_MINUTES	date.c	/^  TIME_SPEC_MINUTES$/;"	e	enum:Time_spec	file:
TIME_SPEC_NS	date.c	/^  TIME_SPEC_NS,$/;"	e	enum:Time_spec	file:
TIME_SPEC_SECONDS	date.c	/^  TIME_SPEC_SECONDS,$/;"	e	enum:Time_spec	file:
TIME_STAMP_LEN_MAXIMUM	ls.c	/^enum { TIME_STAMP_LEN_MAXIMUM = MAX (1000, INT_STRLEN_BOUND (time_t)) };$/;"	e	enum:__anon64	file:
TIME_STYLE_OPTION	du.c	/^  TIME_STYLE_OPTION$/;"	e	enum:__anon39	file:
TIME_STYLE_OPTION	ls.c	/^  TIME_STYLE_OPTION$/;"	e	enum:__anon66	file:
TIME_T_MAX	getlimits.c	32;"	d	file:
TIME_T_MIN	getlimits.c	36;"	d	file:
TMPDIR_OPTION	mktemp.c	/^  TMPDIR_OPTION$/;"	e	enum:__anon83	file:
TOTAL_OPTION	df.c	/^  TOTAL_OPTION,$/;"	e	enum:__anon53	file:
TO_OPTION	numfmt.c	/^  TO_OPTION,$/;"	e	enum:__anon43	file:
TO_UNIT_OPTION	numfmt.c	/^  TO_UNIT_OPTION,$/;"	e	enum:__anon43	file:
TRADITIONAL_OPTION	od.c	/^  TRADITIONAL_OPTION = CHAR_MAX + 1$/;"	e	enum:__anon49	file:
TTY_FAILURE	tty.c	/^    TTY_FAILURE = 2,$/;"	e	enum:__anon41	file:
TTY_WRITE_ERROR	tty.c	/^    TTY_WRITE_ERROR = 3$/;"	e	enum:__anon41	file:
TYPE	expr.c	/^typedef enum valtype TYPE;$/;"	t	typeref:enum:valtype	file:
TZSET	date.c	105;"	d	file:
TZSET	date.c	107;"	d	file:
T_NO	remove.c	/^    T_NO,$/;"	e	enum:Ternary	file:
T_UNKNOWN	remove.c	/^    T_UNKNOWN = 2,$/;"	e	enum:Ternary	file:
T_YES	remove.c	/^    T_YES$/;"	e	enum:Ternary	file:
Ternary	remove.c	/^enum Ternary$/;"	g	file:
Ternary	remove.c	/^typedef enum Ternary Ternary;$/;"	t	typeref:enum:Ternary	file:
Text	nl.c	/^  Header, Body, Footer, Text$/;"	e	enum:section	file:
Time_spec	date.c	/^enum Time_spec$/;"	g	file:
UCHAR_LIM	sort.c	92;"	d	file:
UCHAR_MIN	getlimits.c	51;"	d	file:
UDIV_NEEDS_NORMALIZATION	longlong.h	2059;"	d
UDIV_NEEDS_NORMALIZATION	longlong.h	210;"	d
UDIV_NEEDS_NORMALIZATION	longlong.h	2139;"	d
UDIV_NEEDS_NORMALIZATION	longlong.h	273;"	d
UDIV_NEEDS_NORMALIZATION	longlong.h	359;"	d
UDIV_NEEDS_NORMALIZATION	longlong.h	484;"	d
UDIV_PREINV_ALWAYS	longlong.h	209;"	d
UDIV_PREINV_ALWAYS	longlong.h	2145;"	d
UDIV_PREINV_ALWAYS	longlong.h	272;"	d
UDIV_PREINV_ALWAYS	longlong.h	358;"	d
UDIV_PREINV_ALWAYS	longlong.h	483;"	d
UDIV_TIME	longlong.h	1121;"	d
UDIV_TIME	longlong.h	1156;"	d
UDIV_TIME	longlong.h	1210;"	d
UDIV_TIME	longlong.h	1213;"	d
UDIV_TIME	longlong.h	1236;"	d
UDIV_TIME	longlong.h	1259;"	d
UDIV_TIME	longlong.h	1380;"	d
UDIV_TIME	longlong.h	1388;"	d
UDIV_TIME	longlong.h	1480;"	d
UDIV_TIME	longlong.h	1542;"	d
UDIV_TIME	longlong.h	1612;"	d
UDIV_TIME	longlong.h	1624;"	d
UDIV_TIME	longlong.h	1676;"	d
UDIV_TIME	longlong.h	1741;"	d
UDIV_TIME	longlong.h	211;"	d
UDIV_TIME	longlong.h	2154;"	d
UDIV_TIME	longlong.h	274;"	d
UDIV_TIME	longlong.h	361;"	d
UDIV_TIME	longlong.h	485;"	d
UDIV_TIME	longlong.h	513;"	d
UDIV_TIME	longlong.h	650;"	d
UDIV_TIME	longlong.h	653;"	d
UDIV_TIME	longlong.h	998;"	d
UDItype	factor.c	/^typedef unsigned int UDItype    __attribute__ ((mode (DI)));$/;"	t	file:
UDItype	factor.c	/^typedef unsigned long int UDItype;$/;"	t	file:
UDItype	factor.c	/^typedef unsigned long long int UDItype;$/;"	t	file:
UDWtype	factor.c	146;"	d	file:
UHWtype	factor.c	145;"	d	file:
UID_T_MAX	system.h	400;"	d
UID_T_MIN	getlimits.c	55;"	d	file:
UINTMAX_MIN	getlimits.c	54;"	d	file:
UINT_MIN	getlimits.c	52;"	d	file:
ULONG_MIN	getlimits.c	53;"	d	file:
UL_LOWER	tr.c	/^    UL_LOWER,$/;"	e	enum:Upper_Lower_class	file:
UL_NONE	tr.c	/^    UL_NONE$/;"	e	enum:Upper_Lower_class	file:
UL_UPPER	tr.c	/^    UL_UPPER,$/;"	e	enum:Upper_Lower_class	file:
UMUL_TIME	longlong.h	1116;"	d
UMUL_TIME	longlong.h	1155;"	d
UMUL_TIME	longlong.h	1209;"	d
UMUL_TIME	longlong.h	1212;"	d
UMUL_TIME	longlong.h	1235;"	d
UMUL_TIME	longlong.h	1258;"	d
UMUL_TIME	longlong.h	1372;"	d
UMUL_TIME	longlong.h	1382;"	d
UMUL_TIME	longlong.h	1472;"	d
UMUL_TIME	longlong.h	1541;"	d
UMUL_TIME	longlong.h	1561;"	d
UMUL_TIME	longlong.h	1609;"	d
UMUL_TIME	longlong.h	1633;"	d
UMUL_TIME	longlong.h	1730;"	d
UMUL_TIME	longlong.h	193;"	d
UMUL_TIME	longlong.h	2150;"	d
UMUL_TIME	longlong.h	318;"	d
UMUL_TIME	longlong.h	474;"	d
UMUL_TIME	longlong.h	505;"	d
UMUL_TIME	longlong.h	649;"	d
UMUL_TIME	longlong.h	652;"	d
UMUL_TIME	longlong.h	995;"	d
UNAME_ARCH	uname.h	5;"	d
UNAME_HARDWARE_PLATFORM	uname.c	38;"	d	file:
UNAME_PROCESSOR	uname.c	39;"	d	file:
UNAME_PROCESSOR	uname.c	42;"	d	file:
UNAME_UNAME	uname.h	2;"	d
UNCOMPRESSED	sort.c	/^enum { UNCOMPRESSED, UNREAPED, REAPED };$/;"	e	enum:__anon81	file:
UNKNOWN_FORMAT	ptx.c	/^  UNKNOWN_FORMAT,		\/* output format still unknown *\/$/;"	e	enum:Format	file:
UNKNOWN_SECURITY_CONTEXT	ls.c	/^static char UNKNOWN_SECURITY_CONTEXT[] = "?";$/;"	v	file:
UNLIKELY	factor.c	716;"	d	file:
UNLIKELY	factor.c	719;"	d	file:
UNLINK_DEST_BEFORE_OPENING	cp.c	/^  UNLINK_DEST_BEFORE_OPENING$/;"	e	enum:__anon56	file:
UNREAPED	sort.c	/^enum { UNCOMPRESSED, UNREAPED, REAPED };$/;"	e	enum:__anon81	file:
UNSIGNED_DECIMAL	od.c	/^    UNSIGNED_DECIMAL,$/;"	e	enum:output_format	file:
UPDATE_STATUS	remove.h	86;"	d
UQItype	factor.c	/^typedef unsigned char UQItype;$/;"	t	file:
UQItype	factor.c	/^typedef unsigned int UQItype    __attribute__ ((mode (QI)));$/;"	t	file:
USAGE_BUILTIN_WARNING	system.h	342;"	d
USED_FIELD	df.c	/^  USED_FIELD,   \/* FS size used  *\/$/;"	e	enum:__anon51	file:
USERSPEC	chroot.c	/^  USERSPEC$/;"	e	enum:__anon94	file:
USE_ACL	copy.c	92;"	d	file:
USE_LONGLONG_H	factor.c	127;"	d	file:
USE_STATVFS	stat.c	26;"	d	file:
USE_STATVFS	stat.c	28;"	d	file:
USItype	factor.c	/^typedef unsigned int USItype    __attribute__ ((mode (SI)));$/;"	t	file:
USItype	factor.c	/^typedef unsigned long int USItype;$/;"	t	file:
UT_ID	who.c	94;"	d	file:
UT_ID	who.c	96;"	d	file:
UT_TYPE_DEAD_PROCESS	who.c	71;"	d	file:
UT_TYPE_DEAD_PROCESS	who.c	73;"	d	file:
UT_TYPE_INIT_PROCESS	who.c	59;"	d	file:
UT_TYPE_INIT_PROCESS	who.c	61;"	d	file:
UT_TYPE_LOGIN_PROCESS	who.c	65;"	d	file:
UT_TYPE_LOGIN_PROCESS	who.c	67;"	d	file:
UT_TYPE_NEW_TIME	who.c	77;"	d	file:
UT_TYPE_NEW_TIME	who.c	79;"	d	file:
UT_TYPE_RUN_LVL	who.c	53;"	d	file:
UT_TYPE_RUN_LVL	who.c	55;"	d	file:
UWtype	factor.c	144;"	d	file:
Upper_Lower_class	tr.c	/^enum Upper_Lower_class$/;"	g	file:
V	ls.c	/^typedef void const *V;$/;"	t	file:
VALID_REFLINK_MODE	copy.h	89;"	d
VALID_SPARSE_MODE	copy.h	84;"	d
VALID_STATUS	remove.h	83;"	d
VALUE	expr.c	/^typedef struct valinfo VALUE;$/;"	t	typeref:struct:valinfo	file:
VERBOSE_OPTION	split.c	/^  VERBOSE_OPTION = CHAR_MAX + 1,$/;"	e	enum:__anon72	file:
VERBOSE_UPDATE	shred.c	/^enum { VERBOSE_UPDATE = 5 };$/;"	e	enum:__anon34	file:
VERSION_OPTION_DESCRIPTION	system.h	350;"	d
VFLUSHO	stty.c	149;"	d	file:
VFLUSHO	stty.c	152;"	d	file:
VREPRINT	stty.c	134;"	d	file:
VSWTCH	stty.c	107;"	d	file:
VSWTCH	stty.c	111;"	d	file:
VWERASE	stty.c	128;"	d	file:
V_changes_only	chmod.c	/^  V_changes_only,$/;"	e	enum:Verbosity	file:
V_changes_only	chown-core.h	/^  V_changes_only,$/;"	e	enum:Verbosity
V_high	chmod.c	/^  V_high,$/;"	e	enum:Verbosity	file:
V_high	chown-core.h	/^  V_high,$/;"	e	enum:Verbosity
V_off	chmod.c	/^  V_off$/;"	e	enum:Verbosity	file:
V_off	chown-core.h	/^  V_off$/;"	e	enum:Verbosity
Verbosity	chmod.c	/^enum Verbosity$/;"	g	file:
Verbosity	chown-core.h	/^enum Verbosity$/;"	g
W	factor.c	/^enum { W = sizeof (uintmax_t) * CHAR_BIT };$/;"	e	enum:__anon85	file:
WIDE_UINT_BITS	primes.h	3;"	d
WIDOW_COST	fmt.c	83;"	d	file:
WIDTH	fmt.c	44;"	d	file:
WORD	fmt.c	/^typedef struct Word WORD;$/;"	t	typeref:struct:Word	file:
WORD	ptx.c	/^WORD;$/;"	t	typeref:struct:__anon30	file:
WORD_TABLE	ptx.c	/^WORD_TABLE;$/;"	t	typeref:struct:__anon31	file:
WRITESIZE	tac.c	78;"	d	file:
W_TYPE_SIZE	factor.c	137;"	d	file:
W_TYPE_SIZE	factor.c	139;"	d	file:
W_TYPE_SIZE	factor.c	141;"	d	file:
W_TYPE_SIZE	factor.c	197;"	d	file:
Word	fmt.c	/^struct Word$/;"	s	file:
Word::best_cost	fmt.c	/^    COST best_cost;		\/* cost of best paragraph starting here *\/$/;"	m	struct:Word	file:	access:public
Word::final	fmt.c	/^    unsigned int final:1;	\/* end of sentence *\/$/;"	m	struct:Word	file:	access:public
Word::length	fmt.c	/^    int length;			\/* length of this word *\/$/;"	m	struct:Word	file:	access:public
Word::line_length	fmt.c	/^    int line_length;		\/* length of the best line starting here *\/$/;"	m	struct:Word	file:	access:public
Word::next_break	fmt.c	/^    WORD *next_break;		\/* break which achieves best_cost *\/$/;"	m	struct:Word	file:	access:public
Word::paren	fmt.c	/^    unsigned int paren:1;	\/* starts with open paren *\/$/;"	m	struct:Word	file:	access:public
Word::period	fmt.c	/^    unsigned int period:1;	\/* ends in [.?!])* *\/$/;"	m	struct:Word	file:	access:public
Word::punct	fmt.c	/^    unsigned int punct:1;	\/* ends in punctuation *\/$/;"	m	struct:Word	file:	access:public
Word::space	fmt.c	/^    int space;			\/* the size of the following space *\/$/;"	m	struct:Word	file:	access:public
Word::text	fmt.c	/^    const char *text;		\/* the text of the word *\/$/;"	m	struct:Word	file:	access:public
X2NREALLOC	system.h	247;"	d
X2REALLOC	system.h	254;"	d
XSTAT	copy.h	264;"	d
_	system.h	175;"	d
_D_EXACT_NAMLEN	system.h	119;"	d
_LINUX_FIEMAP_H	fiemap.h	10;"	d
_PC_NAME_MAX	pathchk.c	56;"	d	file:
_PC_PATH_MAX	pathchk.c	57;"	d	file:
_POSIX_NAME_MAX	pathchk.c	40;"	d	file:
_POSIX_PATH_MAX	pathchk.c	37;"	d	file:
_POSIX_VDISABLE	stty.c	69;"	d	file:
_RELPATH_H	relpath.h	20;"	d
_XOPEN_SOURCE	stty.c	33;"	d	file:
__AND_CLOBBER_CC	longlong.h	371;"	d
__AND_CLOBBER_CC	longlong.h	374;"	d
__BITS4	longlong.h	42;"	d
__CLOBBER_CC	longlong.h	370;"	d
__CLOBBER_CC	longlong.h	373;"	d
__GMP_DECLSPEC	factor.c	167;"	d	file:
__GMP_GNUC_PREREQ	factor.c	170;"	d	file:
__MPN	longlong.h	50;"	d
__anon20::optarg	stdbuf.c	/^  char *optarg;$/;"	m	struct:__anon20	file:	access:public
__anon20::optc	stdbuf.c	/^  int optc;$/;"	m	struct:__anon20	file:	access:public
__anon20::size	stdbuf.c	/^  size_t size;$/;"	m	struct:__anon20	file:	access:public
__anon29::end	ptx.c	/^    char *end;			\/* pointer to end + 1 of region *\/$/;"	m	struct:__anon29	file:	access:public
__anon29::start	ptx.c	/^    char *start;		\/* pointer to beginning of region *\/$/;"	m	struct:__anon29	file:	access:public
__anon30::size	ptx.c	/^    short int size;		\/* length of the region *\/$/;"	m	struct:__anon30	file:	access:public
__anon30::start	ptx.c	/^    char *start;		\/* pointer to beginning of region *\/$/;"	m	struct:__anon30	file:	access:public
__anon31::alloc	ptx.c	/^    size_t alloc;		\/* allocated length *\/$/;"	m	struct:__anon31	file:	access:public
__anon31::length	ptx.c	/^    size_t length;		\/* number of used entries *\/$/;"	m	struct:__anon31	file:	access:public
__anon31::start	ptx.c	/^    WORD *start;		\/* array of WORDs *\/$/;"	m	struct:__anon31	file:	access:public
__anon32::key	ptx.c	/^    WORD key;			\/* description of the keyword *\/$/;"	m	struct:__anon32	file:	access:public
__anon32::left	ptx.c	/^    DELTA left;			\/* distance to left context start *\/$/;"	m	struct:__anon32	file:	access:public
__anon32::reference	ptx.c	/^    int reference;		\/* reference descriptor *\/$/;"	m	struct:__anon32	file:	access:public
__anon32::right	ptx.c	/^    DELTA right;		\/* distance to right context end *\/$/;"	m	struct:__anon32	file:	access:public
__attribute__	system.h	420;"	d
__clz_tab	factor.c	168;"	d	file:
__ll_B	factor.c	198;"	d	file:
__ll_B	longlong.h	43;"	d
__ll_highpart	factor.c	200;"	d	file:
__ll_highpart	longlong.h	45;"	d
__ll_lowpart	factor.c	199;"	d	file:
__ll_lowpart	longlong.h	44;"	d
__udiv_qrnnd_c	longlong.h	2005;"	d
__umulsidi3	longlong.h	1060;"	d
__umulsidi3	longlong.h	1276;"	d
__umulsidi3	longlong.h	1852;"	d
__umulsidi3	longlong.h	577;"	d
_ct_	sort.c	570;"	d	file:
_ct_	sort.c	572;"	d	file:
_ct_	sort.c	576;"	d	file:
_ct_	sort.c	578;"	d	file:
_invalid	numfmt.c	/^static enum inval_type _invalid = inval_abort;$/;"	v	typeref:enum:inval_type	file:
_round	numfmt.c	/^static enum round_type _round = round_from_zero;$/;"	v	typeref:enum:round_type	file:
_st_	sort.c	591;"	d	file:
_st_	sort.c	593;"	d	file:
_st_	sort.c	597;"	d	file:
_st_	sort.c	599;"	d	file:
abandon_move	copy.c	/^abandon_move (const struct cp_options *x,$/;"	f	file:	signature:(const struct cp_options *x, char const *dst_name, struct stat const *dst_sb)
abbreviate_duplicate_blocks	od.c	/^static bool abbreviate_duplicate_blocks = true;$/;"	v	file:
abmon	ls.c	/^static char abmon[12][MAX_MON_WIDTH * 2 * MB_LEN_MAX + 1];$/;"	v	file:
abmon_init	ls.c	/^abmon_init (void)$/;"	f	file:	signature:(void)
absld	numfmt.c	/^absld (long double val)$/;"	f	file:	signature:(long double val)
acl_type	ls.c	/^    enum acl_type acl_type;$/;"	m	struct:fileinfo	typeref:enum:fileinfo::acl_type	file:	access:public
acl_type	ls.c	/^enum acl_type$/;"	g	file:
active_dir_set	ls.c	/^static Hash_table *active_dir_set;$/;"	v	file:
add_excluded_fs_type	df.c	/^add_excluded_fs_type (const char *fstype)$/;"	f	file:	signature:(const char *fstype)
add_field	join.c	/^add_field (int file, size_t field)$/;"	f	file:	signature:(int file, size_t field)
add_field_list	join.c	/^add_field_list (char *str)$/;"	f	file:	signature:(char *str)
add_file_name	join.c	/^add_file_name (char *name, char *names[2],$/;"	f	file:	signature:(char *name, char *names[2], int operand_status[2], int joption_count[2], int *nfiles, int *prev_optc_status, int *optc_status)
add_fs_type	df.c	/^add_fs_type (const char *fstype)$/;"	f	file:	signature:(const char *fstype)
add_ignore_pattern	ls.c	/^add_ignore_pattern (const char *pattern)$/;"	f	file:	signature:(const char *pattern)
add_ignore_pattern	ls.c	/^static void add_ignore_pattern (const char *pattern);$/;"	p	file:	signature:(const char *pattern)
add_line_number	pr.c	/^add_line_number (COLUMN *p)$/;"	f	file:	signature:(COLUMN *p)
add_line_number	pr.c	/^static void add_line_number (COLUMN *p);$/;"	p	file:	signature:(COLUMN *p)
add_ssaaaa	factor.c	305;"	d	file:
add_ssaaaa	longlong.h	1003;"	d
add_ssaaaa	longlong.h	1045;"	d
add_ssaaaa	longlong.h	1096;"	d
add_ssaaaa	longlong.h	1176;"	d
add_ssaaaa	longlong.h	1320;"	d
add_ssaaaa	longlong.h	1398;"	d
add_ssaaaa	longlong.h	1484;"	d
add_ssaaaa	longlong.h	1506;"	d
add_ssaaaa	longlong.h	1565;"	d
add_ssaaaa	longlong.h	1748;"	d
add_ssaaaa	longlong.h	1769;"	d
add_ssaaaa	longlong.h	1811;"	d
add_ssaaaa	longlong.h	1922;"	d
add_ssaaaa	longlong.h	378;"	d
add_ssaaaa	longlong.h	408;"	d
add_ssaaaa	longlong.h	427;"	d
add_ssaaaa	longlong.h	532;"	d
add_ssaaaa	longlong.h	607;"	d
add_ssaaaa	longlong.h	631;"	d
add_ssaaaa	longlong.h	682;"	d
add_ssaaaa	longlong.h	694;"	d
add_ssaaaa	longlong.h	812;"	d
add_ssaaaa	longlong.h	862;"	d
add_tab_stop	expand.c	/^add_tab_stop (uintmax_t tabval)$/;"	f	file:	signature:(uintmax_t tabval)
add_tab_stop	unexpand.c	/^add_tab_stop (uintmax_t tabval)$/;"	f	file:	signature:(uintmax_t tabval)
add_temp_dir	sort.c	/^add_temp_dir (char const *dir)$/;"	f	file:	signature:(char const *dir)
add_to_grand_total	df.c	/^add_to_grand_total (struct field_values_t *bv, struct field_values_t *iv)$/;"	f	file:	signature:(struct field_values_t *bv, struct field_values_t *iv)
add_uint_with_neg_flag	df.c	/^add_uint_with_neg_flag (uintmax_t *dest, bool *dest_neg,$/;"	f	file:	signature:(uintmax_t *dest, bool *dest_neg, uintmax_t src, bool src_neg)
additional_suffix	split.c	/^static char const *additional_suffix;$/;"	v	file:
addmod	factor.c	376;"	d	file:
addmod2	factor.c	382;"	d	file:
address_base	od.c	/^static int address_base;$/;"	v	file:
address_pad_len	od.c	/^static int address_pad_len;$/;"	v	file:
adjust_column	fold.c	/^adjust_column (size_t column, char c)$/;"	f	file:	signature:(size_t column, char c)
advance	test.c	/^advance (bool f)$/;"	f	file:	signature:(bool f)
advance_input_after_read_error	dd.c	/^advance_input_after_read_error (size_t nbytes)$/;"	f	file:	signature:(size_t nbytes)
advance_input_offset	dd.c	/^advance_input_offset (uintmax_t offset)$/;"	f	file:	signature:(uintmax_t offset)
advance_seq	join.c	/^advance_seq (FILE *fp, struct seq *seq, bool first, int whichfile)$/;"	f	file:	signature:(FILE *fp, struct seq *seq, bool first, int whichfile)
affect_symlink_referent	chcon.c	/^static bool affect_symlink_referent;$/;"	v	file:
affect_symlink_referent	chown-core.h	/^  bool affect_symlink_referent;$/;"	m	struct:Chown_option	access:public
alg	factor.c	/^static enum alg_type alg;$/;"	v	typeref:enum:alg_type	file:
alg_type	factor.c	/^enum alg_type { ALG_POLLARD_RHO = 1, ALG_SQUFOF = 2 };$/;"	g	file:
align	df.c	/^  mbs_align_t align;  \/* Alignment for this field.  *\/$/;"	m	struct:field_data_t	file:	access:public
align_column	pr.c	/^align_column (COLUMN *p)$/;"	f	file:	signature:(COLUMN *p)
align_empty_cols	pr.c	/^static bool align_empty_cols;$/;"	v	file:
align_nstrftime	ls.c	/^align_nstrftime (char *buf, size_t size, char const *fmt, struct tm const *tm,$/;"	f	file:	signature:(char *buf, size_t size, char const *fmt, struct tm const *tm, int __utc, int __ns)
all	stty.c	/^    changed, all, recoverable	\/* Default, -a, -g.  *\/$/;"	e	enum:output_type	file:
all_args_string	df.c	/^static char const *all_args_string =$/;"	v	file:
all_digits_p	seq.c	/^all_digits_p (char const *s)$/;"	f	file:	signature:(char const *s)
all_programs	local.mk	/^all_programs = \\$/;"	m
alloc	join.c	/^    size_t alloc;			\/* Elements allocated in 'lines'.  *\/$/;"	m	struct:seq	file:	access:public
alloc	ptx.c	/^    size_t alloc;		\/* allocated length *\/$/;"	m	struct:__anon31	file:	access:public
alloc	sort.c	/^  size_t alloc;			\/* Number of bytes allocated. *\/$/;"	m	struct:buffer	file:	access:public
alloc_field	df.c	/^alloc_field (int f, const char *c)$/;"	f	file:	signature:(int f, const char *c)
alloc_table_row	df.c	/^alloc_table_row (void)$/;"	f	file:	signature:(void)
always	head.c	/^  multiple_files, always, never$/;"	e	enum:header_mode	file:
always	tail.c	/^  multiple_files, always, never$/;"	e	enum:header_mode	file:
amtime_now	touch.c	/^static bool amtime_now;$/;"	v	file:
ancestor_mode	mkdir.c	/^  mode_t ancestor_mode;$/;"	m	struct:mkdir_options	file:	access:public
and	test.c	/^and (void)$/;"	f	file:	signature:(void)
and	test.c	/^static bool and (void);$/;"	p	file:	signature:(void)
announce_mkdir	install.c	/^announce_mkdir (char const *dir, void *options)$/;"	f	file:	signature:(char const *dir, void *options)
announce_mkdir	mkdir.c	/^announce_mkdir (char const *dir, void *options)$/;"	f	file:	signature:(char const *dir, void *options)
any_has_acl	ls.c	/^static bool any_has_acl;$/;"	v	file:
any_live_files	tail.c	/^any_live_files (const struct File_spec *f, size_t n_files)$/;"	f	file:	signature:(const struct File_spec *f, size_t n_files)
any_remote_file	tail.c	/^any_remote_file (const struct File_spec *f, size_t n_files)$/;"	f	file:	signature:(const struct File_spec *f, size_t n_files)
apparent_size	du.c	/^static bool apparent_size = false;$/;"	v	file:
append	tee.c	/^static bool append;$/;"	v	file:
append_char_class	tr.c	/^append_char_class (struct Spec_list *list,$/;"	f	file:	signature:(struct Spec_list *list, char const *char_class_str, size_t len)
append_equiv_class	tr.c	/^append_equiv_class (struct Spec_list *list,$/;"	f	file:	signature:(struct Spec_list *list, char const *equiv_class_str, size_t len)
append_normal_char	tr.c	/^append_normal_char (struct Spec_list *list, unsigned char c)$/;"	f	file:	signature:(struct Spec_list *list, unsigned char c)
append_quoted	dircolors.c	/^append_quoted (const char *str)$/;"	f	file:	signature:(const char *str)
append_range	tr.c	/^append_range (struct Spec_list *list, unsigned char first, unsigned char last)$/;"	f	file:	signature:(struct Spec_list *list, unsigned char first, unsigned char last)
append_repeated_char	tr.c	/^append_repeated_char (struct Spec_list *list, unsigned char the_char,$/;"	f	file:	signature:(struct Spec_list *list, unsigned char the_char, count repeat_count)
apply_mode	libstdbuf.c	/^apply_mode (FILE *stream, const char *mode)$/;"	f	file:	signature:(FILE *stream, const char *mode)
apply_suffix	sleep.c	/^apply_suffix (double *x, char suffix_char)$/;"	f	file:	signature:(double *x, char suffix_char)
apply_time_suffix	timeout.c	/^apply_time_suffix (double *x, char suffix_char)$/;"	f	file:	signature:(double *x, char suffix_char)
apply_translations	dd.c	/^apply_translations (void)$/;"	f	file:	signature:(void)
arch_long_options	uname.c	/^static struct option const arch_long_options[] =$/;"	v	file:
arg	df.c	/^  char const *arg;$/;"	m	struct:field_data_t	file:	access:public
arg_directory	ls.c	/^    arg_directory$/;"	e	enum:filetype	file:
argc	test.c	/^static int argc;	\/* The number of arguments present in ARGV. *\/$/;"	v	file:
argnum	csplit.c	/^  int argnum;			\/* ARGV index. *\/$/;"	m	struct:control	file:	access:public
args	expr.c	/^static char **args;$/;"	v	file:
argv	test.c	/^static char **argv;	\/* The argument list. *\/$/;"	v	file:
ascii_to_ebcdic	dd.c	/^static char const ascii_to_ebcdic[] =$/;"	v	file:
ascii_to_ibm	dd.c	/^static char const ascii_to_ibm[] =$/;"	v	file:
attach	ls.c	/^attach (char *dest, const char *dirname, const char *name)$/;"	f	file:	signature:(char *dest, const char *dirname, const char *name)
attach	ls.c	/^static void attach (char *dest, const char *dirname, const char *name);$/;"	p	file:	signature:(char *dest, const char *dirname, const char *name)
author_width	ls.c	/^static int author_width;$/;"	v	file:
auto_padding	numfmt.c	/^static int auto_padding = 0;$/;"	v	file:
auto_reference	ptx.c	/^static bool auto_reference = false;	\/* refs are 'file_name:line_number:' *\/$/;"	v	file:
autocount_1	join.c	/^static size_t autocount_1;$/;"	v	file:
autocount_2	join.c	/^static size_t autocount_2;$/;"	v	file:
autoformat	join.c	/^static bool autoformat;$/;"	v	file:
available	df.c	/^  uintmax_t available;$/;"	m	struct:field_values_t	file:	access:public
available_to_root	df.c	/^  uintmax_t available_to_root;$/;"	m	struct:field_values_t	file:	access:public
avoid_trashing_input	sort.c	/^avoid_trashing_input (struct sortfile *files, size_t ntemps,$/;"	f	file:	signature:(struct sortfile *files, size_t ntemps, size_t nfiles, char const *outfile)
backup_type	copy.h	/^  enum backup_type backup_type;$/;"	m	struct:cp_options	typeref:enum:cp_options::backup_type	access:public
backup_type	ln.c	/^static enum backup_type backup_type;$/;"	v	typeref:enum:backup_type	file:
bad_cast	system.h	/^bad_cast (char const *s)$/;"	f	signature:(char const *s)
badfieldspec	sort.c	/^badfieldspec (char const *spec, char const *msgid)$/;"	f	file:	signature:(char const *spec, char const *msgid)
balance	pr.c	/^balance (int total_stored)$/;"	f	file:	signature:(int total_stored)
balance	pr.c	/^static void balance (int total_stored);$/;"	p	file:	signature:(int total_stored)
balance	tsort.c	/^  int balance; \/* -1, 0, or +1 *\/$/;"	m	struct:item	file:	access:public
balance_columns	pr.c	/^static bool balance_columns = false;$/;"	v	file:
base_cost	fmt.c	/^base_cost (WORD *this)$/;"	f	file:	signature:(WORD *this)
base_cost	fmt.c	/^static COST base_cost (WORD *this);$/;"	p	file:	signature:(WORD *this)
basename_is_dot_or_dotdot	ls.c	/^basename_is_dot_or_dotdot (const char *name)$/;"	f	file:	signature:(const char *name)
basename_start	tail.c	/^  size_t basename_start;$/;"	m	struct:File_spec	file:	access:public
batch_convert	date.c	/^batch_convert (const char *input_filename, const char *format)$/;"	f	file:	signature:(const char *input_filename, const char *format)
baud_to_value	stty.c	/^baud_to_value (speed_t speed)$/;"	f	file:	signature:(speed_t speed)
baud_to_value	stty.c	/^static unsigned long int baud_to_value (speed_t speed);$/;"	p	file:	signature:(speed_t speed)
before	ptx.c	/^static BLOCK before;		\/* before field *\/$/;"	v	file:
before_max_width	ptx.c	/^static int before_max_width;	\/* maximum width of before field *\/$/;"	v	file:
before_truncation	ptx.c	/^static int before_truncation;	\/* flag truncation before the before field *\/$/;"	v	file:
beg	join.c	/^    char *beg;			\/* First character in field.  *\/$/;"	m	struct:field	file:	access:public
begfield	sort.c	/^begfield (struct line const *line, struct keyfield const *key)$/;"	f	file:	signature:(struct line const *line, struct keyfield const *key)
best_cost	fmt.c	/^    COST best_cost;		\/* cost of best paragraph starting here *\/$/;"	m	struct:Word	file:	access:public
beyond	test.c	/^beyond (void)$/;"	f	file:	signature:(void)
bin_PROGRAMS	local.mk	/^bin_PROGRAMS = @bin_PROGRAMS@$/;"	m
bin_str	ls.c	/^struct bin_str$/;"	s	file:
bin_str::len	ls.c	/^    size_t len;			\/* Number of bytes *\/$/;"	m	struct:bin_str	file:	access:public
bin_str::string	ls.c	/^    const char *string;		\/* Pointer to the same *\/$/;"	m	struct:bin_str	file:	access:public
binary_operator	test.c	/^binary_operator (bool l_is_l)$/;"	f	file:	signature:(bool l_is_l)
binary_operator	test.c	/^static bool binary_operator (bool);$/;"	p	file:
bindtextdomain	system.h	171;"	d
bindtextdomain	system.h	172;"	d
binop	test.c	/^binop (char const *s)$/;"	f	file:	signature:(char const *s)
binv	factor.c	/^  uintmax_t binv, lim;$/;"	m	struct:primes_dtab	file:	access:public
binv	factor.c	906;"	d	file:
binvert	make-prime-list.c	/^binvert (wide_uint a)$/;"	f	file:	signature:(wide_uint a)
binvert_table	factor.c	/^static const unsigned char  binvert_table[128] =$/;"	v	file:
bits	stty.c	/^    unsigned long bits;		\/* Bits to set for this mode.  *\/$/;"	m	struct:mode_info	file:	access:public
bl_both	sort.c	/^enum blanktype { bl_start, bl_end, bl_both };$/;"	e	enum:blanktype	file:
bl_end	sort.c	/^enum blanktype { bl_start, bl_end, bl_both };$/;"	e	enum:blanktype	file:
bl_start	sort.c	/^enum blanktype { bl_start, bl_end, bl_both };$/;"	e	enum:blanktype	file:
blank_join	nl.c	/^static intmax_t blank_join = 1;$/;"	v	file:
blanks	sort.c	/^static bool blanks[UCHAR_LIM];$/;"	v	file:
blanktype	sort.c	/^enum blanktype { bl_start, bl_end, bl_both };$/;"	g	file:
block_mode	truncate.c	/^static bool block_mode;$/;"	v	file:
block_size_width	ls.c	/^static int block_size_width;$/;"	v	file:
blockdev	ls.c	/^    blockdev,$/;"	e	enum:filetype	file:
blocking	tail.c	/^  int blocking;$/;"	m	struct:File_spec	file:	access:public
body_del	nl.c	/^static char *body_del = NULL;$/;"	v	file:
body_del_len	nl.c	/^static size_t body_del_len;$/;"	v	file:
body_fastmap	nl.c	/^static char body_fastmap[UCHAR_MAX + 1];$/;"	v	file:
body_regex	nl.c	/^static struct re_pattern_buffer body_regex;$/;"	v	typeref:struct:re_pattern_buffer	file:
body_type	nl.c	/^static char const *body_type = "t";$/;"	v	file:
both	comm.c	/^static bool both;$/;"	v	file:
both_speeds	stty.c	/^    input_speed, output_speed, both_speeds$/;"	e	enum:speed_setting	file:
break_file	ptx.c	/^static const char *break_file = NULL;	\/* name of the 'Break chars' file *\/$/;"	v	file:
break_spaces	fold.c	/^static bool break_spaces;$/;"	v	file:
bsd_reversed	md5sum.c	/^static int bsd_reversed = -1;$/;"	v	file:
bsd_split_3	md5sum.c	/^bsd_split_3 (char *s, size_t s_len, unsigned char **hex_digest,$/;"	f	file:	signature:(char *s, size_t s_len, unsigned char **hex_digest, char **file_name, bool escaped_filename)
bsd_sum_file	sum.c	/^bsd_sum_file (const char *file, int print_name)$/;"	f	file:	signature:(const char *file, int print_name)
buf	join.c	/^    struct linebuffer buf;	\/* The line itself.  *\/$/;"	m	struct:line	typeref:struct:line::linebuffer	file:	access:public
buf	pwd.c	/^  char *buf;$/;"	m	struct:file_name	file:	access:public
buf	sort.c	/^  char *buf;			\/* Dynamically allocated buffer,$/;"	m	struct:buffer	file:	access:public
buf_free	tac-pipe.c	/^buf_free (Buf *x)$/;"	f	file:	signature:(Buf *x)
buf_init_from_stdin	tac-pipe.c	/^buf_init_from_stdin (Buf *x, char eol_byte)$/;"	f	file:	signature:(Buf *x, char eol_byte)
buff	pr.c	/^static char *buff;$/;"	v	file:
buff_allocated	pr.c	/^static size_t buff_allocated;$/;"	v	file:
buff_current	pr.c	/^static unsigned int buff_current;$/;"	v	file:
buffer	csplit.c	/^  char *buffer;			\/* Data area. *\/$/;"	m	struct:buffer_record	file:	access:public
buffer	sort.c	/^struct buffer$/;"	s	file:
buffer::alloc	sort.c	/^  size_t alloc;			\/* Number of bytes allocated. *\/$/;"	m	struct:buffer	file:	access:public
buffer::buf	sort.c	/^  char *buf;			\/* Dynamically allocated buffer,$/;"	m	struct:buffer	file:	access:public
buffer::eof	sort.c	/^  bool eof;			\/* An EOF has been read.  *\/$/;"	m	struct:buffer	file:	access:public
buffer::left	sort.c	/^  size_t left;			\/* Number of bytes left from previous reads. *\/$/;"	m	struct:buffer	file:	access:public
buffer::line_bytes	sort.c	/^  size_t line_bytes;		\/* Number of bytes to reserve for each line. *\/$/;"	m	struct:buffer	file:	access:public
buffer::nlines	sort.c	/^  size_t nlines;		\/* Number of lines in the line array.  *\/$/;"	m	struct:buffer	file:	access:public
buffer::used	sort.c	/^  size_t used;			\/* Number of bytes used for input data.  *\/$/;"	m	struct:buffer	file:	access:public
buffer_linelim	sort.c	/^buffer_linelim (struct buffer const *buf)$/;"	f	file:	signature:(struct buffer const *buf)
buffer_or_output	relpath.c	/^buffer_or_output (const char* str, char **pbuf, size_t *plen)$/;"	f	file:	signature:(const char* str, char **pbuf, size_t *plen)
buffer_record	csplit.c	/^struct buffer_record$/;"	s	file:
buffer_record::buffer	csplit.c	/^  char *buffer;			\/* Data area. *\/$/;"	m	struct:buffer_record	file:	access:public
buffer_record::bytes_alloc	csplit.c	/^  size_t bytes_alloc;		\/* Size of the buffer area. *\/$/;"	m	struct:buffer_record	file:	access:public
buffer_record::bytes_used	csplit.c	/^  size_t bytes_used;		\/* Bytes used in the buffer area. *\/$/;"	m	struct:buffer_record	file:	access:public
buffer_record::curr_line	csplit.c	/^  struct line *curr_line;	\/* The line start record currently in use. *\/$/;"	m	struct:buffer_record	typeref:struct:buffer_record::line	file:	access:public
buffer_record::first_available	csplit.c	/^  uintmax_t first_available;	\/* First line that can be retrieved. *\/$/;"	m	struct:buffer_record	file:	access:public
buffer_record::line_start	csplit.c	/^  struct line *line_start;	\/* Head of list of pointers to lines. *\/$/;"	m	struct:buffer_record	typeref:struct:buffer_record::line	file:	access:public
buffer_record::next	csplit.c	/^  struct buffer_record *next;$/;"	m	struct:buffer_record	typeref:struct:buffer_record::buffer_record	file:	access:public
buffer_record::num_lines	csplit.c	/^  size_t num_lines;		\/* Number of complete lines in this buffer. *\/$/;"	m	struct:buffer_record	file:	access:public
buffer_record::start_line	csplit.c	/^  uintmax_t start_line;		\/* First line number in this buffer. *\/$/;"	m	struct:buffer_record	file:	access:public
build_if_possible__progs	cu-progs.mk	/^build_if_possible__progs =$/;"	m
build_spec_list	tr.c	/^build_spec_list (const struct E_string *es, struct Spec_list *result)$/;"	f	file:	signature:(const struct E_string *es, struct Spec_list *result)
build_type_arg	nl.c	/^build_type_arg (char const **typep,$/;"	f	file:	signature:(char const **typep, struct re_pattern_buffer *regexp, char *fastmap)
byte_mode	cut.c	/^    byte_mode,$/;"	e	enum:operating_mode	file:
bytes_alloc	csplit.c	/^  size_t bytes_alloc;		\/* Size of the buffer area. *\/$/;"	m	struct:buffer_record	file:	access:public
bytes_chunk_extract	split.c	/^bytes_chunk_extract (uintmax_t k, uintmax_t n, char *buf, size_t bufsize,$/;"	f	file:	signature:(uintmax_t k, uintmax_t n, char *buf, size_t bufsize, off_t file_size)
bytes_per_block	od.c	/^static size_t bytes_per_block;$/;"	v	file:
bytes_split	split.c	/^bytes_split (uintmax_t n_bytes, char *buf, size_t bufsize, uintmax_t max_files)$/;"	f	file:	signature:(uintmax_t n_bytes, char *buf, size_t bufsize, uintmax_t max_files)
bytes_to_hex_digits	od.c	/^static unsigned int const bytes_to_hex_digits[] =$/;"	v	file:
bytes_to_oct_digits	od.c	/^static unsigned int const bytes_to_oct_digits[] =$/;"	v	file:
bytes_to_signed_dec_digits	od.c	/^static unsigned int const bytes_to_signed_dec_digits[] =$/;"	v	file:
bytes_to_unsigned_dec_digits	od.c	/^static unsigned int const bytes_to_unsigned_dec_digits[] =$/;"	v	file:
bytes_used	csplit.c	/^  size_t bytes_used;		\/* Bytes used in the buffer area. *\/$/;"	m	struct:buffer_record	file:	access:public
bytes_written	csplit.c	/^static uintmax_t bytes_written;$/;"	v	file:
cache_fstatat	remove.c	/^cache_fstatat (int fd, char const *file, struct stat *st, int flag)$/;"	f	file:	signature:(int fd, char const *file, struct stat *st, int flag)
cache_round	dd.c	/^cache_round (int fd, off_t len)$/;"	f	file:	signature:(int fd, off_t len)
cache_stat_init	remove.c	/^cache_stat_init (struct stat *st)$/;"	f	file:	signature:(struct stat *st)
cached_umask	copy.c	/^cached_umask (void)$/;"	f	signature:(void)
cached_umask	copy.h	/^mode_t cached_umask (void);$/;"	p	signature:(void)
calculate_columns	ls.c	/^calculate_columns (bool by_columns)$/;"	f	file:	signature:(bool by_columns)
calculate_columns	ls.c	/^static size_t calculate_columns (bool by_columns);$/;"	p	file:	signature:(bool by_columns)
can_relative_base	realpath.c	/^static const char *can_relative_base;$/;"	v	file:
can_relative_to	realpath.c	/^static const char *can_relative_to;$/;"	v	file:
caption	df.c	/^  const char *caption;\/* NULL means to use the default header of this field.  *\/$/;"	m	struct:field_data_t	file:	access:public
card_of_complement	tr.c	/^card_of_complement (struct Spec_list *s)$/;"	f	file:	signature:(struct Spec_list *s)
case_GETOPT_HELP_CHAR	system.h	335;"	d
case_GETOPT_VERSION_CHAR	system.h	370;"	d
cat	cat.c	/^cat ($/;"	f	file:	signature:( char *inbuf, size_t insize, char *outbuf, size_t outsize, bool show_nonprinting, bool show_tabs, bool number, bool number_nonblank, bool show_ends, bool squeeze_blank)
caught_signals	csplit.c	/^static sigset_t caught_signals;$/;"	v	file:
caught_signals	dd.c	/^static sigset_t caught_signals;$/;"	v	file:
caught_signals	ls.c	/^static sigset_t caught_signals;$/;"	v	file:
caught_signals	sort.c	/^static sigset_t caught_signals;$/;"	v	file:
cfcc_msg	printf.c	/^static char const *const cfcc_msg =$/;"	v	file:
change	chmod.c	/^static struct mode_change *change;$/;"	v	typeref:struct:mode_change	file:
change_attributes	install.c	/^change_attributes (char const *name)$/;"	f	file:	signature:(char const *name)
change_file_context	chcon.c	/^change_file_context (int fd, char const *file)$/;"	f	file:	signature:(int fd, char const *file)
change_file_owner	chown-core.c	/^change_file_owner (FTS *fts, FTSENT *ent,$/;"	f	file:	signature:(FTS *fts, FTSENT *ent, uid_t uid, gid_t gid, uid_t required_uid, gid_t required_gid, struct Chown_option const *chopt)
change_times	touch.c	/^static int change_times;$/;"	v	file:
change_timestamps	install.c	/^change_timestamps (struct stat const *src_sb, char const *dest)$/;"	f	file:	signature:(struct stat const *src_sb, char const *dest)
changed	stty.c	/^    changed, all, recoverable	\/* Default, -a, -g.  *\/$/;"	e	enum:output_type	file:
char_class	tr.c	/^        enum Char_class char_class;$/;"	m	union:List_element::__anon3	typeref:enum:List_element::__anon3::Char_class	file:	access:public
char_class_name	tr.c	/^static char const *const char_class_name[] =$/;"	v	file:
char_func	pr.c	/^    void (*char_func) (char);$/;"	m	struct:COLUMN	file:	access:public
char_is_saved	dd.c	/^static bool char_is_saved = false;$/;"	v	file:
char_to_clump	pr.c	/^char_to_clump (char c)$/;"	f	file:	signature:(char c)
char_to_clump	pr.c	/^static int char_to_clump (char c);$/;"	p	file:	signature:(char c)
chardev	ls.c	/^    chardev,$/;"	e	enum:filetype	file:
charname	od.c	/^static char const charname[33][4] =$/;"	v	file:
chars_per_column	pr.c	/^static int chars_per_column;$/;"	v	file:
chars_per_input_tab	pr.c	/^static int chars_per_input_tab = 8;$/;"	v	file:
chars_per_line	pr.c	/^static int chars_per_line = 72;$/;"	v	file:
chars_per_margin	pr.c	/^static int chars_per_margin = 0;$/;"	v	file:
chars_per_number	pr.c	/^static int chars_per_number = 5;$/;"	v	file:
chars_per_output_tab	pr.c	/^static int chars_per_output_tab = 8;$/;"	v	file:
check	sort.c	/^check (char const *file_name, char checkonly)$/;"	f	file:	signature:(char const *file_name, char checkonly)
check_and_close	od.c	/^check_and_close (int in_errno)$/;"	f	file:	signature:(int in_errno)
check_args	sort.c	/^static char const *const check_args[] =$/;"	v	file:
check_chars	uniq.c	/^static size_t check_chars;$/;"	v	file:
check_file	uniq.c	/^check_file (const char *infile, const char *outfile, char delimiter)$/;"	f	file:	signature:(const char *infile, const char *outfile, char delimiter)
check_for_offset	csplit.c	/^check_for_offset (struct control *p, const char *str, const char *num)$/;"	f	file:	signature:(struct control *p, const char *str, const char *num)
check_format_conv_type	csplit.c	/^check_format_conv_type (char *format, int flags)$/;"	f	file:	signature:(char *format, int flags)
check_fspec	tail.c	/^check_fspec (struct File_spec *fspec, int wd, int *prev_wd)$/;"	f	file:	signature:(struct File_spec *fspec, int wd, int *prev_wd)
check_input_order	comm.c	/^  } check_input_order;$/;"	v	typeref:enum:__anon92	file:
check_input_order	join.c	/^  } check_input_order;$/;"	v	typeref:enum:__anon8	file:
check_inputs	sort.c	/^check_inputs (char *const *files, size_t nfiles)$/;"	f	file:	signature:(char *const *files, size_t nfiles)
check_order	comm.c	/^check_order (struct linebuffer const *prev,$/;"	f	file:	signature:(struct linebuffer const *prev, struct linebuffer const *current, int whatfile)
check_order	join.c	/^check_order (const struct line *prev,$/;"	f	file:	signature:(const struct line *prev, const struct line *current, int whatfile)
check_ordering_compatibility	sort.c	/^check_ordering_compatibility (void)$/;"	f	file:	signature:(void)
check_output	sort.c	/^check_output (char const *outfile)$/;"	f	file:	signature:(char const *outfile)
check_punctuation	fmt.c	/^check_punctuation (WORD *w)$/;"	f	file:	signature:(WORD *w)
check_punctuation	fmt.c	/^static void check_punctuation (WORD *w);$/;"	p	file:	signature:(WORD *w)
check_section	nl.c	/^check_section (void)$/;"	f	file:	signature:(void)
check_symlink_color	ls.c	/^static bool check_symlink_color;$/;"	v	file:
check_types	sort.c	/^static char const check_types[] =$/;"	v	file:
chopt_free	chown-core.c	/^chopt_free (struct Chown_option *chopt ATTRIBUTE_UNUSED)$/;"	f	signature:(struct Chown_option *chopt ATTRIBUTE_UNUSED)
chopt_free	chown-core.h	/^chopt_free (struct Chown_option *);$/;"	p	signature:(struct Chown_option *)
chopt_init	chown-core.c	/^chopt_init (struct Chown_option *chopt)$/;"	f	signature:(struct Chown_option *chopt)
chopt_init	chown-core.h	/^chopt_init (struct Chown_option *);$/;"	p	signature:(struct Chown_option *)
chown_failure_ok	copy.c	/^chown_failure_ok (struct cp_options const *x)$/;"	f	signature:(struct cp_options const *x)
chown_files	chown-core.c	/^chown_files (char **files, int bit_flags,$/;"	f	signature:(char **files, int bit_flags, uid_t uid, gid_t gid, uid_t required_uid, gid_t required_gid, struct Chown_option const *chopt)
chown_files	chown-core.h	/^chown_files (char **files, int bit_flags,$/;"	p	signature:(char **files, int bit_flags, uid_t uid, gid_t gid, uid_t required_uid, gid_t required_gid, struct Chown_option const *chopt)
chown_privileges	copy.h	/^  bool chown_privileges;$/;"	m	struct:cp_options	access:public
cksum	cksum.c	/^cksum (const char *file, bool print_name)$/;"	f	file:	signature:(const char *file, bool print_name)
classify	ls.c	/^    classify	\/* -F, --indicator-style=classify *\/$/;"	e	enum:indicator_style	file:
cleanup	csplit.c	/^cleanup (void)$/;"	f	file:	signature:(void)
cleanup	dd.c	/^cleanup (void)$/;"	f	file:	signature:(void)
cleanup	pr.c	/^cleanup (void)$/;"	f	file:	signature:(void)
cleanup	pr.c	/^static void cleanup (void);$/;"	p	file:	signature:(void)
cleanup	sort.c	/^cleanup (void)$/;"	f	file:	signature:(void)
cleanup	timeout.c	/^cleanup (int sig)$/;"	f	file:	signature:(int sig)
cleanup_fatal	csplit.c	/^cleanup_fatal (void)$/;"	f	file:	signature:(void)
clear_files	ls.c	/^clear_files (void)$/;"	f	file:	signature:(void)
clear_files	ls.c	/^static void clear_files (void);$/;"	p	file:	signature:(void)
clear_line_control	csplit.c	/^clear_line_control (struct line *p)$/;"	f	file:	signature:(struct line *p)
clear_random_data	shred.c	/^clear_random_data (void)$/;"	f	file:	signature:(void)
clone_file	copy.c	/^clone_file (int dest_fd, int src_fd)$/;"	f	file:	signature:(int dest_fd, int src_fd)
close_fd	tail.c	/^close_fd (int fd, const char *filename)$/;"	f	file:	signature:(int fd, const char *filename)
close_file	pr.c	/^close_file (COLUMN *p)$/;"	f	file:	signature:(COLUMN *p)
close_output_file	csplit.c	/^close_output_file (void)$/;"	f	file:	signature:(void)
close_output_file	csplit.c	/^static void close_output_file (void);$/;"	p	file:	signature:(void)
close_stdout_required	dd.c	/^static bool close_stdout_required = true;$/;"	v	file:
closeout	split.c	/^closeout (FILE *fp, int fd, pid_t pid, char const *name)$/;"	f	file:	signature:(FILE *fp, int fd, pid_t pid, char const *name)
clump_buff	pr.c	/^static char *clump_buff;$/;"	v	file:
cmp	seq.c	/^cmp (char const *a, size_t a_len, char const *b, size_t b_len)$/;"	f	file:	signature:(char const *a, size_t a_len, char const *b, size_t b_len)
cmp_atime	ls.c	/^cmp_atime (struct fileinfo const *a, struct fileinfo const *b,$/;"	f	file:	signature:(struct fileinfo const *a, struct fileinfo const *b, int (*cmp) (char const *, char const *))
cmp_ctime	ls.c	/^cmp_ctime (struct fileinfo const *a, struct fileinfo const *b,$/;"	f	file:	signature:(struct fileinfo const *a, struct fileinfo const *b, int (*cmp) (char const *, char const *))
cmp_extension	ls.c	/^cmp_extension (struct fileinfo const *a, struct fileinfo const *b,$/;"	f	file:	signature:(struct fileinfo const *a, struct fileinfo const *b, int (*cmp) (char const *, char const *))
cmp_mtime	ls.c	/^cmp_mtime (struct fileinfo const *a, struct fileinfo const *b,$/;"	f	file:	signature:(struct fileinfo const *a, struct fileinfo const *b, int (*cmp) (char const *, char const *))
cmp_name	ls.c	/^cmp_name (struct fileinfo const *a, struct fileinfo const *b,$/;"	f	file:	signature:(struct fileinfo const *a, struct fileinfo const *b, int (*cmp) (char const *, char const *))
cmp_size	ls.c	/^cmp_size (struct fileinfo const *a, struct fileinfo const *b,$/;"	f	file:	signature:(struct fileinfo const *a, struct fileinfo const *b, int (*cmp) (char const *, char const *))
cmp_version	ls.c	/^cmp_version (struct fileinfo const *a, struct fileinfo const *b)$/;"	f	file:	signature:(struct fileinfo const *a, struct fileinfo const *b)
col	dd.c	/^static size_t col = 0;$/;"	v	file:
col_arr	ls.c	/^  size_t *col_arr;$/;"	m	struct:column_info	file:	access:public
col_sep_length	pr.c	/^static int col_sep_length = 0;$/;"	v	file:
col_sep_string	pr.c	/^static char *col_sep_string = (char *) "";$/;"	v	file:
collapse_escapes	paste.c	/^collapse_escapes (char const *strptr)$/;"	f	file:	signature:(char const *strptr)
color_always	ls.c	/^    color_always,		\/* 1: --color=always *\/$/;"	e	enum:color_type	file:
color_args	ls.c	/^static char const *const color_args[] =$/;"	v	file:
color_buf	ls.c	/^static char *color_buf;$/;"	v	file:
color_ext_list	ls.c	/^static struct color_ext_type *color_ext_list = NULL;$/;"	v	typeref:struct:color_ext_type	file:
color_ext_type	ls.c	/^struct color_ext_type$/;"	s	file:
color_ext_type::ext	ls.c	/^    struct bin_str ext;		\/* The extension we're looking for *\/$/;"	m	struct:color_ext_type	typeref:struct:color_ext_type::bin_str	file:	access:public
color_ext_type::next	ls.c	/^    struct color_ext_type *next;	\/* Next in list *\/$/;"	m	struct:color_ext_type	typeref:struct:color_ext_type::color_ext_type	file:	access:public
color_ext_type::seq	ls.c	/^    struct bin_str seq;		\/* The sequence to output when we do *\/$/;"	m	struct:color_ext_type	typeref:struct:color_ext_type::bin_str	file:	access:public
color_if_tty	ls.c	/^    color_if_tty		\/* 2: --color=tty *\/$/;"	e	enum:color_type	file:
color_indicator	ls.c	/^static struct bin_str color_indicator[] =$/;"	v	typeref:struct:bin_str	file:
color_never	ls.c	/^    color_never,		\/* 0: default or --color=never *\/$/;"	e	enum:color_type	file:
color_symlink_as_referent	ls.c	/^static bool color_symlink_as_referent;$/;"	v	file:
color_type	ls.c	/^enum color_type$/;"	g	file:
color_types	ls.c	/^static enum color_type const color_types[] =$/;"	v	file:
cols_ready_to_print	pr.c	/^cols_ready_to_print (void)$/;"	f	file:	signature:(void)
column_info	ls.c	/^static struct column_info *column_info;$/;"	v	typeref:struct:column_info	file:
column_info	ls.c	/^struct column_info$/;"	s	file:
column_info::col_arr	ls.c	/^  size_t *col_arr;$/;"	m	struct:column_info	file:	access:public
column_info::line_len	ls.c	/^  size_t line_len;$/;"	m	struct:column_info	file:	access:public
column_info::valid_len	ls.c	/^  bool valid_len;$/;"	m	struct:column_info	file:	access:public
column_separator	pr.c	/^static char *column_separator = (char *) " ";$/;"	v	file:
column_vector	pr.c	/^static COLUMN *column_vector;$/;"	v	file:
columns	df.c	/^static struct field_data_t **columns;$/;"	v	typeref:struct:field_data_t	file:
columns	pr.c	/^static int columns = 1;$/;"	v	file:
combination	stty.c	/^    control, input, output, local, combination$/;"	e	enum:mode_type	file:
command_line_arg	ls.c	/^    bool command_line_arg;$/;"	m	struct:pending	file:	access:public
compare	sort.c	/^compare (struct line const *a, struct line const *b)$/;"	f	file:	signature:(struct line const *a, struct line const *b)
compare_files	comm.c	/^compare_files (char **infiles)$/;"	f	file:	signature:(char **infiles)
compare_nodes	sort.c	/^compare_nodes (void const *a, void const *b)$/;"	f	file:	signature:(void const *a, void const *b)
compare_occurs	ptx.c	/^compare_occurs (const void *void_first, const void *void_second)$/;"	f	file:	signature:(const void *void_first, const void *void_second)
compare_random	sort.c	/^compare_random (char *restrict texta, size_t lena,$/;"	f	file:	signature:(char *restrict texta, size_t lena, char *restrict textb, size_t lenb)
compare_ranges	cut.c	/^compare_ranges (const void *a, const void *b)$/;"	f	file:	signature:(const void *a, const void *b)
compare_words	ptx.c	/^compare_words (const void *void_first, const void *void_second)$/;"	f	file:	signature:(const void *void_first, const void *void_second)
compile_regex	ptx.c	/^compile_regex (struct regex_data *regex)$/;"	f	file:	signature:(struct regex_data *regex)
compiled_separator	tac.c	/^static struct re_pattern_buffer compiled_separator;$/;"	v	typeref:struct:re_pattern_buffer	file:
compiled_separator_fastmap	tac.c	/^static char compiled_separator_fastmap[UCHAR_MAX + 1];$/;"	v	file:
complement	cut.c	/^static bool complement;$/;"	v	file:
complement	tr.c	/^static bool complement = false;$/;"	v	file:
component_len	pathchk.c	/^component_len (char const *f)$/;"	f	file:	signature:(char const *f)
component_start	pathchk.c	/^component_start (char *f)$/;"	f	file:	signature:(char *f)
compress_program	sort.c	/^static char const *compress_program;$/;"	v	file:
compute_context_from_mask	chcon.c	/^compute_context_from_mask (security_context_t context, context_t *ret)$/;"	f	file:	signature:(security_context_t context, context_t *ret)
compute_number_width	wc.c	/^compute_number_width (int nfiles, struct fstatus const *fstatus)$/;"	f	file:	signature:(int nfiles, struct fstatus const *fstatus)
cond	sort.c	/^  pthread_cond_t cond;          \/* Conditional wait for empty queue to populate$/;"	m	struct:merge_node_queue	file:	access:public
context	id.c	/^static security_context_t context = NULL;$/;"	v	file:
context_regex	ptx.c	/^static struct regex_data context_regex;	\/* end of context *\/$/;"	v	typeref:struct:regex_data	file:
context_regs	ptx.c	/^static struct re_registers context_regs;$/;"	v	typeref:struct:re_registers	file:
control	csplit.c	/^struct control$/;"	s	file:
control	stty.c	/^    control, input, output, local, combination$/;"	e	enum:mode_type	file:
control::argnum	csplit.c	/^  int argnum;			\/* ARGV index. *\/$/;"	m	struct:control	file:	access:public
control::ignore	csplit.c	/^  bool ignore;			\/* If true, produce no output (for regexp). *\/$/;"	m	struct:control	file:	access:public
control::lines_required	csplit.c	/^  uintmax_t lines_required;	\/* Number of lines required. *\/$/;"	m	struct:control	file:	access:public
control::offset	csplit.c	/^  intmax_t offset;		\/* Offset from regexp to split at. *\/$/;"	m	struct:control	file:	access:public
control::re_compiled	csplit.c	/^  struct re_pattern_buffer re_compiled;	\/* Compiled regular expression. *\/$/;"	m	struct:control	typeref:struct:control::re_pattern_buffer	file:	access:public
control::regexpr	csplit.c	/^  bool regexpr;			\/* True if regular expression was used. *\/$/;"	m	struct:control	file:	access:public
control::repeat	csplit.c	/^  uintmax_t repeat;		\/* Repeat count. *\/$/;"	m	struct:control	file:	access:public
control::repeat_forever	csplit.c	/^  bool repeat_forever;		\/* True if '*' used as a repeat count. *\/$/;"	m	struct:control	file:	access:public
control_info	stty.c	/^static struct control_info const control_info[] =$/;"	v	file:
control_info	stty.c	/^struct control_info$/;"	s	file:
control_info::name	stty.c	/^    const char *name;		\/* Name given on command line.  *\/$/;"	m	struct:control_info	file:	access:public
control_info::offset	stty.c	/^    size_t offset;		\/* Offset in c_cc.  *\/$/;"	m	struct:control_info	file:	access:public
control_info::saneval	stty.c	/^    cc_t saneval;		\/* Value to set for 'stty sane'.  *\/$/;"	m	struct:control_info	file:	access:public
control_used	csplit.c	/^static size_t control_used;$/;"	v	file:
controls	csplit.c	/^static struct control *controls;$/;"	v	typeref:struct:control	file:
conv_exit_code	numfmt.c	/^static int conv_exit_code = EXIT_CONVERSION_WARNINGS;$/;"	v	file:
conversion_blocksize	dd.c	/^static size_t conversion_blocksize = 0;$/;"	v	file:
conversions	dd.c	/^static struct symbol_value const conversions[] =$/;"	v	file:
conversions_mask	dd.c	/^static int conversions_mask = 0;$/;"	v	file:
convert_abs_rel	ln.c	/^convert_abs_rel (const char *from, const char *target)$/;"	f	file:	signature:(const char *from, const char *target)
convert_entire_line	expand.c	/^static bool convert_entire_line;$/;"	v	file:
convert_entire_line	unexpand.c	/^static bool convert_entire_line;$/;"	v	file:
copy	copy.c	/^copy (char const *src_name, char const *dst_name,$/;"	f	signature:(char const *src_name, char const *dst_name, bool nonexistent_dst, const struct cp_options *options, bool *copy_into_self, bool *rename_succeeded)
copy	copy.h	/^bool copy (char const *src_name, char const *dst_name,$/;"	p	signature:(char const *src_name, char const *dst_name, bool nonexistent_dst, const struct cp_options *options, bool *copy_into_self, bool *rename_succeeded)
copy_as_regular	copy.h	/^  bool copy_as_regular;$/;"	m	struct:cp_options	access:public
copy_attr	copy.c	/^copy_attr (char const *src_path ATTRIBUTE_UNUSED,$/;"	f	file:	signature:(char const *src_path ATTRIBUTE_UNUSED, int src_fd ATTRIBUTE_UNUSED, char const *dst_path ATTRIBUTE_UNUSED, int dst_fd ATTRIBUTE_UNUSED, struct cp_options const *x ATTRIBUTE_UNUSED)
copy_attr	copy.c	/^copy_attr (char const *src_path, int src_fd,$/;"	f	file:	signature:(char const *src_path, int src_fd, char const *dst_path, int dst_fd, struct cp_options const *x)
copy_attr_allerror	copy.c	/^copy_attr_allerror (struct error_context *ctx ATTRIBUTE_UNUSED,$/;"	f	file:	signature:(struct error_context *ctx ATTRIBUTE_UNUSED, char const *fmt, ...)
copy_attr_error	copy.c	/^copy_attr_error (struct error_context *ctx ATTRIBUTE_UNUSED,$/;"	f	file:	signature:(struct error_context *ctx ATTRIBUTE_UNUSED, char const *fmt, ...)
copy_attr_free	copy.c	/^copy_attr_free (struct error_context *ctx ATTRIBUTE_UNUSED,$/;"	f	file:	signature:(struct error_context *ctx ATTRIBUTE_UNUSED, char const *str ATTRIBUTE_UNUSED)
copy_attr_quote	copy.c	/^copy_attr_quote (struct error_context *ctx ATTRIBUTE_UNUSED, char const *str)$/;"	f	file:	signature:(struct error_context *ctx ATTRIBUTE_UNUSED, char const *str)
copy_dir	copy.c	/^copy_dir (char const *src_name_in, char const *dst_name_in, bool new_dst,$/;"	f	file:	signature:(char const *src_name_in, char const *dst_name_in, bool new_dst, const struct stat *src_sb, struct dir_list *ancestors, const struct cp_options *x, bool *first_dir_created_per_command_line_arg, bool *copy_into_self)
copy_fd	head.c	/^copy_fd (int src_fd, FILE *o_stream, uintmax_t n_bytes)$/;"	f	file:	signature:(int src_fd, FILE *o_stream, uintmax_t n_bytes)
copy_file	install.c	/^copy_file (const char *from, const char *to, const struct cp_options *x)$/;"	f	file:	signature:(const char *from, const char *to, const struct cp_options *x)
copy_internal	copy.c	/^copy_internal (char const *src_name, char const *dst_name,$/;"	f	file:	signature:(char const *src_name, char const *dst_name, bool new_dst, dev_t device, struct dir_list *ancestors, const struct cp_options *x, bool command_line_arg, bool *first_dir_created_per_command_line_arg, bool *copy_into_self, bool *rename_succeeded)
copy_internal	copy.c	/^static bool copy_internal (char const *src_name, char const *dst_name,$/;"	p	file:	signature:(char const *src_name, char const *dst_name, bool new_dst, dev_t device, struct dir_list *ancestors, const struct cp_options *x, bool command_line_arg, bool *first_dir_created_per_command_line_arg, bool *copy_into_self, bool *rename_succeeded)
copy_ldadd	local.mk	/^copy_ldadd =$/;"	m
copy_only_if_needed	install.c	/^static bool copy_only_if_needed;$/;"	v	file:
copy_reg	copy.c	/^copy_reg (char const *src_name, char const *dst_name,$/;"	f	file:	signature:(char const *src_name, char const *dst_name, const struct cp_options *x, mode_t dst_mode, mode_t omitted_permissions, bool *new_dst, struct stat const *src_sb)
copy_rest	fmt.c	/^copy_rest (FILE *f, int c)$/;"	f	file:	signature:(FILE *f, int c)
copy_rest	fmt.c	/^static int copy_rest (FILE *f, int c);$/;"	p	file:	signature:(FILE *f, int c)
copy_simple	dd.c	/^copy_simple (char const *buf, size_t nread)$/;"	f	file:	signature:(char const *buf, size_t nread)
copy_sources	local.mk	/^copy_sources = \\$/;"	m
copy_to_temp	tac.c	/^copy_to_temp (FILE **g_tmp, char **g_tempfile, int input_fd, char const *file)$/;"	f	file:	signature:(FILE **g_tmp, char **g_tempfile, int input_fd, char const *file)
copy_unescaped_string	ptx.c	/^copy_unescaped_string (const char *string)$/;"	f	file:	signature:(const char *string)
copy_with_block	dd.c	/^copy_with_block (char const *buf, size_t nread)$/;"	f	file:	signature:(char const *buf, size_t nread)
copy_with_unblock	dd.c	/^copy_with_unblock (char const *buf, size_t nread)$/;"	f	file:	signature:(char const *buf, size_t nread)
count	join.c	/^    size_t count;			\/* Elements used in 'lines'.  *\/$/;"	m	struct:seq	file:	access:public
count	tr.c	/^typedef uintmax_t count;$/;"	t	file:
count	tsort.c	/^  size_t count;$/;"	m	struct:item	file:	access:public
count_ampersands	pinky.c	/^count_ampersands (const char *str)$/;"	f	file:	signature:(const char *str)
count_bytes	fold.c	/^static bool count_bytes;$/;"	v	file:
count_consecutive_X_s	mktemp.c	/^count_consecutive_X_s (const char *s, size_t len)$/;"	f	file:	signature:(const char *s, size_t len)
count_items	tsort.c	/^count_items (struct item *unused ATTRIBUTE_UNUSED)$/;"	f	file:	signature:(struct item *unused ATTRIBUTE_UNUSED)
count_leading_zeros	factor.c	343;"	d	file:
count_leading_zeros	longlong.h	/^long __MPN(count_leading_zeros) (UDItype) __attribute__ ((const));$/;"	p	signature:(UDItype)
count_leading_zeros	longlong.h	/^long __MPN(count_leading_zeros) (UDItype);$/;"	p	signature:(UDItype)
count_leading_zeros	longlong.h	1022;"	d
count_leading_zeros	longlong.h	1074;"	d
count_leading_zeros	longlong.h	1167;"	d
count_leading_zeros	longlong.h	1184;"	d
count_leading_zeros	longlong.h	1352;"	d
count_leading_zeros	longlong.h	1452;"	d
count_leading_zeros	longlong.h	1543;"	d
count_leading_zeros	longlong.h	1677;"	d
count_leading_zeros	longlong.h	2064;"	d
count_leading_zeros	longlong.h	219;"	d
count_leading_zeros	longlong.h	236;"	d
count_leading_zeros	longlong.h	256;"	d
count_leading_zeros	longlong.h	276;"	d
count_leading_zeros	longlong.h	319;"	d
count_leading_zeros	longlong.h	400;"	d
count_leading_zeros	longlong.h	525;"	d
count_leading_zeros	longlong.h	555;"	d
count_leading_zeros	longlong.h	625;"	d
count_leading_zeros	longlong.h	655;"	d
count_leading_zeros	longlong.h	907;"	d
count_leading_zeros	longlong.h	931;"	d
count_leading_zeros	longlong.h	947;"	d
count_leading_zeros	longlong.h	961;"	d
count_leading_zeros	longlong.h	971;"	d
count_leading_zeros_gcc_clz	longlong.h	141;"	d
count_leading_zeros_gcc_clz	longlong.h	147;"	d
count_lines	tail.c	/^static bool count_lines;$/;"	v	file:
count_none	uniq.c	/^  count_none			\/* Default.  Do not print counts. *\/$/;"	e	enum:countmode	file:
count_occurrences	uniq.c	/^  count_occurrences,		\/* -c Print count before output lines. *\/$/;"	e	enum:countmode	file:
count_trailing_zeros	factor.c	357;"	d	file:
count_trailing_zeros	longlong.h	1031;"	d
count_trailing_zeros	longlong.h	1291;"	d
count_trailing_zeros	longlong.h	2104;"	d
count_trailing_zeros	longlong.h	2116;"	d
count_trailing_zeros	longlong.h	221;"	d
count_trailing_zeros	longlong.h	335;"	d
count_trailing_zeros	longlong.h	981;"	d
count_trailing_zeros	longlong.h	985;"	d
count_trailing_zeros_gcc_ctz	longlong.h	155;"	d
count_trailing_zeros_gcc_ctz	longlong.h	161;"	d
countmode	uniq.c	/^enum countmode$/;"	g	file:
countmode	uniq.c	/^static enum countmode countmode;$/;"	v	typeref:enum:countmode	file:
cp_option_init	cp.c	/^cp_option_init (struct cp_options *x)$/;"	f	file:	signature:(struct cp_options *x)
cp_option_init	install.c	/^cp_option_init (struct cp_options *x)$/;"	f	file:	signature:(struct cp_options *x)
cp_option_init	mv.c	/^cp_option_init (struct cp_options *x)$/;"	f	file:	signature:(struct cp_options *x)
cp_options	copy.h	/^struct cp_options$/;"	s
cp_options::backup_type	copy.h	/^  enum backup_type backup_type;$/;"	m	struct:cp_options	typeref:enum:cp_options::backup_type	access:public
cp_options::chown_privileges	copy.h	/^  bool chown_privileges;$/;"	m	struct:cp_options	access:public
cp_options::copy_as_regular	copy.h	/^  bool copy_as_regular;$/;"	m	struct:cp_options	access:public
cp_options::data_copy_required	copy.h	/^  bool data_copy_required;$/;"	m	struct:cp_options	access:public
cp_options::dereference	copy.h	/^  enum Dereference_symlink dereference;$/;"	m	struct:cp_options	typeref:enum:cp_options::Dereference_symlink	access:public
cp_options::dest_info	copy.h	/^  Hash_table *dest_info;$/;"	m	struct:cp_options	access:public
cp_options::explicit_no_preserve_mode	copy.h	/^  bool explicit_no_preserve_mode;$/;"	m	struct:cp_options	access:public
cp_options::hard_link	copy.h	/^  bool hard_link;$/;"	m	struct:cp_options	access:public
cp_options::interactive	copy.h	/^  enum Interactive interactive;$/;"	m	struct:cp_options	typeref:enum:cp_options::Interactive	access:public
cp_options::mode	copy.h	/^  mode_t mode;$/;"	m	struct:cp_options	access:public
cp_options::move_mode	copy.h	/^  bool move_mode;$/;"	m	struct:cp_options	access:public
cp_options::one_file_system	copy.h	/^  bool one_file_system;$/;"	m	struct:cp_options	access:public
cp_options::open_dangling_dest_symlink	copy.h	/^  bool open_dangling_dest_symlink;$/;"	m	struct:cp_options	access:public
cp_options::owner_privileges	copy.h	/^  bool owner_privileges;$/;"	m	struct:cp_options	access:public
cp_options::preserve_links	copy.h	/^  bool preserve_links;$/;"	m	struct:cp_options	access:public
cp_options::preserve_mode	copy.h	/^  bool preserve_mode;$/;"	m	struct:cp_options	access:public
cp_options::preserve_ownership	copy.h	/^  bool preserve_ownership;$/;"	m	struct:cp_options	access:public
cp_options::preserve_security_context	copy.h	/^  bool preserve_security_context;$/;"	m	struct:cp_options	access:public
cp_options::preserve_timestamps	copy.h	/^  bool preserve_timestamps;$/;"	m	struct:cp_options	access:public
cp_options::preserve_xattr	copy.h	/^  bool preserve_xattr;$/;"	m	struct:cp_options	access:public
cp_options::recursive	copy.h	/^  bool recursive;$/;"	m	struct:cp_options	access:public
cp_options::reduce_diagnostics	copy.h	/^  bool reduce_diagnostics;$/;"	m	struct:cp_options	access:public
cp_options::reflink_mode	copy.h	/^  enum Reflink_type reflink_mode;$/;"	m	struct:cp_options	typeref:enum:cp_options::Reflink_type	access:public
cp_options::require_preserve	copy.h	/^  bool require_preserve;$/;"	m	struct:cp_options	access:public
cp_options::require_preserve_context	copy.h	/^  bool require_preserve_context;$/;"	m	struct:cp_options	access:public
cp_options::require_preserve_xattr	copy.h	/^  bool require_preserve_xattr;$/;"	m	struct:cp_options	access:public
cp_options::set_mode	copy.h	/^  bool set_mode;$/;"	m	struct:cp_options	access:public
cp_options::sparse_mode	copy.h	/^  enum Sparse_type sparse_mode;$/;"	m	struct:cp_options	typeref:enum:cp_options::Sparse_type	access:public
cp_options::src_info	copy.h	/^  Hash_table *src_info;$/;"	m	struct:cp_options	access:public
cp_options::stdin_tty	copy.h	/^  bool stdin_tty;$/;"	m	struct:cp_options	access:public
cp_options::symbolic_link	copy.h	/^  bool symbolic_link;$/;"	m	struct:cp_options	access:public
cp_options::unlink_dest_after_failed_open	copy.h	/^  bool unlink_dest_after_failed_open;$/;"	m	struct:cp_options	access:public
cp_options::unlink_dest_before_opening	copy.h	/^  bool unlink_dest_before_opening;$/;"	m	struct:cp_options	access:public
cp_options::update	copy.h	/^  bool update;$/;"	m	struct:cp_options	access:public
cp_options::verbose	copy.h	/^  bool verbose;$/;"	m	struct:cp_options	access:public
cp_options_default	copy.c	/^cp_options_default (struct cp_options *x)$/;"	f	signature:(struct cp_options *x)
cp_options_default	copy.h	/^void cp_options_default (struct cp_options *);$/;"	p	signature:(struct cp_options *)
crc_remainder	cksum.c	/^crc_remainder (int m)$/;"	f	file:	signature:(int m)
crctab	cksum.c	/^static uint_fast32_t const crctab[256] =$/;"	v	file:
create	split.c	/^create (const char *name)$/;"	f	file:	signature:(const char *name)
create_fullname	pinky.c	/^create_fullname (const char *gecos_name, const char *user_name)$/;"	f	file:	signature:(const char *gecos_name, const char *user_name)
create_hard_link	copy.c	/^create_hard_link (char const *src_name, char const *dst_name,$/;"	f	file:	signature:(char const *src_name, char const *dst_name, bool replace, bool verbose)
create_new_buffer	csplit.c	/^create_new_buffer (size_t size)$/;"	f	file:	signature:(size_t size)
create_output_file	csplit.c	/^create_output_file (void)$/;"	f	file:	signature:(void)
create_output_file	csplit.c	/^static void create_output_file (void);$/;"	p	file:	signature:(void)
create_temp	sort.c	/^create_temp (FILE **pfp)$/;"	f	file:	signature:(FILE **pfp)
create_temp_file	sort.c	/^create_temp_file (int *pfd, bool survive_fd_exhaustion)$/;"	f	file:	signature:(int *pfd, bool survive_fd_exhaustion)
created_directory_format	mkdir.c	/^  char const *created_directory_format;$/;"	m	struct:mkdir_options	file:	access:public
crown	fmt.c	/^static bool crown;$/;"	v	file:
cs_enter	sort.c	/^cs_enter (void)$/;"	f	file:	signature:(void)
cs_leave	sort.c	/^cs_leave (struct cs_status status)$/;"	f	file:	signature:(struct cs_status status)
cs_status	sort.c	/^struct cs_status$/;"	s	file:
cs_status::sigs	sort.c	/^  sigset_t sigs;$/;"	m	struct:cs_status	file:	access:public
cs_status::valid	sort.c	/^  bool valid;$/;"	m	struct:cs_status	file:	access:public
cstring	csplit.c	/^struct cstring$/;"	s	file:
cstring::len	csplit.c	/^  size_t len;$/;"	m	struct:cstring	file:	access:public
cstring::str	csplit.c	/^  char *str;$/;"	m	struct:cstring	file:	access:public
cu_install_program	local.mk	/^cu_install_program = @INSTALL_PROGRAM@$/;"	m
cu_install_program	local.mk	/^cu_install_program = src\/ginstall$/;"	m
curr_line	csplit.c	/^  struct line *curr_line;	\/* The line start record currently in use. *\/$/;"	m	struct:buffer_record	typeref:struct:buffer_record::line	file:	access:public
current_col	stty.c	/^static int current_col;$/;"	v	file:
current_line	csplit.c	/^static uintmax_t current_line = 0;$/;"	v	file:
current_line	pr.c	/^    int current_line;		\/* Index of current place in line_vector. *\/$/;"	m	struct:COLUMN	file:	access:public
current_regex	nl.c	/^static struct re_pattern_buffer *current_regex = NULL;$/;"	v	typeref:struct:re_pattern_buffer	file:
current_time	ls.c	/^static struct timespec current_time;$/;"	v	typeref:struct:timespec	file:
current_type	nl.c	/^static char const *current_type;$/;"	v	file:
custom_header	pr.c	/^static char *custom_header;$/;"	v	file:
cut_bytes	cut.c	/^cut_bytes (FILE *stream)$/;"	f	file:	signature:(FILE *stream)
cut_fields	cut.c	/^cut_fields (FILE *stream)$/;"	f	file:	signature:(FILE *stream)
cut_file	cut.c	/^cut_file (char const *file)$/;"	f	file:	signature:(char const *file)
cut_stream	cut.c	/^cut_stream (FILE *stream)$/;"	f	file:	signature:(FILE *stream)
cwd_file	ls.c	/^static struct fileinfo *cwd_file;$/;"	v	typeref:struct:fileinfo	file:
cwd_n_alloc	ls.c	/^static size_t cwd_n_alloc;$/;"	v	file:
cwd_n_used	ls.c	/^static size_t cwd_n_used;$/;"	v	file:
cwrite	split.c	/^cwrite (bool new_file_flag, const char *bp, size_t bytes)$/;"	f	file:	signature:(bool new_file_flag, const char *bp, size_t bytes)
data_copy_required	copy.h	/^  bool data_copy_required;$/;"	m	struct:cp_options	access:public
date_format	pr.c	/^static char const *date_format;$/;"	v	file:
date_text	pr.c	/^static char *date_text;$/;"	v	file:
dc_parse_file	dircolors.c	/^dc_parse_file (const char *filename)$/;"	f	file:	signature:(const char *filename)
dc_parse_stream	dircolors.c	/^dc_parse_stream (FILE *fp, const char *filename)$/;"	f	file:	signature:(FILE *fp, const char *filename)
dd_copy	dd.c	/^dd_copy (void)$/;"	f	file:	signature:(void)
debug	numfmt.c	/^static bool debug;$/;"	v	file:
debug	sort.c	/^static bool debug;$/;"	v	file:
debug_key	sort.c	/^debug_key (struct line const *line, struct keyfield const *key)$/;"	f	file:	signature:(struct line const *line, struct keyfield const *key)
debug_line	sort.c	/^debug_line (struct line const *line)$/;"	f	file:	signature:(struct line const *line)
debug_width	sort.c	/^debug_width (char const *text, char const *lim)$/;"	f	file:	signature:(char const *text, char const *lim)
decimal_absval_add_one	getlimits.c	/^decimal_absval_add_one (char *buf)$/;"	f	file:	signature:(char *buf)
decimal_point	numfmt.c	/^static const char *decimal_point;$/;"	v	file:
decimal_point	sort.c	/^static int decimal_point;$/;"	v	file:
decimal_point	stat.c	/^static char const *decimal_point;$/;"	v	file:
decimal_point_len	stat.c	/^static size_t decimal_point_len;$/;"	v	file:
decimal_point_length	numfmt.c	/^static int decimal_point_length;$/;"	v	file:
decode_field_spec	join.c	/^decode_field_spec (const char *s, int *file_index, size_t *field_index)$/;"	f	file:	signature:(const char *s, int *file_index, size_t *field_index)
decode_format_string	od.c	/^decode_format_string (const char *s)$/;"	f	file:	signature:(const char *s)
decode_one_format	od.c	/^decode_one_format (const char *s_orig, const char *s, const char **next,$/;"	f	file:	signature:(const char *s_orig, const char *s, const char **next, struct tspec *tspec)
decode_output_arg	df.c	/^decode_output_arg (char const *arg)$/;"	f	file:	signature:(char const *arg)
decode_preserve_arg	cp.c	/^decode_preserve_arg (char const *arg, struct cp_options *x, bool on_off)$/;"	f	file:	signature:(char const *arg, struct cp_options *x, bool on_off)
decode_switches	ls.c	/^decode_switches (int argc, char **argv)$/;"	f	file:	signature:(int argc, char **argv)
decode_switches	ls.c	/^static int decode_switches (int argc, char **argv);$/;"	p	file:	signature:(int argc, char **argv)
decode_switches	uname.c	/^decode_switches (int argc, char **argv)$/;"	f	file:	signature:(int argc, char **argv)
default__progs	cu-progs.mk	/^default__progs =$/;"	m
default_file_list	od.c	/^static char const *const default_file_list[] = {"-", NULL};$/;"	v	file:
default_format	stat.c	/^default_format (bool fs, bool terse, bool device)$/;"	f	file:	signature:(bool fs, bool terse, bool device)
default_key_compare	sort.c	/^default_key_compare (struct keyfield const *key)$/;"	f	file:	signature:(struct keyfield const *key)
default_scale_base	numfmt.c	/^default_scale_base (enum scale_type scale)$/;"	f	file:	signature:(enum scale_type scale)
default_sort_size	sort.c	/^default_sort_size (void)$/;"	f	file:	signature:(void)
default_template	mktemp.c	/^static const char *default_template = "tmp.XXXXXXXXXX";$/;"	v	file:
define_all_fields	ptx.c	/^define_all_fields (OCCURS *occurs)$/;"	f	file:	signature:(OCCURS *occurs)
delete	tr.c	/^static bool delete = false;$/;"	v	file:
delete_all_files	csplit.c	/^delete_all_files (bool in_signal_handler)$/;"	f	file:	signature:(bool in_signal_handler)
delete_all_files	csplit.c	/^static void delete_all_files (bool);$/;"	p	file:
delete_proc	sort.c	/^delete_proc (pid_t pid)$/;"	f	file:	signature:(pid_t pid)
delete_proc	sort.c	/^static bool delete_proc (pid_t);$/;"	p	file:
delim	cut.c	/^static unsigned char delim;$/;"	v	file:
delim_end	paste.c	/^static char const *delim_end;$/;"	v	file:
delimit_groups	uniq.c	/^static enum delimit_method delimit_groups;$/;"	v	typeref:enum:delimit_method	file:
delimit_method	uniq.c	/^enum delimit_method$/;"	g	file:
delimit_method_map	uniq.c	/^static enum delimit_method const delimit_method_map[] =$/;"	v	file:
delimit_method_string	uniq.c	/^static char const *const delimit_method_string[] =$/;"	v	file:
delimiter	comm.c	/^static char const *delimiter;$/;"	v	file:
delimiter	numfmt.c	/^static int delimiter = DELIMITER_DEFAULT;$/;"	v	file:
delims	paste.c	/^static char *delims;$/;"	v	file:
delseq	join.c	/^delseq (struct seq *seq)$/;"	f	file:	signature:(struct seq *seq)
dereference	copy.h	/^  enum Dereference_symlink dereference;$/;"	m	struct:cp_options	typeref:enum:cp_options::Dereference_symlink	access:public
dereference	ls.c	/^static enum Dereference_symlink dereference;$/;"	v	typeref:enum:Dereference_symlink	file:
dereference_dest_dir_symlinks	ln.c	/^static bool dereference_dest_dir_symlinks = true;$/;"	v	file:
describe_change	chmod.c	/^describe_change (const char *file, mode_t old_mode, mode_t mode,$/;"	f	file:	signature:(const char *file, mode_t old_mode, mode_t mode, enum Change_status changed)
describe_change	chown-core.c	/^describe_change (const char *file, enum Change_status changed,$/;"	f	file:	signature:(const char *file, enum Change_status changed, char const *old_user, char const *old_group, char const *user, char const *group)
dest	sort.c	/^  struct line **dest;           \/* Pointer to destination of merge. *\/$/;"	m	struct:merge_node	typeref:struct:merge_node::line	file:	access:public
dest_info	copy.h	/^  Hash_table *dest_info;$/;"	m	struct:cp_options	access:public
dest_info_init	copy.c	/^dest_info_init (struct cp_options *x)$/;"	f	signature:(struct cp_options *x)
dest_info_init	copy.h	/^void dest_info_init (struct cp_options *);$/;"	p	signature:(struct cp_options *)
dest_set	ln.c	/^static Hash_table *dest_set;$/;"	v	file:
detect_loop	tsort.c	/^detect_loop (struct item *k)$/;"	f	file:	signature:(struct item *k)
dev	copy.c	/^  dev_t dev;$/;"	m	struct:dir_list	file:	access:public
dev	tail.c	/^  dev_t dev;$/;"	m	struct:File_spec	file:	access:public
dev_debug	factor.c	/^static bool dev_debug = false;$/;"	v	file:
dev_debug	numfmt.c	/^static bool dev_debug = false;$/;"	v	file:
dev_ino_compare	ls.c	/^dev_ino_compare (void const *x, void const *y)$/;"	f	file:	signature:(void const *x, void const *y)
dev_ino_free	ls.c	/^dev_ino_free (void *x)$/;"	f	file:	signature:(void *x)
dev_ino_hash	ls.c	/^dev_ino_hash (void const *x, size_t table_size)$/;"	f	file:	signature:(void const *x, size_t table_size)
dev_ino_obstack	ls.c	/^static struct obstack dev_ino_obstack;$/;"	v	typeref:struct:obstack	file:
dev_ino_pop	ls.c	/^dev_ino_pop (void)$/;"	f	file:	signature:(void)
dev_num	df.c	/^  dev_t dev_num;$/;"	m	struct:devlist	file:	access:public
devlist	df.c	/^struct devlist$/;"	s	file:
devlist::dev_num	df.c	/^  dev_t dev_num;$/;"	m	struct:devlist	file:	access:public
devlist::me	df.c	/^  struct mount_entry *me;$/;"	m	struct:devlist	typeref:struct:devlist::mount_entry	file:	access:public
devlist::next	df.c	/^  struct devlist *next;$/;"	m	struct:devlist	typeref:struct:devlist::devlist	file:	access:public
devmsg	factor.c	/^devmsg (char const *fmt, ...)$/;"	f	file:	signature:(char const *fmt, ...)
devmsg	numfmt.c	/^devmsg (char const *fmt, ...)$/;"	f	file:	signature:(char const *fmt, ...)
df_readable	df.c	/^df_readable (bool negative, uintmax_t n, char *buf,$/;"	f	file:	signature:(bool negative, uintmax_t n, char *buf, uintmax_t input_units, uintmax_t output_units)
di_files	du.c	/^static struct di_set *di_files;$/;"	v	typeref:struct:di_set	file:
di_mnt	du.c	/^static struct di_set *di_mnt;$/;"	v	typeref:struct:di_set	file:
diagnose_copy_fd_failure	head.c	/^diagnose_copy_fd_failure (enum Copy_fd_status err, char const *filename)$/;"	f	file:	signature:(enum Copy_fd_status err, char const *filename)
diagnose_leading_hyphen	rm.c	/^diagnose_leading_hyphen (int argc, char **argv)$/;"	f	file:	signature:(int argc, char **argv)
diagnose_surprises	chmod.c	/^static bool diagnose_surprises;$/;"	v	file:
die	expr.c	/^die (int errno_val, char const *msg)$/;"	f	file:	signature:(int errno_val, char const *msg)
die	sort.c	/^die (char const *message, char const *file)$/;"	f	file:	signature:(char const *message, char const *file)
different	uniq.c	/^different (char *old, char *new, size_t oldlen, size_t newlen)$/;"	f	file:	signature:(char *old, char *new, size_t oldlen, size_t newlen)
digest_break_file	ptx.c	/^digest_break_file (const char *file_name)$/;"	f	file:	signature:(const char *file_name)
digest_check	md5sum.c	/^digest_check (const char *checkfile_name)$/;"	f	file:	signature:(const char *checkfile_name)
digest_file	md5sum.c	/^digest_file (const char *filename, int *binary, unsigned char *bin_result)$/;"	f	file:	signature:(const char *filename, int *binary, unsigned char *bin_result)
digest_hex_bytes	md5sum.c	/^static size_t digest_hex_bytes;$/;"	v	file:
digest_word_file	ptx.c	/^digest_word_file (const char *file_name, WORD_TABLE *table)$/;"	f	file:	signature:(const char *file_name, WORD_TABLE *table)
digits	csplit.c	/^static int volatile digits = 2;$/;"	v	file:
digits	stat.c	/^static char const digits[] = "0123456789";$/;"	v	file:
dir_arg	install.c	/^static bool dir_arg;$/;"	v	file:
dir_attr	cp.c	/^struct dir_attr$/;"	s	file:
dir_attr::next	cp.c	/^  struct dir_attr *next;$/;"	m	struct:dir_attr	typeref:struct:dir_attr::dir_attr	file:	access:public
dir_attr::restore_mode	cp.c	/^  bool restore_mode;$/;"	m	struct:dir_attr	file:	access:public
dir_attr::slash_offset	cp.c	/^  size_t slash_offset;$/;"	m	struct:dir_attr	file:	access:public
dir_attr::st	cp.c	/^  struct stat st;$/;"	m	struct:dir_attr	typeref:struct:dir_attr::stat	file:	access:public
dir_list	copy.c	/^struct dir_list$/;"	s	file:
dir_list::dev	copy.c	/^  dev_t dev;$/;"	m	struct:dir_list	file:	access:public
dir_list::ino	copy.c	/^  ino_t ino;$/;"	m	struct:dir_list	file:	access:public
dir_list::parent	copy.c	/^  struct dir_list *parent;$/;"	m	struct:dir_list	typeref:struct:dir_list::dir_list	file:	access:public
dir_mode	install.c	/^static mode_t dir_mode = DEFAULT_MODE;$/;"	v	file:
dir_mode_bits	install.c	/^static mode_t dir_mode_bits = CHMOD_MODE_BITS;$/;"	v	file:
direct_mode	shred.c	/^direct_mode (int fd, bool enable)$/;"	f	file:	signature:(int fd, bool enable)
directories_first	ls.c	/^static bool directories_first;$/;"	v	file:
directory	ls.c	/^    directory,$/;"	e	enum:filetype	file:
dired	ls.c	/^static bool dired;$/;"	v	file:
dired_dump_obstack	ls.c	/^dired_dump_obstack (const char *prefix, struct obstack *os)$/;"	f	file:	signature:(const char *prefix, struct obstack *os)
dired_obstack	ls.c	/^static struct obstack dired_obstack;$/;"	v	typeref:struct:obstack	file:
dired_pos	ls.c	/^static size_t dired_pos;$/;"	v	file:
dirname_quoting_options	ls.c	/^static struct quoting_options *dirname_quoting_options;$/;"	v	typeref:struct:quoting_options	file:
disable_core_dumps	timeout.c	/^disable_core_dumps (void)$/;"	f	file:	signature:(void)
disable_inotify	tail.c	/^static bool disable_inotify;$/;"	v	file:
display_all	stty.c	/^display_all (struct termios *mode, char const *device_name)$/;"	f	file:	signature:(struct termios *mode, char const *device_name)
display_all	stty.c	/^static void display_all (struct termios *mode, char const *device_name);$/;"	p	file:	signature:(struct termios *mode, char const *device_name)
display_changed	stty.c	/^display_changed (struct termios *mode)$/;"	f	file:	signature:(struct termios *mode)
display_changed	stty.c	/^static void display_changed (struct termios *mode);$/;"	p	file:	signature:(struct termios *mode)
display_field_t	df.c	/^} display_field_t;$/;"	t	typeref:enum:__anon51	file:
display_recoverable	stty.c	/^display_recoverable (struct termios *mode)$/;"	f	file:	signature:(struct termios *mode)
display_recoverable	stty.c	/^static void display_recoverable (struct termios *mode);$/;"	p	file:	signature:(struct termios *mode)
display_settings	stty.c	/^display_settings (enum output_type output_type, struct termios *mode,$/;"	f	file:	signature:(enum output_type output_type, struct termios *mode, char const *device_name)
display_settings	stty.c	/^static void display_settings (enum output_type output_type,$/;"	p	file:	signature:(enum output_type output_type, struct termios *mode, const char *device_name)
display_speed	stty.c	/^display_speed (struct termios *mode, bool fancy)$/;"	f	file:	signature:(struct termios *mode, bool fancy)
display_speed	stty.c	/^static void display_speed (struct termios *mode, bool fancy);$/;"	p	file:	signature:(struct termios *mode, bool fancy)
display_window_size	stty.c	/^display_window_size (bool fancy, char const *device_name)$/;"	f	file:	signature:(bool fancy, char const *device_name)
display_window_size	stty.c	/^static void display_window_size (bool fancy, char const *device_name);$/;"	p	file:	signature:(bool fancy, char const *device_name)
div_smallq	factor.c	1878;"	d	file:
divexact_21	factor.c	929;"	d	file:
do_copy	cp.c	/^do_copy (int n_files, char **file, const char *target_directory,$/;"	f	file:	signature:(int n_files, char **file, const char *target_directory, bool no_target_directory, struct cp_options *x)
do_decode	base64.c	/^do_decode (FILE *in, FILE *out, bool ignore_garbage)$/;"	f	file:	signature:(FILE *in, FILE *out, bool ignore_garbage)
do_encode	base64.c	/^do_encode (FILE *in, FILE *out, uintmax_t wrap_column)$/;"	f	file:	signature:(FILE *in, FILE *out, uintmax_t wrap_column)
do_ftruncate	truncate.c	/^do_ftruncate (int fd, char const *fname, off_t ssize, off_t rsize,$/;"	f	file:	signature:(int fd, char const *fname, off_t ssize, off_t rsize, rel_mode_t rel_mode)
do_link	ln.c	/^do_link (const char *source, const char *dest)$/;"	f	file:	signature:(const char *source, const char *dest)
do_lookup	who.c	/^static bool do_lookup;$/;"	v	file:
do_move	mv.c	/^do_move (const char *source, const char *dest, const struct cp_options *x)$/;"	f	file:	signature:(const char *source, const char *dest, const struct cp_options *x)
do_short_format	pinky.c	/^static bool do_short_format = true;$/;"	v	file:
do_stat	stat.c	/^do_stat (char const *filename, char const *format,$/;"	f	file:	signature:(char const *filename, char const *format, char const *format2)
do_statfs	stat.c	/^do_statfs (char const *filename, char const *format)$/;"	f	file:	signature:(char const *filename, char const *format)
do_stdin	factor.c	/^do_stdin (void)$/;"	f	file:	signature:(void)
do_wipefd	shred.c	/^do_wipefd (int fd, char const *qname, struct randint_source *s,$/;"	f	file:	signature:(int fd, char const *qname, struct randint_source *s, struct Options const *flags)
docolon	expr.c	/^docolon (VALUE *sv, VALUE *pv)$/;"	f	file:	signature:(VALUE *sv, VALUE *pv)
dopass	shred.c	/^dopass (int fd, char const *qname, off_t *sizep, int type,$/;"	f	file:	signature:(int fd, char const *qname, off_t *sizep, int type, struct randread_source *s, unsigned long int k, unsigned long int n)
dosync	shred.c	/^dosync (int fd, char const *qname)$/;"	f	file:	signature:(int fd, char const *qname)
dot_or_dotdot	system.h	/^dot_or_dotdot (char const *file_name)$/;"	f	signature:(char const *file_name)
double_space	pr.c	/^static bool double_space = false;$/;"	v	file:
double_to_human	numfmt.c	/^double_to_human (long double val, int precision,$/;"	f	file:	signature:(long double val, int precision, char *buf, size_t buf_size, enum scale_type scale, int group, enum round_type round)
du_files	du.c	/^du_files (char **files, int bit_flags)$/;"	f	file:	signature:(char **files, int bit_flags)
duinfo	du.c	/^struct duinfo$/;"	s	file:
duinfo::size	du.c	/^  uintmax_t size;$/;"	m	struct:duinfo	file:	access:public
duinfo::tmax	du.c	/^  struct timespec tmax;$/;"	m	struct:duinfo	typeref:struct:duinfo::timespec	file:	access:public
duinfo_add	du.c	/^duinfo_add (struct duinfo *a, struct duinfo const *b)$/;"	f	file:	signature:(struct duinfo *a, struct duinfo const *b)
duinfo_init	du.c	/^duinfo_init (struct duinfo *a)$/;"	f	file:	signature:(struct duinfo *a)
duinfo_set	du.c	/^duinfo_set (struct duinfo *a, uintmax_t size, struct timespec tmax)$/;"	f	file:	signature:(struct duinfo *a, uintmax_t size, struct timespec tmax)
dulevel	du.c	/^struct dulevel$/;"	s	file:
dulevel::ent	du.c	/^  struct duinfo ent;$/;"	m	struct:dulevel	typeref:struct:dulevel::duinfo	file:	access:public
dulevel::subdir	du.c	/^  struct duinfo subdir;$/;"	m	struct:dulevel	typeref:struct:dulevel::duinfo	file:	access:public
dump	od.c	/^dump (void)$/;"	f	file:	signature:(void)
dump_hexl_mode_trailer	od.c	/^dump_hexl_mode_trailer (size_t n_bytes, const char *block)$/;"	f	file:	signature:(size_t n_bytes, const char *block)
dump_remainder	tail.c	/^dump_remainder (const char *pretty_filename, int fd, uintmax_t n_bytes)$/;"	f	file:	signature:(const char *pretty_filename, int fd, uintmax_t n_bytes)
dump_rest_of_file	csplit.c	/^dump_rest_of_file (void)$/;"	f	file:	signature:(void)
dump_strings	od.c	/^dump_strings (void)$/;"	f	file:	signature:(void)
e	factor.c	/^  unsigned char e[MAX_NFACTS];$/;"	m	struct:factors	file:	access:public
e	factor.c	/^  unsigned long int *e;$/;"	m	struct:mp_factors	file:	access:public
ebcdic_to_ascii	dd.c	/^static char const ebcdic_to_ascii[] =$/;"	v	file:
echar	sort.c	/^  size_t echar;			\/* Additional characters in field. *\/$/;"	m	struct:keyfield	file:	access:public
edited_flag	ptx.c	/^static char edited_flag[CHAR_SET_SIZE];$/;"	v	file:
egid	id.c	/^static gid_t rgid, egid;$/;"	v	file:
ei_count	extent-scan.h	/^  uint32_t ei_count;$/;"	m	struct:extent_scan	access:public
elide_empty_files	csplit.c	/^static bool elide_empty_files;$/;"	v	file:
elide_empty_files	split.c	/^static bool elide_empty_files;$/;"	v	file:
elide_tail_bytes_file	head.c	/^elide_tail_bytes_file (const char *filename, int fd, uintmax_t n_elide)$/;"	f	file:	signature:(const char *filename, int fd, uintmax_t n_elide)
elide_tail_bytes_pipe	head.c	/^elide_tail_bytes_pipe (const char *filename, int fd, uintmax_t n_elide_0)$/;"	f	file:	signature:(const char *filename, int fd, uintmax_t n_elide_0)
elide_tail_lines_file	head.c	/^elide_tail_lines_file (const char *filename, int fd, uintmax_t n_elide)$/;"	f	file:	signature:(const char *filename, int fd, uintmax_t n_elide)
elide_tail_lines_pipe	head.c	/^elide_tail_lines_pipe (const char *filename, int fd, uintmax_t n_elide)$/;"	f	file:	signature:(const char *filename, int fd, uintmax_t n_elide)
elide_tail_lines_seekable	head.c	/^elide_tail_lines_seekable (const char *pretty_filename, int fd,$/;"	f	file:	signature:(const char *pretty_filename, int fd, uintmax_t n_lines, off_t start_pos, off_t end_pos)
emit_ancillary_info	system.h	/^emit_ancillary_info (void)$/;"	f	signature:(void)
emit_blocksize_note	system.h	/^emit_blocksize_note (char const *program)$/;"	f	signature:(char const *program)
emit_bug_reporting_address	system.h	356;"	d
emit_bug_reporting_address	system.h	358;"	d
emit_cycle_warning	system.h	625;"	d
emit_mandatory_arg_note	system.h	/^emit_mandatory_arg_note (void)$/;"	f	signature:(void)
emit_size_note	system.h	/^emit_size_note (void)$/;"	f	signature:(void)
emit_try_help	system.h	/^emit_try_help (void)$/;"	f	signature:(void)
emit_verbose	copy.c	/^emit_verbose (char const *src, char const *dst, char const *backup_dst_name)$/;"	f	file:	signature:(char const *src, char const *dst, char const *backup_dst_name)
empty_filler	join.c	/^static char const *empty_filler;$/;"	v	file:
empty_line	pr.c	/^static bool empty_line;$/;"	v	file:
end	ptx.c	/^    char *end;			\/* pointer to end + 1 of region *\/$/;"	m	struct:__anon29	file:	access:public
end_hi	sort.c	/^  struct line *end_hi;          \/* End of available lines from HI. *\/$/;"	m	struct:merge_node	typeref:struct:merge_node::line	file:	access:public
end_lo	sort.c	/^  struct line *end_lo;          \/* End of available lines from LO. *\/$/;"	m	struct:merge_node	typeref:struct:merge_node::line	file:	access:public
end_offset	od.c	/^static uintmax_t end_offset;$/;"	v	file:
end_vector	pr.c	/^static int *end_vector;$/;"	v	file:
endgrent	chgrp.c	41;"	d	file:
endgrent	install.c	56;"	d	file:
endpwent	install.c	60;"	d	file:
ent	du.c	/^  struct duinfo ent;$/;"	m	struct:dulevel	typeref:struct:dulevel::duinfo	file:	access:public
eof	sort.c	/^  bool eof;			\/* An EOF has been read.  *\/$/;"	m	struct:buffer	file:	access:public
eol_range_start	cut.c	/^static size_t eol_range_start;$/;"	v	file:
eolchar	sort.c	/^static char eolchar = '\\n';$/;"	v	file:
equal_width	seq.c	/^static bool equal_width;$/;"	v	file:
equiv_code	tr.c	/^        unsigned char equiv_code;$/;"	m	union:List_element::__anon3	file:	access:public
errno_may_be_empty	rmdir.c	/^errno_may_be_empty (int error_number)$/;"	f	file:	signature:(int error_number)
errno_rmdir_non_empty	rmdir.c	/^errno_rmdir_non_empty (int error_number)$/;"	f	file:	signature:(int error_number)
errno_unsupported	copy.c	/^errno_unsupported (int err)$/;"	f	file:	signature:(int err)
errno_unsupported	ls.c	/^errno_unsupported (int err)$/;"	f	file:	signature:(int err)
errnum	tail.c	/^  int errnum;$/;"	m	struct:File_spec	file:	access:public
es_free	tr.c	/^es_free (struct E_string *es)$/;"	f	file:	signature:(struct E_string *es)
es_match	tr.c	/^es_match (struct E_string const *es, size_t i, char c)$/;"	f	file:	signature:(struct E_string const *es, size_t i, char c)
escaped	tr.c	/^  bool *escaped;$/;"	m	struct:E_string	file:	access:public
euid	id.c	/^static uid_t ruid, euid;$/;"	v	file:
eval	expr.c	/^eval (bool evaluate)$/;"	f	file:	signature:(bool evaluate)
eval	expr.c	/^static VALUE *eval (bool);$/;"	p	file:
eval1	expr.c	/^eval1 (bool evaluate)$/;"	f	file:	signature:(bool evaluate)
eval2	expr.c	/^eval2 (bool evaluate)$/;"	f	file:	signature:(bool evaluate)
eval3	expr.c	/^eval3 (bool evaluate)$/;"	f	file:	signature:(bool evaluate)
eval4	expr.c	/^eval4 (bool evaluate)$/;"	f	file:	signature:(bool evaluate)
eval5	expr.c	/^eval5 (bool evaluate)$/;"	f	file:	signature:(bool evaluate)
eval6	expr.c	/^eval6 (bool evaluate)$/;"	f	file:	signature:(bool evaluate)
eval7	expr.c	/^eval7 (bool evaluate)$/;"	f	file:	signature:(bool evaluate)
eword	sort.c	/^  size_t eword;			\/* Zero-origin last 'word' of key. *\/$/;"	m	struct:keyfield	file:	access:public
exact	shred.c	/^  bool exact;		\/* -x flag: Do not round up file size *\/$/;"	m	struct:Options	file:	access:public
excise	remove.c	/^excise (FTS *fts, FTSENT *ent, struct rm_options const *x, bool is_dir)$/;"	f	file:	signature:(FTS *fts, FTSENT *ent, struct rm_options const *x, bool is_dir)
exclude	du.c	/^static struct exclude *exclude;$/;"	v	typeref:struct:exclude	file:
excluded_fstype	df.c	/^excluded_fstype (const char *fstype)$/;"	f	file:	signature:(const char *fstype)
exit_cleanup	sort.c	/^exit_cleanup (void)$/;"	f	file:	signature:(void)
exit_status	df.c	/^static int exit_status;$/;"	v	file:
exit_status	expand.c	/^static int exit_status;$/;"	v	file:
exit_status	ls.c	/^static int exit_status;$/;"	v	file:
exit_status	printf.c	/^static int exit_status;$/;"	v	file:
exit_status	unexpand.c	/^static int exit_status;$/;"	v	file:
expand	expand.c	/^expand (void)$/;"	f	file:	signature:(void)
expld	numfmt.c	/^expld (long double val, unsigned int base, unsigned int \/*output *\/ *x)$/;"	f	file:	signature:(long double val, unsigned int base, unsigned int *x)
explicit_columns	pr.c	/^static bool explicit_columns = false;$/;"	v	file:
explicit_no_preserve_mode	copy.h	/^  bool explicit_no_preserve_mode;$/;"	m	struct:cp_options	access:public
expr	test.c	/^expr (void)$/;"	f	file:	signature:(void)
expr	test.c	/^static bool expr (void);$/;"	p	file:	signature:(void)
ext	ls.c	/^    struct bin_str ext;		\/* The extension we're looking for *\/$/;"	m	struct:color_ext_type	typeref:struct:color_ext_type::bin_str	file:	access:public
ext_flags	extent-scan.h	/^  uint32_t ext_flags;$/;"	m	struct:extent_info	access:public
ext_info	extent-scan.h	/^  struct extent_info *ext_info;$/;"	m	struct:extent_scan	typeref:struct:extent_scan::extent_info	access:public
ext_length	extent-scan.h	/^  uint64_t ext_length;$/;"	m	struct:extent_info	access:public
ext_logical	extent-scan.h	/^  off_t ext_logical;$/;"	m	struct:extent_info	access:public
extent_copy	copy.c	/^extent_copy (int src_fd, int dest_fd, char *buf, size_t buf_size,$/;"	f	file:	signature:(int src_fd, int dest_fd, char *buf, size_t buf_size, off_t src_total_size, enum Sparse_type sparse_mode, char const *src_name, char const *dst_name, bool *require_normal_copy)
extent_info	extent-scan.h	/^struct extent_info$/;"	s
extent_info::ext_flags	extent-scan.h	/^  uint32_t ext_flags;$/;"	m	struct:extent_info	access:public
extent_info::ext_length	extent-scan.h	/^  uint64_t ext_length;$/;"	m	struct:extent_info	access:public
extent_info::ext_logical	extent-scan.h	/^  off_t ext_logical;$/;"	m	struct:extent_info	access:public
extent_need_sync	extent-scan.c	/^extent_need_sync (void)$/;"	f	file:	signature:(void)
extent_scan	extent-scan.h	/^struct extent_scan$/;"	s
extent_scan::ei_count	extent-scan.h	/^  uint32_t ei_count;$/;"	m	struct:extent_scan	access:public
extent_scan::ext_info	extent-scan.h	/^  struct extent_info *ext_info;$/;"	m	struct:extent_scan	typeref:struct:extent_scan::extent_info	access:public
extent_scan::fd	extent-scan.h	/^  int fd;$/;"	m	struct:extent_scan	access:public
extent_scan::fm_flags	extent-scan.h	/^  uint32_t fm_flags;$/;"	m	struct:extent_scan	access:public
extent_scan::hit_final_extent	extent-scan.h	/^  bool hit_final_extent;$/;"	m	struct:extent_scan	access:public
extent_scan::initial_scan_failed	extent-scan.h	/^  bool initial_scan_failed;$/;"	m	struct:extent_scan	access:public
extent_scan::scan_start	extent-scan.h	/^  off_t scan_start;$/;"	m	struct:extent_scan	access:public
extent_scan_free	extent-scan.h	/^extent_scan_free (struct extent_scan *scan)$/;"	f	signature:(struct extent_scan *scan)
extent_scan_init	extent-scan.c	/^extent_scan_init (int src_fd, struct extent_scan *scan)$/;"	f	signature:(int src_fd, struct extent_scan *scan)
extent_scan_init	extent-scan.h	/^void extent_scan_init (int src_fd, struct extent_scan *scan);$/;"	p	signature:(int src_fd, struct extent_scan *scan)
extent_scan_read	extent-scan.c	/^extent_scan_read (struct extent_scan *scan ATTRIBUTE_UNUSED)$/;"	f	signature:(struct extent_scan *scan ATTRIBUTE_UNUSED)
extent_scan_read	extent-scan.c	/^extent_scan_read (struct extent_scan *scan)$/;"	f	signature:(struct extent_scan *scan)
extent_scan_read	extent-scan.h	/^bool extent_scan_read (struct extent_scan *scan);$/;"	p	signature:(struct extent_scan *scan)
extra_mode	install.c	/^extra_mode (mode_t input)$/;"	f	file:	signature:(mode_t input)
extract_dirs_from_files	ls.c	/^extract_dirs_from_files (char const *dirname, bool command_line_arg)$/;"	f	file:	signature:(char const *dirname, bool command_line_arg)
extract_dirs_from_files	ls.c	/^static void extract_dirs_from_files (char const *dirname,$/;"	p	file:	signature:(char const *dirname, bool command_line_arg)
extract_field	join.c	/^extract_field (struct line *line, char *field, size_t len)$/;"	f	file:	signature:(struct line *line, char *field, size_t len)
extract_fields	numfmt.c	/^extract_fields (char *line, int _field,$/;"	f	file:	signature:(char *line, int _field, char ** _prefix, char ** _data, char ** _suffix)
extract_regexp	csplit.c	/^extract_regexp (int argnum, bool ignore, char const *str)$/;"	f	file:	signature:(int argnum, bool ignore, char const *str)
extremities	pr.c	/^static bool extremities = true;$/;"	v	file:
f_bavail	stat.c	119;"	d	file:
f_bfree	stat.c	118;"	d	file:
f_blocks	stat.c	117;"	d	file:
f_bsize	stat.c	120;"	d	file:
f_ffree	stat.c	122;"	d	file:
f_files	stat.c	121;"	d	file:
f_fsid	stat.c	116;"	d	file:
factor	factor.c	/^factor (uintmax_t t1, uintmax_t t0, struct factors *factors)$/;"	f	file:	signature:(uintmax_t t1, uintmax_t t0, struct factors *factors)
factor	factor.c	/^static void factor (uintmax_t, uintmax_t, struct factors *);$/;"	p	file:	signature:(uintmax_t, uintmax_t, struct factors *)
factor_clz_tab	factor.c	/^const unsigned char factor_clz_tab[129] =$/;"	v
factor_insert	factor.c	540;"	d	file:
factor_insert_large	factor.c	/^factor_insert_large (struct factors *factors,$/;"	f	file:	signature:(struct factors *factors, uintmax_t p1, uintmax_t p0)
factor_insert_multiplicity	factor.c	/^factor_insert_multiplicity (struct factors *factors,$/;"	f	file:	signature:(struct factors *factors, uintmax_t prime, unsigned int m)
factor_insert_refind	factor.c	/^factor_insert_refind (struct factors *factors, uintmax_t p, unsigned int i,$/;"	f	file:	signature:(struct factors *factors, uintmax_t p, unsigned int i, unsigned int off)
factor_using_division	factor.c	/^factor_using_division (uintmax_t *t1p, uintmax_t t1, uintmax_t t0,$/;"	f	file:	signature:(uintmax_t *t1p, uintmax_t t1, uintmax_t t0, struct factors *factors)
factor_using_pollard_rho	factor.c	/^factor_using_pollard_rho (uintmax_t n, unsigned long int a,$/;"	f	file:	signature:(uintmax_t n, unsigned long int a, struct factors *factors)
factor_using_pollard_rho2	factor.c	/^factor_using_pollard_rho2 (uintmax_t n1, uintmax_t n0, unsigned long int a,$/;"	f	file:	signature:(uintmax_t n1, uintmax_t n0, unsigned long int a, struct factors *factors)
factor_using_squfof	factor.c	/^factor_using_squfof (uintmax_t n1, uintmax_t n0, struct factors *factors)$/;"	f	file:	signature:(uintmax_t n1, uintmax_t n0, struct factors *factors)
factors	factor.c	/^struct factors$/;"	s	file:
factors::e	factor.c	/^  unsigned char e[MAX_NFACTS];$/;"	m	struct:factors	file:	access:public
factors::nfactors	factor.c	/^  unsigned char nfactors;$/;"	m	struct:factors	file:	access:public
factors::p	factor.c	/^  uintmax_t     p[MAX_NFACTS];$/;"	m	struct:factors	file:	access:public
factors::plarge	factor.c	/^  uintmax_t     plarge[2]; \/* Can have a single large factor *\/$/;"	m	struct:factors	file:	access:public
failed	wc.c	/^  int failed;$/;"	m	struct:fstatus	file:	access:public
failed_opens	pr.c	/^static bool failed_opens = false;$/;"	v	file:
failed_strcoll	ls.c	/^static jmp_buf failed_strcoll;$/;"	v	file:
fastmap	ptx.c	/^  char fastmap[UCHAR_MAX + 1];$/;"	m	struct:regex_data	file:	access:public
fchmod_or_lchmod	copy.c	/^fchmod_or_lchmod (int desc, char const *name, mode_t mode)$/;"	f	file:	signature:(int desc, char const *name, mode_t mode)
fchown	copy.c	73;"	d	file:
fclose	make-prime-list.c	31;"	d	file:
fd	extent-scan.h	/^  int fd;$/;"	m	struct:extent_scan	access:public
fd	tail.c	/^  int fd;$/;"	m	struct:File_spec	file:	access:public
fdatasync	dd.c	79;"	d	file:
fe_flags	fiemap.h	/^  uint32_t fe_flags;$/;"	m	struct:fiemap_extent	access:public
fe_length	fiemap.h	/^  uint64_t fe_length;$/;"	m	struct:fiemap_extent	access:public
fe_logical	fiemap.h	/^  uint64_t fe_logical;$/;"	m	struct:fiemap_extent	access:public
fe_physical	fiemap.h	/^  uint64_t fe_physical;$/;"	m	struct:fiemap_extent	access:public
fe_reserved	fiemap.h	/^  uint32_t fe_reserved[3];$/;"	m	struct:fiemap_extent	access:public
fe_reserved64	fiemap.h	/^  uint64_t fe_reserved64[2];$/;"	m	struct:fiemap_extent	access:public
field	df.c	/^  display_field_t field;$/;"	m	struct:field_data_t	file:	access:public
field	join.c	/^    size_t field;$/;"	m	struct:outlist	file:	access:public
field	join.c	/^struct field$/;"	s	file:
field	numfmt.c	/^static long int field = 1;$/;"	v	file:
field::beg	join.c	/^    char *beg;			\/* First character in field.  *\/$/;"	m	struct:field	file:	access:public
field::len	join.c	/^    size_t len;			\/* The length of the field.  *\/$/;"	m	struct:field	file:	access:public
field_1_buffer	cut.c	/^static char *field_1_buffer;$/;"	v	file:
field_1_bufsize	cut.c	/^static size_t field_1_bufsize;$/;"	v	file:
field_data	df.c	/^static struct field_data_t field_data[] = {$/;"	v	typeref:struct:field_data_t	file:
field_data_t	df.c	/^struct field_data_t$/;"	s	file:
field_data_t::align	df.c	/^  mbs_align_t align;  \/* Alignment for this field.  *\/$/;"	m	struct:field_data_t	file:	access:public
field_data_t::arg	df.c	/^  char const *arg;$/;"	m	struct:field_data_t	file:	access:public
field_data_t::caption	df.c	/^  const char *caption;\/* NULL means to use the default header of this field.  *\/$/;"	m	struct:field_data_t	file:	access:public
field_data_t::field	df.c	/^  display_field_t field;$/;"	m	struct:field_data_t	file:	access:public
field_data_t::field_type	df.c	/^  field_type_t field_type;$/;"	m	struct:field_data_t	file:	access:public
field_data_t::used	df.c	/^  bool used;$/;"	m	struct:field_data_t	file:	access:public
field_data_t::width	df.c	/^  size_t width;       \/* Auto adjusted (up) widths used to align columns.  *\/$/;"	m	struct:field_data_t	file:	access:public
field_mode	cut.c	/^    field_mode$/;"	e	enum:operating_mode	file:
field_type	df.c	/^  field_type_t field_type;$/;"	m	struct:field_data_t	file:	access:public
field_type_t	df.c	/^} field_type_t;$/;"	t	typeref:enum:__anon52	file:
field_values_t	df.c	/^struct field_values_t$/;"	s	file:
field_values_t::available	df.c	/^  uintmax_t available;$/;"	m	struct:field_values_t	file:	access:public
field_values_t::available_to_root	df.c	/^  uintmax_t available_to_root;$/;"	m	struct:field_values_t	file:	access:public
field_values_t::input_units	df.c	/^  uintmax_t input_units;$/;"	m	struct:field_values_t	file:	access:public
field_values_t::negate_available	df.c	/^  bool negate_available;$/;"	m	struct:field_values_t	file:	access:public
field_values_t::negate_used	df.c	/^  bool negate_used;$/;"	m	struct:field_values_t	file:	access:public
field_values_t::output_units	df.c	/^  uintmax_t output_units;$/;"	m	struct:field_values_t	file:	access:public
field_values_t::total	df.c	/^  uintmax_t total;$/;"	m	struct:field_values_t	file:	access:public
field_values_t::used	df.c	/^  uintmax_t used;$/;"	m	struct:field_values_t	file:	access:public
field_width	od.c	/^    int field_width; \/* Minimum width of a field, excluding leading space.  *\/$/;"	m	struct:tspec	file:	access:public
fields	join.c	/^    struct field *fields;$/;"	m	struct:line	typeref:struct:line::field	file:	access:public
fiemap	fiemap.h	/^struct fiemap$/;"	s
fiemap::fm_extent_count	fiemap.h	/^  uint32_t fm_extent_count;$/;"	m	struct:fiemap	access:public
fiemap::fm_extents	fiemap.h	/^  struct fiemap_extent fm_extents[0];$/;"	m	struct:fiemap	typeref:struct:fiemap::fiemap_extent	access:public
fiemap::fm_flags	fiemap.h	/^  uint32_t fm_flags;$/;"	m	struct:fiemap	access:public
fiemap::fm_length	fiemap.h	/^  uint64_t fm_length;$/;"	m	struct:fiemap	access:public
fiemap::fm_mapped_extents	fiemap.h	/^  uint32_t fm_mapped_extents;$/;"	m	struct:fiemap	access:public
fiemap::fm_reserved	fiemap.h	/^  uint32_t fm_reserved;$/;"	m	struct:fiemap	access:public
fiemap::fm_start	fiemap.h	/^  uint64_t fm_start;$/;"	m	struct:fiemap	access:public
fiemap_extent	fiemap.h	/^struct fiemap_extent$/;"	s
fiemap_extent::fe_flags	fiemap.h	/^  uint32_t fe_flags;$/;"	m	struct:fiemap_extent	access:public
fiemap_extent::fe_length	fiemap.h	/^  uint64_t fe_length;$/;"	m	struct:fiemap_extent	access:public
fiemap_extent::fe_logical	fiemap.h	/^  uint64_t fe_logical;$/;"	m	struct:fiemap_extent	access:public
fiemap_extent::fe_physical	fiemap.h	/^  uint64_t fe_physical;$/;"	m	struct:fiemap_extent	access:public
fiemap_extent::fe_reserved	fiemap.h	/^  uint32_t fe_reserved[3];$/;"	m	struct:fiemap_extent	access:public
fiemap_extent::fe_reserved64	fiemap.h	/^  uint64_t fe_reserved64[2];$/;"	m	struct:fiemap_extent	access:public
fifo	ls.c	/^    fifo,$/;"	e	enum:filetype	file:
file	join.c	/^    int file;$/;"	m	struct:outlist	file:	access:public
file_failure	ls.c	/^file_failure (bool serious, char const *message, char const *file)$/;"	f	file:	signature:(bool serious, char const *message, char const *file)
file_has_acl_cache	ls.c	/^file_has_acl_cache (char const *file, struct fileinfo *f)$/;"	f	file:	signature:(char const *file, struct fileinfo *f)
file_human_output_opts	ls.c	/^static int file_human_output_opts;$/;"	v	file:
file_ignored	ls.c	/^file_ignored (char const *name)$/;"	f	file:	signature:(char const *name)
file_ignored	ls.c	/^static bool file_ignored (char const *name);$/;"	p	file:	signature:(char const *name)
file_line_count	ptx.c	/^static int *file_line_count;	\/* array of 'total_line_count' values at end *\/$/;"	v	file:
file_lines	tail.c	/^file_lines (const char *pretty_filename, int fd, uintmax_t n_lines,$/;"	f	file:	signature:(const char *pretty_filename, int fd, uintmax_t n_lines, off_t start_pos, off_t end_pos, uintmax_t *read_pos)
file_list	expand.c	/^static char **file_list;$/;"	v	file:
file_list	od.c	/^static char const *const *file_list;$/;"	v	file:
file_list	unexpand.c	/^static char **file_list;$/;"	v	file:
file_name	pwd.c	/^struct file_name$/;"	s	file:
file_name::buf	pwd.c	/^  char *buf;$/;"	m	struct:file_name	file:	access:public
file_name::n_alloc	pwd.c	/^  size_t n_alloc;$/;"	m	struct:file_name	file:	access:public
file_name::start	pwd.c	/^  char *start;$/;"	m	struct:file_name	file:	access:public
file_name_free	pwd.c	/^file_name_free (struct file_name *p)$/;"	f	file:	signature:(struct file_name *p)
file_name_init	pwd.c	/^file_name_init (void)$/;"	f	file:	signature:(void)
file_name_prepend	pwd.c	/^file_name_prepend (struct file_name *p, char const *s, size_t s_len)$/;"	f	file:	signature:(struct file_name *p, char const *s, size_t s_len)
file_output_block_size	ls.c	/^static uintmax_t file_output_block_size = 1;$/;"	v	file:
file_size_width	ls.c	/^static int file_size_width;$/;"	v	file:
file_systems_processed	df.c	/^static bool file_systems_processed;$/;"	v	file:
file_text	pr.c	/^static char const *file_text;$/;"	v	file:
file_to_remove	tac.c	/^static const char *file_to_remove;$/;"	v	file:
file_type	ls.c	/^    file_type,	\/*     --indicator-style=file-type *\/$/;"	e	enum:indicator_style	file:
fileinfo	ls.c	/^struct fileinfo$/;"	s	file:
fileinfo::acl_type	ls.c	/^    enum acl_type acl_type;$/;"	m	struct:fileinfo	typeref:enum:fileinfo::acl_type	file:	access:public
fileinfo::filetype	ls.c	/^    enum filetype filetype;$/;"	m	struct:fileinfo	typeref:enum:fileinfo::filetype	file:	access:public
fileinfo::has_capability	ls.c	/^    bool has_capability;$/;"	m	struct:fileinfo	file:	access:public
fileinfo::linkmode	ls.c	/^    mode_t linkmode;$/;"	m	struct:fileinfo	file:	access:public
fileinfo::linkname	ls.c	/^    char *linkname;$/;"	m	struct:fileinfo	file:	access:public
fileinfo::linkok	ls.c	/^    bool linkok;$/;"	m	struct:fileinfo	file:	access:public
fileinfo::name	ls.c	/^    char *name;$/;"	m	struct:fileinfo	file:	access:public
fileinfo::scontext	ls.c	/^    security_context_t scontext;$/;"	m	struct:fileinfo	file:	access:public
fileinfo::stat	ls.c	/^    struct stat stat;$/;"	m	struct:fileinfo	typeref:struct:fileinfo::stat	file:	access:public
fileinfo::stat_ok	ls.c	/^    bool stat_ok;$/;"	m	struct:fileinfo	file:	access:public
filename_quoting_options	ls.c	/^static struct quoting_options *filename_quoting_options;$/;"	v	typeref:struct:quoting_options	file:
filename_space	csplit.c	/^static char *volatile filename_space = NULL;$/;"	v	file:
filename_unescape	md5sum.c	/^filename_unescape (char *s, size_t s_len)$/;"	f	file:	signature:(char *s, size_t s_len)
fileno_to_name	libstdbuf.c	/^fileno_to_name (const int fd)$/;"	f	file:	signature:(const int fd)
files_created	csplit.c	/^static unsigned int volatile files_created = 0;$/;"	v	file:
files_ready_to_read	pr.c	/^static int files_ready_to_read = 0;$/;"	v	file:
filetype	ls.c	/^    enum filetype filetype;$/;"	m	struct:fileinfo	typeref:enum:fileinfo::filetype	file:	access:public
filetype	ls.c	/^enum filetype$/;"	g	file:
filetype_letter	ls.c	/^static char const filetype_letter[] = "?pcdb-lswd";$/;"	v	file:
fill_mount_table	du.c	/^fill_mount_table (void)$/;"	f	file:	signature:(void)
fill_r	cksum.c	/^fill_r (void)$/;"	f	file:	signature:(void)
fillbuf	sort.c	/^fillbuf (struct buffer *buf, FILE *fp, char const *file)$/;"	f	file:	signature:(struct buffer *buf, FILE *fp, char const *file)
fillpattern	shred.c	/^fillpattern (int type, unsigned char *r, size_t size)$/;"	f	file:	signature:(int type, unsigned char *r, size_t size)
filter_command	split.c	/^static char const *filter_command;$/;"	v	file:
filter_mount_list	df.c	/^filter_mount_list (void)$/;"	f	file:	signature:(void)
filter_pid	split.c	/^static int filter_pid;$/;"	v	file:
final	fmt.c	/^    unsigned int final:1;	\/* end of sentence *\/$/;"	m	struct:Word	file:	access:public
final_op_was_seek	dd.c	/^static bool final_op_was_seek;$/;"	v	file:
find_bind_mount	stat.c	/^find_bind_mount (char const * name)$/;"	f	file:	signature:(char const * name)
find_bol	tac-pipe.c	/^find_bol (const Buf *x,$/;"	f	file:	signature:(const Buf *x, const Line_ptr *last_bol, Line_ptr *new_bol, char eol_byte)
find_bracketed_repeat	tr.c	/^find_bracketed_repeat (const struct E_string *es, size_t start_idx,$/;"	f	file:	signature:(const struct E_string *es, size_t start_idx, unsigned char *char_to_repeat, count *repeat_count, size_t *closing_bracket_idx)
find_closing_delim	tr.c	/^find_closing_delim (const struct E_string *es, size_t start_idx,$/;"	f	file:	signature:(const struct E_string *es, size_t start_idx, char pre_bracket_char, size_t *result_idx)
find_dir_entry	pwd.c	/^find_dir_entry (struct stat *dot_sb, struct file_name *file_name,$/;"	f	file:	signature:(struct stat *dot_sb, struct file_name *file_name, size_t parent_height)
find_field	uniq.c	/^find_field (struct linebuffer const *line)$/;"	f	file:	signature:(struct linebuffer const *line)
find_int	test.c	/^find_int (char const *string)$/;"	f	file:	signature:(char const *string)
find_line	csplit.c	/^find_line (uintmax_t linenum)$/;"	f	file:	signature:(uintmax_t linenum)
find_mount_point	find-mount-point.c	/^find_mount_point (char const *file, struct stat const *file_stat)$/;"	f	signature:(char const *file, struct stat const *file_stat)
find_mount_point	find-mount-point.h	/^extern char *find_mount_point (char const *, struct stat const *);$/;"	p	signature:(char const *, struct stat const *)
find_occurs_in_text	ptx.c	/^find_occurs_in_text (void)$/;"	f	file:	signature:(void)
find_unit_order	sort.c	/^find_unit_order (char const *number)$/;"	f	file:	signature:(char const *number)
first	ptx.c	541;"	d	file:
first	ptx.c	571;"	d	file:
first	ptx.c	584;"	d	file:
first	ptx.c	590;"	d	file:
first_available	csplit.c	/^  uintmax_t first_available;	\/* First line that can be retrieved. *\/$/;"	m	struct:buffer_record	file:	access:public
first_char	tr.c	/^            unsigned char first_char;$/;"	m	struct:List_element::__anon3::__anon4	file:	access:public
first_free_tab	expand.c	/^static size_t first_free_tab;$/;"	v	file:
first_free_tab	unexpand.c	/^static size_t first_free_tab;$/;"	v	file:
first_indent	fmt.c	/^static int first_indent;$/;"	v	file:
first_last_page	pr.c	/^first_last_page (int oi, char c, char const *pages)$/;"	f	file:	signature:(int oi, char c, char const *pages)
first_page_number	pr.c	/^static uintmax_t first_page_number = 0;$/;"	v	file:
fix_output_parameters	ptx.c	/^fix_output_parameters (void)$/;"	f	file:	signature:(void)
flag_dump_strings	od.c	/^static bool flag_dump_strings;$/;"	v	file:
flag_prove_primality	factor.c	/^static bool flag_prove_primality = true;$/;"	v	file:
flag_pseudo_start	od.c	/^static bool flag_pseudo_start;$/;"	v	file:
flags	dd.c	/^static struct symbol_value const flags[] =$/;"	v	file:
flags	stty.c	/^    char flags;			\/* Setting and display options.  *\/$/;"	m	struct:mode_info	file:	access:public
flush_paragraph	fmt.c	/^flush_paragraph (void)$/;"	f	file:	signature:(void)
flush_paragraph	fmt.c	/^static void flush_paragraph (void);$/;"	p	file:	signature:(void)
fm_extent_count	fiemap.h	/^  uint32_t fm_extent_count;$/;"	m	struct:fiemap	access:public
fm_extents	fiemap.h	/^  struct fiemap_extent fm_extents[0];$/;"	m	struct:fiemap	typeref:struct:fiemap::fiemap_extent	access:public
fm_flags	extent-scan.h	/^  uint32_t fm_flags;$/;"	m	struct:extent_scan	access:public
fm_flags	fiemap.h	/^  uint32_t fm_flags;$/;"	m	struct:fiemap	access:public
fm_length	fiemap.h	/^  uint64_t fm_length;$/;"	m	struct:fiemap	access:public
fm_mapped_extents	fiemap.h	/^  uint32_t fm_mapped_extents;$/;"	m	struct:fiemap	access:public
fm_reserved	fiemap.h	/^  uint32_t fm_reserved;$/;"	m	struct:fiemap	access:public
fm_start	fiemap.h	/^  uint64_t fm_start;$/;"	m	struct:fiemap	access:public
fmt	fmt.c	/^fmt (FILE *f)$/;"	f	file:	signature:(FILE *f)
fmt	fmt.c	/^static void fmt (FILE *f);$/;"	p	file:	signature:(FILE *f)
fmt	od.c	/^    enum output_format fmt;$/;"	m	struct:tspec	typeref:enum:tspec::output_format	file:	access:public
fmt_paragraph	fmt.c	/^fmt_paragraph (void)$/;"	f	file:	signature:(void)
fmt_paragraph	fmt.c	/^static void fmt_paragraph (void);$/;"	p	file:	signature:(void)
fmt_string	od.c	/^    char fmt_string[FMT_BYTES_ALLOCATED]; \/* Of the style "%*d".  *\/$/;"	m	struct:tspec	file:	access:public
fold_file	fold.c	/^fold_file (char const *filename, size_t width)$/;"	f	file:	signature:(char const *filename, size_t width)
fold_toupper	sort.c	/^static char fold_toupper[UCHAR_LIM];$/;"	v	file:
folded_chars	ptx.c	/^static unsigned char folded_chars[CHAR_SET_SIZE];$/;"	v	file:
follow_links	stat.c	/^static bool follow_links;$/;"	v	file:
follow_mode	tail.c	/^static enum Follow_mode follow_mode = Follow_descriptor;$/;"	v	typeref:enum:Follow_mode	file:
follow_mode_map	tail.c	/^static enum Follow_mode const follow_mode_map[] =$/;"	v	file:
follow_mode_string	tail.c	/^static char const *const follow_mode_string[] =$/;"	v	file:
footer_del	nl.c	/^static char *footer_del = NULL;$/;"	v	file:
footer_del_len	nl.c	/^static size_t footer_del_len;$/;"	v	file:
footer_fastmap	nl.c	/^static char footer_fastmap[UCHAR_MAX + 1];$/;"	v	file:
footer_regex	nl.c	/^static struct re_pattern_buffer footer_regex;$/;"	v	typeref:struct:re_pattern_buffer	file:
footer_type	nl.c	/^static char const *footer_type = "n";$/;"	v	file:
force	shred.c	/^  bool force;		\/* -f flag: chmod files if necessary *\/$/;"	m	struct:Options	file:	access:public
force_silent	chmod.c	/^static bool force_silent;$/;"	v	file:
force_silent	chown-core.h	/^  bool force_silent;$/;"	m	struct:Chown_option	access:public
foreground	timeout.c	/^static bool foreground;      \/* whether to use another program group.  *\/$/;"	v	file:
forever	tail.c	/^static bool forever;$/;"	v	file:
forget_all	cp-hash.c	/^forget_all (void)$/;"	f	signature:(void)
forget_all	cp-hash.h	/^void forget_all (void);$/;"	p	signature:(void)
forget_created	cp-hash.c	/^forget_created (ino_t ino, dev_t dev)$/;"	f	signature:(ino_t ino, dev_t dev)
forget_created	cp-hash.h	/^void forget_created (ino_t ino, dev_t dev);$/;"	p	signature:(ino_t ino, dev_t dev)
format	ls.c	/^enum format$/;"	g	file:
format	ls.c	/^static enum format format;$/;"	v	typeref:enum:format	file:
format_address	od.c	/^static void (*format_address) (uintmax_t, char);$/;"	v	file:
format_address_label	od.c	/^format_address_label (uintmax_t address, char c)$/;"	f	file:	signature:(uintmax_t address, char c)
format_address_none	od.c	/^format_address_none (uintmax_t address ATTRIBUTE_UNUSED,$/;"	f	file:	signature:(uintmax_t address ATTRIBUTE_UNUSED, char c ATTRIBUTE_UNUSED)
format_address_paren	od.c	/^format_address_paren (uintmax_t address, char c)$/;"	f	file:	signature:(uintmax_t address, char c)
format_address_std	od.c	/^format_address_std (uintmax_t address, char c)$/;"	f	file:	signature:(uintmax_t address, char c)
format_args	ls.c	/^static char const *const format_args[] =$/;"	v	file:
format_args	ptx.c	/^static char const* const format_args[] =$/;"	v	file:
format_group	ls.c	/^format_group (gid_t g, int width, bool stat_ok)$/;"	f	file:	signature:(gid_t g, int width, bool stat_ok)
format_group_width	ls.c	/^format_group_width (gid_t g)$/;"	f	file:	signature:(gid_t g)
format_group_width	ls.c	/^static int format_group_width (gid_t g);$/;"	p	file:	signature:(gid_t g)
format_inode	ls.c	/^format_inode (char *buf, size_t buflen, const struct fileinfo *f)$/;"	f	file:	signature:(char *buf, size_t buflen, const struct fileinfo *f)
format_needs_stat	ls.c	/^static bool format_needs_stat;$/;"	v	file:
format_needs_type	ls.c	/^static bool format_needs_type;$/;"	v	file:
format_str	numfmt.c	/^static const char *format_str = NULL;$/;"	v	file:
format_str_prefix	numfmt.c	/^static char *format_str_prefix = NULL;$/;"	v	file:
format_str_suffix	numfmt.c	/^static char *format_str_suffix = NULL;$/;"	v	file:
format_types	ls.c	/^static enum format const format_types[] =$/;"	v	file:
format_user	ls.c	/^format_user (uid_t u, int width, bool stat_ok)$/;"	f	file:	signature:(uid_t u, int width, bool stat_ok)
format_user_or_group	ls.c	/^format_user_or_group (char const *name, unsigned long int id, int width)$/;"	f	file:	signature:(char const *name, unsigned long int id, int width)
format_user_or_group_width	ls.c	/^format_user_or_group_width (char const *name, unsigned long int id)$/;"	f	file:	signature:(char const *name, unsigned long int id)
format_user_width	ls.c	/^format_user_width (uid_t u)$/;"	f	file:	signature:(uid_t u)
format_user_width	ls.c	/^static int format_user_width (uid_t u);$/;"	p	file:	signature:(uid_t u)
format_vals	ptx.c	/^static enum Format const format_vals[] =$/;"	v	file:
fp	pr.c	/^    FILE *fp;			\/* Input stream for this column. *\/$/;"	m	struct:COLUMN	file:	access:public
fp_to_close	tac.c	/^static FILE *fp_to_close;$/;"	v	file:
fp_type_size	od.c	/^static enum size_spec fp_type_size[MAX_FP_TYPE_SIZE + 1];$/;"	v	typeref:enum:size_spec	file:
free_buffer	csplit.c	/^free_buffer (struct buffer_record *buf)$/;"	f	file:	signature:(struct buffer_record *buf)
free_ent	ls.c	/^free_ent (struct fileinfo *f)$/;"	f	file:	signature:(struct fileinfo *f)
free_pending_ent	ls.c	/^free_pending_ent (struct pending *p)$/;"	f	file:	signature:(struct pending *p)
free_spareline	join.c	/^free_spareline (void)$/;"	f	file:	signature:(void)
freeline	join.c	/^freeline (struct line *line)$/;"	f	file:	signature:(struct line *line)
freev	expr.c	/^freev (VALUE *v)$/;"	f	file:	signature:(VALUE *v)
fremote	tail.c	/^fremote (int fd, const char *name)$/;"	f	file:	signature:(int fd, const char *name)
fremote	tail.c	926;"	d	file:
from_start	tail.c	/^static bool from_start;$/;"	v	file:
from_unit_size	numfmt.c	/^static uintmax_t from_unit_size = 1;$/;"	v	file:
fs_exclude_list	df.c	/^static struct fs_type_list *fs_exclude_list;$/;"	v	typeref:struct:fs_type_list	file:
fs_name	df.c	/^  char *fs_name;$/;"	m	struct:fs_type_list	file:	access:public
fs_next	df.c	/^  struct fs_type_list *fs_next;$/;"	m	struct:fs_type_list	typeref:struct:fs_type_list::fs_type_list	file:	access:public
fs_normalize_perl_subst	local.mk	/^fs_normalize_perl_subst =			\\$/;"	m
fs_select_list	df.c	/^static struct fs_type_list *fs_select_list;$/;"	v	typeref:struct:fs_type_list	file:
fs_type_list	df.c	/^struct fs_type_list$/;"	s	file:
fs_type_list::fs_name	df.c	/^  char *fs_name;$/;"	m	struct:fs_type_list	file:	access:public
fs_type_list::fs_next	df.c	/^  struct fs_type_list *fs_next;$/;"	m	struct:fs_type_list	typeref:struct:fs_type_list::fs_type_list	file:	access:public
fstatus	wc.c	/^struct fstatus$/;"	s	file:
fstatus::failed	wc.c	/^  int failed;$/;"	m	struct:fstatus	file:	access:public
fstatus::st	wc.c	/^  struct stat st;$/;"	m	struct:fstatus	typeref:struct:fstatus::stat	file:	access:public
fts_skip_tree	remove.c	/^fts_skip_tree (FTS *fts, FTSENT *ent)$/;"	f	file:	signature:(FTS *fts, FTSENT *ent)
full_iso_time_style	du.c	/^    full_iso_time_style,       \/* --time-style=full-iso *\/$/;"	e	enum:time_style	file:
full_iso_time_style	ls.c	/^    full_iso_time_style,	\/* --time-style=full-iso *\/$/;"	e	enum:time_style	file:
full_page_printed	pr.c	/^    bool full_page_printed;	\/* True means printed without a FF found. *\/$/;"	m	struct:COLUMN	file:	access:public
g_names	join.c	/^static char *g_names[2];$/;"	v	file:
gap_size	ptx.c	/^static int gap_size = 3;	\/* number of spaces between output fields *\/$/;"	v	file:
gcd	system.h	/^gcd (size_t u, size_t v)$/;"	f	signature:(size_t u, size_t v)
gcd2_odd	factor.c	/^gcd2_odd (uintmax_t *r1, uintmax_t a1, uintmax_t a0, uintmax_t b1, uintmax_t b0)$/;"	f	file:	signature:(uintmax_t *r1, uintmax_t a1, uintmax_t a0, uintmax_t b1, uintmax_t b0)
gcd_odd	factor.c	/^gcd_odd (uintmax_t a, uintmax_t b)$/;"	f	file:	signature:(uintmax_t a, uintmax_t b)
ge2	factor.c	326;"	d	file:
general_numcompare	sort.c	/^general_numcompare (char const *sa, char const *sb)$/;"	f	file:	signature:(char const *sa, char const *sb)
general_numeric	sort.c	/^  bool general_numeric;		\/* Flag for general, numeric comparison.$/;"	m	struct:keyfield	file:	access:public
generate_all_output	ptx.c	/^generate_all_output (void)$/;"	f	file:	signature:(void)
genpattern	shred.c	/^genpattern (int *dest, size_t num, struct randint_source *s)$/;"	f	file:	signature:(int *dest, size_t num, struct randint_source *s)
get_all_entries	df.c	/^get_all_entries (void)$/;"	f	file:	signature:(void)
get_default_format	seq.c	/^get_default_format (operand first, operand step, operand last)$/;"	f	file:	signature:(operand first, operand step, operand last)
get_dev	df.c	/^get_dev (char const *disk, char const *mount_point,$/;"	f	file:	signature:(char const *disk, char const *mount_point, char const *stat_file, char const *fstype, bool me_dummy, bool me_remote, const struct fs_usage *force_fsu, bool process_all)
get_disk	df.c	/^get_disk (char const *disk)$/;"	f	file:	signature:(char const *disk)
get_entry	df.c	/^get_entry (char const *name, struct stat const *statp)$/;"	f	file:	signature:(char const *name, struct stat const *statp)
get_field_list	df.c	/^get_field_list (void)$/;"	f	file:	signature:(void)
get_field_values	df.c	/^get_field_values (struct field_values_t *bv,$/;"	f	file:	signature:(struct field_values_t *bv, struct field_values_t *iv, const struct fs_usage *fsu)
get_first_line_in_buffer	csplit.c	/^get_first_line_in_buffer (void)$/;"	f	file:	signature:(void)
get_format_flags	csplit.c	/^get_format_flags (char const *format, int *flags_ptr)$/;"	f	file:	signature:(char const *format, int *flags_ptr)
get_funky_string	ls.c	/^get_funky_string (char **dest, const char **src, bool equals_end,$/;"	f	file:	signature:(char **dest, const char **src, bool equals_end, size_t *output_count)
get_header	df.c	/^get_header (void)$/;"	f	file:	signature:(void)
get_ids	install.c	/^get_ids (void)$/;"	f	file:	signature:(void)
get_input_fstatus	wc.c	/^get_input_fstatus (int nfiles, char *const *file)$/;"	f	file:	signature:(int nfiles, char *const *file)
get_lcm	od.c	/^get_lcm (void)$/;"	f	file:	signature:(void)
get_line	fmt.c	/^get_line (FILE *f, int c)$/;"	f	file:	signature:(FILE *f, int c)
get_line	fmt.c	/^static int get_line (FILE *f, int c);$/;"	p	file:	signature:(FILE *f, int c)
get_line	join.c	/^get_line (FILE *fp, struct line **linep, int which)$/;"	f	file:	signature:(FILE *fp, struct line **linep, int which)
get_link_name	ls.c	/^get_link_name (char const *filename, struct fileinfo *f, bool command_line_arg)$/;"	f	file:	signature:(char const *filename, struct fileinfo *f, bool command_line_arg)
get_link_name	ls.c	/^static void get_link_name (char const *filename, struct fileinfo *f,$/;"	p	file:	signature:(char const *filename, struct fileinfo *f, bool command_line_arg)
get_mtime	test.c	/^get_mtime (char const *filename, struct timespec *mtime)$/;"	f	file:	signature:(char const *filename, struct timespec *mtime)
get_new_buffer	csplit.c	/^get_new_buffer (size_t min_size)$/;"	f	file:	signature:(size_t min_size)
get_next	tr.c	/^get_next (struct Spec_list *s, enum Upper_Lower_class *class)$/;"	f	file:	signature:(struct Spec_list *s, enum Upper_Lower_class *class)
get_paragraph	fmt.c	/^get_paragraph (FILE *f)$/;"	f	file:	signature:(FILE *f)
get_paragraph	fmt.c	/^static bool get_paragraph (FILE *f);$/;"	p	file:	signature:(FILE *f)
get_point	df.c	/^get_point (const char *point, const struct stat *statp)$/;"	f	file:	signature:(const char *point, const struct stat *statp)
get_prefix	fmt.c	/^get_prefix (FILE *f)$/;"	f	file:	signature:(FILE *f)
get_prefix	fmt.c	/^static int get_prefix (FILE *f);$/;"	p	file:	signature:(FILE *f)
get_reldate	touch.c	/^get_reldate (struct timespec *result,$/;"	f	file:	signature:(struct timespec *result, char const *flex_date, struct timespec const *now)
get_s1_spec_stats	tr.c	/^get_s1_spec_stats (struct Spec_list *s1)$/;"	f	file:	signature:(struct Spec_list *s1)
get_s2_spec_stats	tr.c	/^get_s2_spec_stats (struct Spec_list *s2, count len_s1)$/;"	f	file:	signature:(struct Spec_list *s2, count len_s1)
get_space	fmt.c	/^get_space (FILE *f, int c)$/;"	f	file:	signature:(FILE *f, int c)
get_space	fmt.c	/^static int get_space (FILE *f, int c);$/;"	p	file:	signature:(FILE *f, int c)
get_spec_stats	tr.c	/^get_spec_stats (struct Spec_list *s)$/;"	f	file:	signature:(struct Spec_list *s)
get_type_indicator	ls.c	/^get_type_indicator (bool stat_ok, mode_t mode, enum filetype type)$/;"	f	file:	signature:(bool stat_ok, mode_t mode, enum filetype type)
get_win_size	stty.c	/^get_win_size (int fd, struct winsize *win)$/;"	f	file:	signature:(int fd, struct winsize *win)
geteuid	system.h	/^uid_t geteuid ();$/;"	p	signature:()
getfilecon_cache	ls.c	/^getfilecon_cache (char const *file, struct fileinfo *f, bool deref)$/;"	f	file:	signature:(char const *file, struct fileinfo *f, bool deref)
getgrent	system.h	232;"	d
getgrgid	system.h	/^struct group *getgrgid ();$/;"	p	signature:()
getgrgid	system.h	226;"	d
getgrnam	system.h	229;"	d
getlogin	system.h	/^char *getlogin ();$/;"	p	signature:()
getmonth	sort.c	/^getmonth (char const *month, char **ea)$/;"	f	file:	signature:(char const *month, char **ea)
getoptarg	pr.c	/^getoptarg (char *arg, char switch_char, char *character, int *number)$/;"	f	file:	signature:(char *arg, char switch_char, char *character, int *number)
getoptarg	pr.c	/^static void getoptarg (char *arg, char switch_char, char *character,$/;"	p	file:	signature:(char *arg, char switch_char, char *character, int *number)
getpwuid	system.h	/^struct passwd *getpwuid ();$/;"	p	signature:()
getrlimit	sort.c	59;"	d	file:
getseq	join.c	/^getseq (FILE *fp, struct seq *seq, int whichfile)$/;"	f	file:	signature:(FILE *fp, struct seq *seq, int whichfile)
getsize	expr.c	/^getsize (mpz_t i)$/;"	f	file:	signature:(mpz_t i)
getuid	system.h	/^uid_t getuid ();$/;"	p	signature:()
gid_to_name	chown-core.c	/^gid_to_name (gid_t gid)$/;"	f	signature:(gid_t gid)
gid_to_name	chown-core.h	/^gid_to_name (gid_t);$/;"	p	signature:(gid_t)
gidtostr	group-list.c	100;"	d	file:
gidtostr	id.c	286;"	d	file:
gidtostr_ptr	group-list.c	/^gidtostr_ptr (gid_t const *gid)$/;"	f	file:	signature:(gid_t const *gid)
gidtostr_ptr	id.c	/^gidtostr_ptr (gid_t const *gid)$/;"	f	file:	signature:(gid_t const *gid)
global_argv	csplit.c	/^static char **global_argv;$/;"	v	file:
gnu_extensions	ptx.c	/^static bool gnu_extensions = true;	\/* trigger all GNU extensions *\/$/;"	v	file:
goal_width	fmt.c	/^static int goal_width;$/;"	v	file:
gobble_file	ls.c	/^gobble_file (char const *name, enum filetype type, ino_t inode,$/;"	f	file:	signature:(char const *name, enum filetype type, ino_t inode, bool command_line_arg, char const *dirname)
gobble_file	ls.c	/^static uintmax_t gobble_file (char const *name, enum filetype type,$/;"	p	file:	signature:(char const *name, enum filetype type, ino_t inode, bool command_line_arg, char const *dirname)
grand_fsu	df.c	/^static struct fs_usage grand_fsu;$/;"	v	typeref:struct:fs_usage	file:
group_id	install.c	/^static gid_t group_id;$/;"	v	file:
group_name	chown-core.h	/^  char *group_name;$/;"	m	struct:Chown_option	access:public
group_name	install.c	/^static char *group_name;$/;"	v	file:
group_width	ls.c	/^static int group_width;$/;"	v	file:
grouping	numfmt.c	/^static int grouping = 0;$/;"	v	file:
gt2	factor.c	329;"	d	file:
guess_shell_syntax	dircolors.c	/^guess_shell_syntax (void)$/;"	f	file:	signature:(void)
half_line_width	ptx.c	/^static int half_line_width;	\/* half of line width, reference excluded *\/$/;"	v	file:
handle_line_error	csplit.c	/^handle_line_error (const struct control *p, uintmax_t repetition)$/;"	f	file:	signature:(const struct control *p, uintmax_t repetition)
hard_LC_COLLATE	comm.c	/^static bool hard_LC_COLLATE;$/;"	v	file:
hard_LC_COLLATE	join.c	/^static bool hard_LC_COLLATE;$/;"	v	file:
hard_LC_COLLATE	sort.c	/^static bool hard_LC_COLLATE;$/;"	v	file:
hard_LC_COLLATE	uniq.c	/^static bool hard_LC_COLLATE;$/;"	v	file:
hard_LC_TIME	sort.c	/^static bool hard_LC_TIME;$/;"	v	file:
hard_dir_link	ln.c	/^static bool hard_dir_link;$/;"	v	file:
hard_link	copy.h	/^  bool hard_link;$/;"	m	struct:cp_options	access:public
has_capability	ls.c	/^    bool has_capability;$/;"	m	struct:fileinfo	file:	access:public
has_capability	ls.c	/^has_capability (char const *name ATTRIBUTE_UNUSED)$/;"	f	file:	signature:(char const *name ATTRIBUTE_UNUSED)
has_capability	ls.c	/^has_capability (char const *name)$/;"	f	file:	signature:(char const *name)
has_capability_cache	ls.c	/^has_capability_cache (char const *file, struct fileinfo *f)$/;"	f	file:	signature:(char const *file, struct fileinfo *f)
has_char_class	tr.c	/^    bool has_char_class;$/;"	m	struct:Spec_list	file:	access:public
has_equiv_class	tr.c	/^    bool has_equiv_class;$/;"	m	struct:Spec_list	file:	access:public
has_restricted_char_class	tr.c	/^    bool has_restricted_char_class;$/;"	m	struct:Spec_list	file:	access:public
has_uuid_suffix	df.c	/^has_uuid_suffix (char const *s)$/;"	f	file:	signature:(char const *s)
hash_all	du.c	/^static bool hash_all;$/;"	v	file:
hash_compare_ints	cut.c	/^hash_compare_ints (void const *x, void const *y)$/;"	f	file:	signature:(void const *x, void const *y)
hash_init	cp-hash.c	/^hash_init (void)$/;"	f	signature:(void)
hash_init	cp-hash.h	/^void hash_init (void);$/;"	p	signature:(void)
hash_ins	du.c	/^hash_ins (struct di_set *di_set, ino_t ino, dev_t dev)$/;"	f	file:	signature:(struct di_set *di_set, ino_t ino, dev_t dev)
hash_int	cut.c	/^hash_int (const void *x, size_t tablesize)$/;"	f	file:	signature:(const void *x, size_t tablesize)
have_read_eof	csplit.c	/^static bool have_read_eof = false;$/;"	v	file:
have_read_stdin	cksum.c	/^static bool have_read_stdin;$/;"	v	file:
have_read_stdin	cut.c	/^static bool have_read_stdin;$/;"	v	file:
have_read_stdin	expand.c	/^static bool have_read_stdin;$/;"	v	file:
have_read_stdin	fold.c	/^static bool have_read_stdin;$/;"	v	file:
have_read_stdin	head.c	/^static bool have_read_stdin;$/;"	v	file:
have_read_stdin	md5sum.c	/^static bool have_read_stdin;$/;"	v	file:
have_read_stdin	nl.c	/^static bool have_read_stdin;$/;"	v	file:
have_read_stdin	od.c	/^static bool have_read_stdin;$/;"	v	file:
have_read_stdin	paste.c	/^static bool have_read_stdin;$/;"	v	file:
have_read_stdin	pr.c	/^static bool have_read_stdin = false;$/;"	v	file:
have_read_stdin	sort.c	/^static bool have_read_stdin;$/;"	v	file:
have_read_stdin	sum.c	/^static bool have_read_stdin;$/;"	v	file:
have_read_stdin	tac.c	/^static bool have_read_stdin = false;$/;"	v	file:
have_read_stdin	tail.c	/^static bool have_read_stdin;$/;"	v	file:
have_read_stdin	unexpand.c	/^static bool have_read_stdin;$/;"	v	file:
have_read_stdin	wc.c	/^static bool have_read_stdin;$/;"	v	file:
have_same_content	install.c	/^have_same_content (int a_fd, int b_fd)$/;"	f	file:	signature:(int a_fd, int b_fd)
head	csplit.c	/^static struct buffer_record *head = NULL;$/;"	v	typeref:struct:buffer_record	file:
head	head.c	/^head (const char *filename, int fd, uintmax_t n_units, bool count_lines,$/;"	f	file:	signature:(const char *filename, int fd, uintmax_t n_units, bool count_lines, bool elide_from_end)
head	ptx.c	/^static BLOCK head;		\/* head field *\/$/;"	v	file:
head	tr.c	/^    struct List_element *head;$/;"	m	struct:Spec_list	typeref:struct:Spec_list::List_element	file:	access:public
head	tsort.c	/^static struct item *head = NULL;$/;"	v	typeref:struct:item	file:
head_bytes	head.c	/^head_bytes (const char *filename, int fd, uintmax_t bytes_to_write)$/;"	f	file:	signature:(const char *filename, int fd, uintmax_t bytes_to_write)
head_file	head.c	/^head_file (const char *filename, uintmax_t n_units, bool count_lines,$/;"	f	file:	signature:(const char *filename, uintmax_t n_units, bool count_lines, bool elide_from_end)
head_lines	head.c	/^head_lines (const char *filename, int fd, uintmax_t lines_to_write)$/;"	f	file:	signature:(const char *filename, int fd, uintmax_t lines_to_write)
head_truncation	ptx.c	/^static int head_truncation;	\/* flag truncation before the head field *\/$/;"	v	file:
header	numfmt.c	/^static uintmax_t header = 0;$/;"	v	file:
header_del	nl.c	/^static char *header_del = NULL;$/;"	v	file:
header_del_len	nl.c	/^static size_t header_del_len;$/;"	v	file:
header_fastmap	nl.c	/^static char header_fastmap[UCHAR_MAX + 1];$/;"	v	file:
header_mode	df.c	/^static int header_mode = DEFAULT_MODE;$/;"	v	file:
header_mode	head.c	/^enum header_mode$/;"	g	file:
header_mode	tail.c	/^enum header_mode$/;"	g	file:
header_regex	nl.c	/^static struct re_pattern_buffer header_regex;$/;"	v	typeref:struct:re_pattern_buffer	file:
header_type	nl.c	/^static char const *header_type = "n";$/;"	v	file:
header_width_available	pr.c	/^static int header_width_available;$/;"	v	file:
hex_digits	md5sum.c	/^hex_digits (unsigned char const *s)$/;"	f	file:	signature:(unsigned char const *s)
hexl_mode_trailer	od.c	/^    bool hexl_mode_trailer;$/;"	m	struct:tspec	file:	access:public
hextobin	echo.c	/^hextobin (unsigned char c)$/;"	f	file:	signature:(unsigned char c)
hextobin	printf.c	66;"	d	file:
hextobin	stat.c	158;"	d	file:
hi	cut.c	/^    size_t hi;$/;"	m	struct:range_pair	file:	access:public
hi	sort.c	/^  struct line *hi;              \/* Lines to merge from HI child ndoe. *\/$/;"	m	struct:merge_node	typeref:struct:merge_node::line	file:	access:public
hi_child	sort.c	/^  struct merge_node *hi_child;  \/* HI child node. *\/$/;"	m	struct:merge_node	typeref:struct:merge_node::merge_node	file:	access:public
hide_patterns	ls.c	/^static struct ignore_pattern *hide_patterns;$/;"	v	typeref:struct:ignore_pattern	file:
hide_problematic_chars	df.c	/^hide_problematic_chars (char *cell)$/;"	f	file:	signature:(char *cell)
hit_final_extent	extent-scan.h	/^  bool hit_final_extent;$/;"	m	struct:extent_scan	access:public
hold_area	csplit.c	/^static char *hold_area = NULL;$/;"	v	file:
hold_count	csplit.c	/^static size_t hold_count = 0;$/;"	v	file:
hold_file	pr.c	/^hold_file (COLUMN *p)$/;"	f	file:	signature:(COLUMN *p)
homogeneous_spec_list	tr.c	/^homogeneous_spec_list (struct Spec_list *s)$/;"	f	file:	signature:(struct Spec_list *s)
horizontal	ls.c	/^    horizontal,			\/* -x *\/$/;"	e	enum:format	file:
human_access	stat.c	/^human_access (struct stat const *statbuf)$/;"	f	file:	signature:(struct stat const *statbuf)
human_fstype	stat.c	/^human_fstype (STRUCT_STATVFS const *statfsbuf)$/;"	f	file:	signature:(STRUCT_STATVFS const *statfsbuf)
human_numcompare	sort.c	/^human_numcompare (char const *a, char const *b)$/;"	f	file:	signature:(char const *a, char const *b)
human_numeric	sort.c	/^  bool human_numeric;		\/* Flag for sorting by human readable$/;"	m	struct:keyfield	file:	access:public
human_output_opts	df.c	/^static int human_output_opts;$/;"	v	file:
human_output_opts	du.c	/^static int human_output_opts;$/;"	v	file:
human_output_opts	ls.c	/^static int human_output_opts;$/;"	v	file:
human_size	dd.c	/^human_size (size_t n)$/;"	f	file:	signature:(size_t n)
human_time	stat.c	/^human_time (struct timespec t)$/;"	f	file:	signature:(struct timespec t)
i	expr.c	/^    mpz_t i;$/;"	m	union:valinfo::__anon61	file:	access:public
i	tac-pipe.c	/^  size_t i;$/;"	m	struct:Line_ptr	file:	access:public
i_nocache	dd.c	/^static bool i_nocache, o_nocache;$/;"	v	file:
idle_string	pinky.c	/^idle_string (time_t when)$/;"	f	file:	signature:(time_t when)
idle_string	who.c	/^idle_string (time_t when, time_t boottime)$/;"	f	file:	signature:(time_t when, time_t boottime)
ignorable	split.c	/^ignorable (int err)$/;"	f	file:	signature:(int err)
ignorable_failure	rmdir.c	/^ignorable_failure (int error_number, char const *dir)$/;"	f	file:	signature:(int error_number, char const *dir)
ignorable_missing	remove.c	/^ignorable_missing (struct rm_options const *x, int errnum)$/;"	f	file:	signature:(struct rm_options const *x, int errnum)
ignorable_sync_errno	shred.c	/^ignorable_sync_errno (int errno_val)$/;"	f	file:	signature:(int errno_val)
ignore	csplit.c	/^  bool ignore;			\/* If true, produce no output (for regexp). *\/$/;"	m	struct:control	file:	access:public
ignore	sort.c	/^  bool const *ignore;		\/* Boolean array of characters to ignore. *\/$/;"	m	struct:keyfield	file:	access:public
ignore	tail.c	/^  bool ignore;$/;"	m	struct:File_spec	file:	access:public
ignore_case	join.c	/^static bool ignore_case;$/;"	v	file:
ignore_case	ptx.c	/^static bool ignore_case = false;	\/* fold lower to upper for sorting *\/$/;"	v	file:
ignore_case	uniq.c	/^static bool ignore_case;$/;"	v	file:
ignore_fail_on_non_empty	rmdir.c	/^static bool ignore_fail_on_non_empty;$/;"	v	file:
ignore_failed_opens	pr.c	/^static bool ignore_failed_opens = false;$/;"	v	file:
ignore_fifo_and_pipe	tail.c	/^ignore_fifo_and_pipe (struct File_spec *f, size_t n_files)$/;"	f	file:	signature:(struct File_spec *f, size_t n_files)
ignore_file	ptx.c	/^static const char *ignore_file = NULL;	\/* name of the 'Ignore words' file *\/$/;"	v	file:
ignore_interrupts	tee.c	/^static bool ignore_interrupts;$/;"	v	file:
ignore_missing_files	remove.h	/^  bool ignore_missing_files;$/;"	m	struct:rm_options	access:public
ignore_mode	ls.c	/^} ignore_mode;$/;"	v	typeref:enum:__anon63	file:
ignore_pattern	ls.c	/^struct ignore_pattern$/;"	s	file:
ignore_pattern::next	ls.c	/^    struct ignore_pattern *next;$/;"	m	struct:ignore_pattern	typeref:struct:ignore_pattern::ignore_pattern	file:	access:public
ignore_pattern::pattern	ls.c	/^    const char *pattern;$/;"	m	struct:ignore_pattern	file:	access:public
ignore_patterns	ls.c	/^static struct ignore_pattern *ignore_patterns;$/;"	v	typeref:struct:ignore_pattern	file:
ignore_table	ptx.c	/^static WORD_TABLE ignore_table;	\/* table of words to ignore *\/$/;"	v	file:
immediate_dirs	ls.c	/^static bool immediate_dirs;$/;"	v	file:
in_column	fmt.c	/^static int in_column;$/;"	v	file:
in_delete_set	tr.c	/^static bool in_delete_set[N_CHARS];$/;"	v	file:
in_squeeze_set	tr.c	/^static bool in_squeeze_set[N_CHARS];$/;"	v	file:
in_stat_buf	split.c	/^static struct stat in_stat_buf;$/;"	v	typeref:struct:stat	file:
in_stream	od.c	/^static FILE *in_stream;$/;"	v	file:
include_exit	who.c	/^static bool include_exit;$/;"	v	file:
include_fullname	pinky.c	/^static bool include_fullname = true;$/;"	v	file:
include_heading	pinky.c	/^static bool include_heading = true;$/;"	v	file:
include_heading	who.c	/^static bool include_heading;$/;"	v	file:
include_home_and_shell	pinky.c	/^static bool include_home_and_shell = true;$/;"	v	file:
include_idle	pinky.c	/^static bool include_idle = true;$/;"	v	file:
include_idle	who.c	/^static bool include_idle;$/;"	v	file:
include_mesg	who.c	/^static bool include_mesg;$/;"	v	file:
include_plan	pinky.c	/^static bool include_plan = true;$/;"	v	file:
include_project	pinky.c	/^static bool include_project = true;$/;"	v	file:
include_where	pinky.c	/^static bool include_where = true;$/;"	v	file:
incname	shred.c	/^incname (char *name, size_t len)$/;"	f	file:	signature:(char *name, size_t len)
incompatible_options	sort.c	/^incompatible_options (char const *opts)$/;"	f	file:	signature:(char const *opts)
incr	seq.c	/^incr (char **s0, size_t *s_len)$/;"	f	file:	signature:(char **s0, size_t *s_len)
indefinite_repeat_element	tr.c	/^    struct List_element *indefinite_repeat_element;$/;"	m	struct:Spec_list	typeref:struct:Spec_list::List_element	file:	access:public
indent	ls.c	/^indent (size_t from, size_t to)$/;"	f	file:	signature:(size_t from, size_t to)
indent	ls.c	/^static void indent (size_t from, size_t to);$/;"	p	file:	signature:(size_t from, size_t to)
indicator_name	ls.c	/^static const char *const indicator_name[]=$/;"	v	file:
indicator_no	ls.c	/^enum indicator_no$/;"	g	file:
indicator_style	ls.c	/^enum indicator_style$/;"	g	file:
indicator_style	ls.c	/^static enum indicator_style indicator_style;$/;"	v	typeref:enum:indicator_style	file:
indicator_style_args	ls.c	/^static char const *const indicator_style_args[] =$/;"	v	file:
indicator_style_types	ls.c	/^static enum indicator_style const indicator_style_types[] =$/;"	v	file:
infile	cat.c	/^static char const *infile;$/;"	v	file:
infile	split.c	/^static char *infile;$/;"	v	file:
info_signal_count	dd.c	/^static sig_atomic_t volatile info_signal_count;$/;"	v	file:
init_column_info	ls.c	/^init_column_info (void)$/;"	f	file:	signature:(void)
init_fps	pr.c	/^init_fps (int number_of_files, char **av)$/;"	f	file:	signature:(int number_of_files, char **av)
init_fps	pr.c	/^static bool init_fps (int number_of_files, char **av);$/;"	p	file:	signature:(int number_of_files, char **av)
init_funcs	pr.c	/^init_funcs (void)$/;"	f	file:	signature:(void)
init_funcs	pr.c	/^static void init_funcs (void);$/;"	p	file:	signature:(void)
init_header	pr.c	/^init_header (char const *filename, int desc)$/;"	f	file:	signature:(char const *filename, int desc)
init_header	pr.c	/^static void init_header (char const *filename, int desc);$/;"	p	file:	signature:(char const *filename, int desc)
init_linep	join.c	/^init_linep (struct line **linep)$/;"	f	file:	signature:(struct line **linep)
init_node	sort.c	/^init_node (struct merge_node *restrict parent,$/;"	f	file:	signature:(struct merge_node *restrict parent, struct merge_node *restrict node_pool, struct line *dest, size_t nthreads, size_t total_lines, bool is_lo_child)
init_node	sort.c	/^static struct merge_node *init_node (struct merge_node *restrict,$/;"	p	file:	signature:(struct merge_node *restrict, struct merge_node *restrict, struct line *, size_t, size_t, bool)
init_page	pr.c	/^init_page (void)$/;"	f	file:	signature:(void)
init_parameters	pr.c	/^init_parameters (int number_of_files)$/;"	f	file:	signature:(int number_of_files)
init_parameters	pr.c	/^static void init_parameters (int number_of_files);$/;"	p	file:	signature:(int number_of_files)
init_store_cols	pr.c	/^init_store_cols (void)$/;"	f	file:	signature:(void)
init_store_cols	pr.c	/^static void init_store_cols (void);$/;"	p	file:	signature:(void)
initbuf	sort.c	/^initbuf (struct buffer *buf, size_t line_bytes, size_t alloc)$/;"	f	file:	signature:(struct buffer *buf, size_t line_bytes, size_t alloc)
initial_scan_failed	extent-scan.h	/^  bool initial_scan_failed;$/;"	m	struct:extent_scan	access:public
initialize_exit_failure	system.h	/^initialize_exit_failure (int status)$/;"	f	signature:(int status)
initialize_main	system.h	140;"	d
initialize_ordering_vector	ls.c	/^initialize_ordering_vector (void)$/;"	f	file:	signature:(void)
initialize_regex	ptx.c	/^initialize_regex (void)$/;"	f	file:	signature:(void)
initseq	join.c	/^initseq (struct seq *seq)$/;"	f	file:	signature:(struct seq *seq)
inittables	sort.c	/^inittables (void)$/;"	f	file:	signature:(void)
ino	copy.c	/^  ino_t ino;$/;"	m	struct:dir_list	file:	access:public
ino	tail.c	/^  ino_t ino;$/;"	m	struct:File_spec	file:	access:public
inode_number_width	ls.c	/^static int inode_number_width;$/;"	v	file:
inotify_wd_mask	tail.c	/^static const uint32_t inotify_wd_mask = (IN_MODIFY | IN_ATTRIB$/;"	v	file:
input	stty.c	/^    control, input, output, local, combination$/;"	e	enum:mode_type	file:
input_blocksize	dd.c	/^static size_t input_blocksize = 0;$/;"	v	file:
input_desc	cat.c	/^static int input_desc;$/;"	v	file:
input_file	dd.c	/^static char const *input_file = NULL;$/;"	v	file:
input_file_name	ptx.c	/^static const char **input_file_name;	\/* array of text input file names *\/$/;"	v	file:
input_filename	od.c	/^static char const *input_filename;$/;"	v	file:
input_flags	dd.c	/^static int input_flags = 0;$/;"	v	file:
input_from_argv	shuf.c	/^input_from_argv (char **operand, int n_operands, char eolbyte)$/;"	f	file:	signature:(char **operand, int n_operands, char eolbyte)
input_numbers_option_used	shuf.c	/^input_numbers_option_used (size_t lo_input, size_t hi_input)$/;"	f	file:	signature:(size_t lo_input, size_t hi_input)
input_offset	dd.c	/^static uintmax_t input_offset;$/;"	v	file:
input_offset_overflow	dd.c	/^static bool input_offset_overflow;$/;"	v	file:
input_position	pr.c	/^static int input_position;$/;"	v	file:
input_reference	ptx.c	/^static bool input_reference = false;	\/* refs at beginning of input lines *\/$/;"	v	file:
input_seek_errno	dd.c	/^static int input_seek_errno;$/;"	v	file:
input_seekable	dd.c	/^static bool input_seekable;$/;"	v	file:
input_speed	stty.c	/^    input_speed, output_speed, both_speeds$/;"	e	enum:speed_setting	file:
input_tab_char	pr.c	/^static char input_tab_char = '\\t';$/;"	v	file:
input_units	df.c	/^  uintmax_t input_units;$/;"	m	struct:field_values_t	file:	access:public
insert_index	csplit.c	/^  size_t insert_index;		\/* Next offset to use when inserting line. *\/$/;"	m	struct:line	file:	access:public
insertkey	sort.c	/^insertkey (struct keyfield *key_arg)$/;"	f	file:	signature:(struct keyfield *key_arg)
install_file_in_dir	install.c	/^install_file_in_dir (const char *from, const char *to_dir,$/;"	f	file:	signature:(const char *from, const char *to_dir, const struct cp_options *x)
install_file_in_file	install.c	/^install_file_in_file (const char *from, const char *to,$/;"	f	file:	signature:(const char *from, const char *to, const struct cp_options *x)
install_file_in_file_parents	install.c	/^install_file_in_file_parents (char const *from, char *to,$/;"	f	file:	signature:(char const *from, char *to, struct cp_options *x)
install_signal_handlers	dd.c	/^install_signal_handlers (void)$/;"	f	file:	signature:(void)
install_signal_handlers	timeout.c	/^install_signal_handlers (int sigterm)$/;"	f	file:	signature:(int sigterm)
int_value	expr.c	/^int_value (unsigned long int i)$/;"	f	file:	signature:(unsigned long int i)
integer	expr.c	/^  integer,$/;"	e	enum:valtype	file:
integer_arg	stty.c	/^integer_arg (const char *s, unsigned long int maxval)$/;"	f	file:	signature:(const char *s, unsigned long int maxval)
integer_arg	stty.c	/^static unsigned long int integer_arg (const char *s, unsigned long int max);$/;"	p	file:	signature:(const char *s, unsigned long int max)
integer_overflow	expr.c	/^integer_overflow (char op)$/;"	f	file:	signature:(char op)
integral_type_size	od.c	/^static enum size_spec integral_type_size[MAX_INTEGRAL_TYPE_SIZE + 1];$/;"	v	typeref:enum:size_spec	file:
interactive	copy.h	/^  enum Interactive interactive;$/;"	m	struct:cp_options	typeref:enum:cp_options::Interactive	access:public
interactive	ln.c	/^static bool interactive;$/;"	v	file:
interactive	remove.h	/^  enum rm_interactive interactive;$/;"	m	struct:rm_options	typeref:enum:rm_options::rm_interactive	access:public
interactive_always	rm.c	/^    interactive_always		\/* 2: default, -i or --interactive=always *\/$/;"	e	enum:interactive_type	file:
interactive_args	rm.c	/^static char const *const interactive_args[] =$/;"	v	file:
interactive_never	rm.c	/^    interactive_never,		\/* 0: no option or --interactive=never *\/$/;"	e	enum:interactive_type	file:
interactive_once	rm.c	/^    interactive_once,		\/* 1: -I or --interactive=once *\/$/;"	e	enum:interactive_type	file:
interactive_type	rm.c	/^enum interactive_type$/;"	g	file:
interactive_types	rm.c	/^static enum interactive_type const interactive_types[] =$/;"	v	file:
interpret_backslash_escapes	stat.c	/^static bool interpret_backslash_escapes;$/;"	v	file:
interrupt_handler	csplit.c	/^interrupt_handler (int sig)$/;"	f	file:	signature:(int sig)
interrupt_handler	dd.c	/^interrupt_handler (int sig)$/;"	f	file:	signature:(int sig)
interrupt_signal	dd.c	/^static sig_atomic_t volatile interrupt_signal;$/;"	v	file:
interrupt_signal	ls.c	/^static sig_atomic_t volatile interrupt_signal;$/;"	v	file:
inval_abort	numfmt.c	/^  inval_abort,$/;"	e	enum:inval_type	file:
inval_args	numfmt.c	/^static char const *const inval_args[] =$/;"	v	file:
inval_fail	numfmt.c	/^  inval_fail,$/;"	e	enum:inval_type	file:
inval_ignore	numfmt.c	/^  inval_ignore$/;"	e	enum:inval_type	file:
inval_type	numfmt.c	/^enum inval_type$/;"	g	file:
inval_types	numfmt.c	/^static enum inval_type const inval_types[] =$/;"	v	file:
inval_warn	numfmt.c	/^  inval_warn,$/;"	e	enum:inval_type	file:
invalidate_cache	dd.c	/^invalidate_cache (int fd, off_t len)$/;"	f	file:	signature:(int fd, off_t len)
invtab	factor.c	/^static const unsigned short invtab[0x81] =$/;"	v	file:
io_blksize	ioblksize.h	/^io_blksize (struct stat sb)$/;"	f	signature:(struct stat sb)
io_buf	tr.c	/^static char io_buf[BUFSIZ];$/;"	v	file:
iread	dd.c	/^iread (int fd, char *buf, size_t size)$/;"	f	file:	signature:(int fd, char *buf, size_t size)
iread_fnc	dd.c	/^static ssize_t (*iread_fnc) (int fd, char *buf, size_t size);$/;"	v	file:
iread_fullblock	dd.c	/^iread_fullblock (int fd, char *buf, size_t size)$/;"	f	file:	signature:(int fd, char *buf, size_t size)
is_ancestor	copy.c	/^is_ancestor (const struct stat *sb, const struct dir_list *ancestors)$/;"	f	file:	signature:(const struct stat *sb, const struct dir_list *ancestors)
is_char_class_member	tr.c	/^is_char_class_member (enum Char_class char_class, unsigned char c)$/;"	f	file:	signature:(enum Char_class char_class, unsigned char c)
is_colored	ls.c	/^is_colored (enum indicator_no type)$/;"	f	file:	signature:(enum indicator_no type)
is_directory	ls.c	/^is_directory (const struct fileinfo *f)$/;"	f	file:	signature:(const struct fileinfo *f)
is_empty_dir	system.h	/^is_empty_dir (int fd_cwd, char const *dir)$/;"	f	signature:(int fd_cwd, char const *dir)
is_equiv_class_member	tr.c	/^is_equiv_class_member (unsigned char equiv_class, unsigned char c)$/;"	f	file:	signature:(unsigned char equiv_class, unsigned char c)
is_local_fs_type	fs-is-local.h	/^is_local_fs_type (unsigned long int magic)$/;"	f	signature:(unsigned long int magic)
is_nul	system.h	/^is_nul (const char *buf, size_t bufsize)$/;"	f	signature:(const char *buf, size_t bufsize)
is_printable_field	cut.c	/^is_printable_field (size_t i)$/;"	f	file:	signature:(size_t i)
is_probably_sparse	copy.c	/^is_probably_sparse (struct stat const *sb)$/;"	f	file:	signature:(struct stat const *sb)
is_range_start_index	cut.c	/^is_range_start_index (size_t i)$/;"	f	file:	signature:(size_t i)
is_square	factor.c	/^is_square (uintmax_t x)$/;"	f	file:	signature:(uintmax_t x)
is_tty_writable	who.c	/^is_tty_writable (struct stat const *pstat)$/;"	f	file:	signature:(struct stat const *pstat)
isclose	fmt.c	121;"	d	file:
isdir	realpath.c	/^isdir (const char *path)$/;"	f	file:	signature:(const char *path)
isfinite	seq.c	33;"	d	file:
iso_time_style	du.c	/^    iso_time_style	       \/* --time-style=iso *\/$/;"	e	enum:time_style	file:
iso_time_style	ls.c	/^    iso_time_style,		\/* --time-style=iso *\/$/;"	e	enum:time_style	file:
isodigit	printf.c	65;"	d	file:
isodigit	stat.c	156;"	d	file:
isopen	fmt.c	120;"	d	file:
isperiod	fmt.c	122;"	d	file:
isqrt	factor.c	/^isqrt (uintmax_t n)$/;"	f	file:	signature:(uintmax_t n)
isqrt2	factor.c	/^isqrt2 (uintmax_t nh, uintmax_t nl)$/;"	f	file:	signature:(uintmax_t nh, uintmax_t nl)
issued_disorder_warning	comm.c	/^static bool issued_disorder_warning[2];$/;"	v	file:
issued_disorder_warning	join.c	/^static bool issued_disorder_warning[2];$/;"	v	file:
iswspace	wc.c	42;"	d	file:
item	tsort.c	/^struct item$/;"	s	file:
item::balance	tsort.c	/^  int balance; \/* -1, 0, or +1 *\/$/;"	m	struct:item	file:	access:public
item::count	tsort.c	/^  size_t count;$/;"	m	struct:item	file:	access:public
item::left	tsort.c	/^  struct item *left, *right;$/;"	m	struct:item	typeref:struct:item::item	file:	access:public
item::qlink	tsort.c	/^  struct item *qlink;$/;"	m	struct:item	typeref:struct:item::item	file:	access:public
item::right	tsort.c	/^  struct item *left, *right;$/;"	m	struct:item	typeref:struct:item::	file:	access:public
item::str	tsort.c	/^  const char *str;$/;"	m	struct:item	file:	access:public
item::top	tsort.c	/^  struct successor *top;$/;"	m	struct:item	typeref:struct:item::successor	file:	access:public
iwrite	dd.c	/^iwrite (int fd, char const *buf, size_t size)$/;"	f	file:	signature:(int fd, char const *buf, size_t size)
join	join.c	/^join (FILE *fp1, FILE *fp2)$/;"	f	file:	signature:(FILE *fp1, FILE *fp2)
join	join.c	42;"	d	file:
join_field_1	join.c	/^static size_t join_field_1 = SIZE_MAX;$/;"	v	file:
join_field_2	join.c	/^static size_t join_field_2 = SIZE_MAX;$/;"	v	file:
join_header_lines	join.c	/^static bool join_header_lines;$/;"	v	file:
join_lines	pr.c	/^static bool join_lines = false;$/;"	v	file:
just_context	id.c	/^static int just_context = 0;$/;"	v	file:
keep_FF	pr.c	/^static bool keep_FF = false;$/;"	v	file:
keep_new_line	csplit.c	/^keep_new_line (struct buffer_record *b, char *line_start, size_t line_len)$/;"	f	file:	signature:(struct buffer_record *b, char *line_start, size_t line_len)
key	ptx.c	/^    WORD key;			\/* description of the keyword *\/$/;"	m	struct:__anon32	file:	access:public
key_init	sort.c	/^key_init (struct keyfield *key)$/;"	f	file:	signature:(struct keyfield *key)
key_numeric	sort.c	/^key_numeric (struct keyfield const *key)$/;"	f	file:	signature:(struct keyfield const *key)
key_to_opts	sort.c	/^key_to_opts (struct keyfield const *key, char *opts)$/;"	f	file:	signature:(struct keyfield const *key, char *opts)
key_warnings	sort.c	/^key_warnings (struct keyfield const *gkey, bool gkey_only)$/;"	f	file:	signature:(struct keyfield const *gkey, bool gkey_only)
keyafter	ptx.c	/^static BLOCK keyafter;		\/* keyword-and-after field *\/$/;"	v	file:
keyafter_max_width	ptx.c	/^static int keyafter_max_width;	\/* maximum width of keyword-and-after field *\/$/;"	v	file:
keyafter_truncation	ptx.c	/^static int keyafter_truncation;	\/* flag truncation after the keyafter field *\/$/;"	v	file:
keybeg	sort.c	/^  char *keybeg;			\/* Start of first key. *\/$/;"	m	struct:line	file:	access:public
keycmp	join.c	/^keycmp (struct line const *line1, struct line const *line2,$/;"	f	file:	signature:(struct line const *line1, struct line const *line2, size_t jf_1, size_t jf_2)
keycompare	sort.c	/^keycompare (struct line const *a, struct line const *b)$/;"	f	file:	signature:(struct line const *a, struct line const *b)
keyfield	sort.c	/^struct keyfield$/;"	s	file:
keyfield::echar	sort.c	/^  size_t echar;			\/* Additional characters in field. *\/$/;"	m	struct:keyfield	file:	access:public
keyfield::eword	sort.c	/^  size_t eword;			\/* Zero-origin last 'word' of key. *\/$/;"	m	struct:keyfield	file:	access:public
keyfield::general_numeric	sort.c	/^  bool general_numeric;		\/* Flag for general, numeric comparison.$/;"	m	struct:keyfield	file:	access:public
keyfield::human_numeric	sort.c	/^  bool human_numeric;		\/* Flag for sorting by human readable$/;"	m	struct:keyfield	file:	access:public
keyfield::ignore	sort.c	/^  bool const *ignore;		\/* Boolean array of characters to ignore. *\/$/;"	m	struct:keyfield	file:	access:public
keyfield::month	sort.c	/^  bool month;			\/* Flag for comparison by month name. *\/$/;"	m	struct:keyfield	file:	access:public
keyfield::next	sort.c	/^  struct keyfield *next;	\/* Next keyfield to try. *\/$/;"	m	struct:keyfield	typeref:struct:keyfield::keyfield	file:	access:public
keyfield::numeric	sort.c	/^  bool numeric;			\/* Flag for numeric comparison.  Handle$/;"	m	struct:keyfield	file:	access:public
keyfield::obsolete_used	sort.c	/^  bool obsolete_used;		\/* obsolescent key option format is used. *\/$/;"	m	struct:keyfield	file:	access:public
keyfield::random	sort.c	/^  bool random;			\/* Sort by random hash of key.  *\/$/;"	m	struct:keyfield	file:	access:public
keyfield::reverse	sort.c	/^  bool reverse;			\/* Reverse the sense of comparison. *\/$/;"	m	struct:keyfield	file:	access:public
keyfield::schar	sort.c	/^  size_t schar;			\/* Additional characters to skip. *\/$/;"	m	struct:keyfield	file:	access:public
keyfield::skipeblanks	sort.c	/^  bool skipeblanks;		\/* Skip leading blanks when finding end.  *\/$/;"	m	struct:keyfield	file:	access:public
keyfield::skipsblanks	sort.c	/^  bool skipsblanks;		\/* Skip leading blanks when finding start.  *\/$/;"	m	struct:keyfield	file:	access:public
keyfield::sword	sort.c	/^  size_t sword;			\/* Zero-origin 'word' to start at. *\/$/;"	m	struct:keyfield	file:	access:public
keyfield::translate	sort.c	/^  char const *translate;	\/* Translation applied to characters. *\/$/;"	m	struct:keyfield	file:	access:public
keyfield::version	sort.c	/^  bool version;			\/* sort by version number *\/$/;"	m	struct:keyfield	file:	access:public
keylim	sort.c	/^  char *keylim;			\/* Limit of first key. *\/$/;"	m	struct:line	file:	access:public
keylist	sort.c	/^static struct keyfield *keylist;$/;"	v	typeref:struct:keyfield	file:
kill_after	timeout.c	/^static double kill_after;$/;"	v	file:
known_value	df.c	/^known_value (uintmax_t n)$/;"	f	file:	signature:(uintmax_t n)
last_char	tr.c	/^            unsigned char last_char;$/;"	m	struct:List_element::__anon3::__anon4	file:	access:public
last_line	pr.c	/^static bool last_line = false;$/;"	v	file:
last_line_length	fmt.c	/^static int last_line_length;$/;"	v	file:
last_line_number	csplit.c	/^static uintmax_t last_line_number = 0;$/;"	v	file:
last_page_number	pr.c	/^static uintmax_t last_page_number = UINTMAX_MAX;$/;"	v	file:
layout	seq.c	/^struct layout$/;"	s	file:
layout::prefix_len	seq.c	/^  size_t prefix_len;$/;"	m	struct:layout	file:	access:public
layout::suffix_len	seq.c	/^  size_t suffix_len;$/;"	m	struct:layout	file:	access:public
lchown	copy.c	78;"	d	file:
lchown	cp.c	39;"	d	file:
lchown	install.c	64;"	d	file:
lcm	system.h	/^lcm (size_t u, size_t v)$/;"	f	signature:(size_t u, size_t v)
left	ptx.c	/^    DELTA left;			\/* distance to left context start *\/$/;"	m	struct:__anon32	file:	access:public
left	sort.c	/^  size_t left;			\/* Number of bytes left from previous reads. *\/$/;"	m	struct:buffer	file:	access:public
left	tsort.c	/^  struct item *left, *right;$/;"	m	struct:item	typeref:struct:item::item	file:	access:public
len	csplit.c	/^  size_t len;$/;"	m	struct:cstring	file:	access:public
len	join.c	/^    size_t len;			\/* The length of the field.  *\/$/;"	m	struct:field	file:	access:public
len	ls.c	/^    size_t len;			\/* Number of bytes *\/$/;"	m	struct:bin_str	file:	access:public
len	tr.c	/^  size_t len;$/;"	m	struct:E_string	file:	access:public
length	fmt.c	/^    int length;			\/* length of this word *\/$/;"	m	struct:Word	file:	access:public
length	ptx.c	/^    size_t length;		\/* number of used entries *\/$/;"	m	struct:__anon31	file:	access:public
length	sort.c	/^  size_t length;		\/* Length including final newline. *\/$/;"	m	struct:line	file:	access:public
length	tr.c	/^    count length;$/;"	m	struct:Spec_list	file:	access:public
length_of_file_name_and_frills	ls.c	/^length_of_file_name_and_frills (const struct fileinfo *f)$/;"	f	file:	signature:(const struct fileinfo *f)
level	sort.c	/^  unsigned int level;           \/* Level in merge tree. *\/$/;"	m	struct:merge_node	file:	access:public
lim	factor.c	/^  uintmax_t binv, lim;$/;"	m	struct:primes_dtab	file:	access:public
lim	make-prime-list.c	/^  wide_uint lim; \/* floor ((wide_uint) -1 \/ p) *\/$/;"	m	struct:prime	file:	access:public
limfield	sort.c	/^limfield (struct line const *line, struct keyfield const *key)$/;"	f	file:	signature:(struct line const *line, struct keyfield const *key)
limit_bytes_to_format	od.c	/^static bool limit_bytes_to_format = false;$/;"	v	file:
line	csplit.c	/^struct line$/;"	s	file:
line	join.c	/^struct line$/;"	s	file:
line	sort.c	/^struct line$/;"	s	file:
line::buf	join.c	/^    struct linebuffer buf;	\/* The line itself.  *\/$/;"	m	struct:line	typeref:struct:line::linebuffer	file:	access:public
line::fields	join.c	/^    struct field *fields;$/;"	m	struct:line	typeref:struct:line::field	file:	access:public
line::insert_index	csplit.c	/^  size_t insert_index;		\/* Next offset to use when inserting line. *\/$/;"	m	struct:line	file:	access:public
line::keybeg	sort.c	/^  char *keybeg;			\/* Start of first key. *\/$/;"	m	struct:line	file:	access:public
line::keylim	sort.c	/^  char *keylim;			\/* Limit of first key. *\/$/;"	m	struct:line	file:	access:public
line::length	sort.c	/^  size_t length;		\/* Length including final newline. *\/$/;"	m	struct:line	file:	access:public
line::next	csplit.c	/^  struct line *next;		\/* Next in linked list. *\/$/;"	m	struct:line	typeref:struct:line::line	file:	access:public
line::nfields	join.c	/^    size_t nfields;		\/* Number of elements in 'fields'.  *\/$/;"	m	struct:line	file:	access:public
line::nfields_allocated	join.c	/^    size_t nfields_allocated;	\/* Number of elements allocated for 'fields'. *\/$/;"	m	struct:line	file:	access:public
line::retrieve_index	csplit.c	/^  size_t retrieve_index;	\/* Next index to use when retrieving line. *\/$/;"	m	struct:line	file:	access:public
line::starts	csplit.c	/^  struct cstring starts[CTRL_SIZE]; \/* Lines in the data area. *\/$/;"	m	struct:line	typeref:struct:line::cstring	file:	access:public
line::text	sort.c	/^  char *text;			\/* Text of the line. *\/$/;"	m	struct:line	file:	access:public
line::used	csplit.c	/^  size_t used;			\/* Number of offsets used in this struct. *\/$/;"	m	struct:line	file:	access:public
line_buf	cat.c	/^static char line_buf[LINE_COUNTER_BUF_LEN] =$/;"	v	file:
line_buf	nl.c	/^static struct linebuffer line_buf;$/;"	v	typeref:struct:linebuffer	file:
line_bytes	sort.c	/^  size_t line_bytes;		\/* Number of bytes to reserve for each line. *\/$/;"	m	struct:buffer	file:	access:public
line_bytes_split	split.c	/^line_bytes_split (size_t n_bytes)$/;"	f	file:	signature:(size_t n_bytes)
line_cost	fmt.c	/^line_cost (WORD *next, int len)$/;"	f	file:	signature:(WORD *next, int len)
line_cost	fmt.c	/^static COST line_cost (WORD *next, int len);$/;"	p	file:	signature:(WORD *next, int len)
line_count	pr.c	/^static int line_count = 1;$/;"	v	file:
line_len	ls.c	/^  size_t line_len;$/;"	m	struct:column_info	file:	access:public
line_length	fmt.c	/^    int line_length;		\/* length of the best line starting here *\/$/;"	m	struct:Word	file:	access:public
line_length	ls.c	/^static size_t line_length;$/;"	v	file:
line_no	join.c	/^static uintmax_t line_no[2] = {0, 0};$/;"	v	file:
line_no	nl.c	/^static intmax_t line_no;$/;"	v	file:
line_num_end	cat.c	/^static char *line_num_end = line_buf + LINE_COUNTER_BUF_LEN - 3;$/;"	v	file:
line_num_print	cat.c	/^static char *line_num_print = line_buf + LINE_COUNTER_BUF_LEN - 8;$/;"	v	file:
line_num_start	cat.c	/^static char *line_num_start = line_buf + LINE_COUNTER_BUF_LEN - 3;$/;"	v	file:
line_number	pr.c	/^static int line_number;$/;"	v	file:
line_ptr_decrement	tac-pipe.c	/^line_ptr_decrement (const Buf *x, const Line_ptr *lp)$/;"	f	signature:(const Buf *x, const Line_ptr *lp)
line_ptr_increment	tac-pipe.c	/^line_ptr_increment (const Buf *x, const Line_ptr *lp)$/;"	f	signature:(const Buf *x, const Line_ptr *lp)
line_separator	pr.c	/^static char *line_separator = (char *) "\\t";$/;"	v	file:
line_start	csplit.c	/^  struct line *line_start;	\/* Head of list of pointers to lines. *\/$/;"	m	struct:buffer_record	typeref:struct:buffer_record::line	file:	access:public
line_vector	pr.c	/^static int *line_vector;$/;"	v	file:
line_width	ptx.c	/^static int line_width = 72;	\/* output line width in characters *\/$/;"	v	file:
lineno_format	nl.c	/^static char const *lineno_format = FORMAT_RIGHT_NOLZ;$/;"	v	file:
lineno_width	nl.c	/^static int lineno_width = 6;$/;"	v	file:
lines	join.c	/^    struct line **lines;$/;"	m	struct:seq	typeref:struct:seq::line	file:	access:public
lines	sort.c	/^  struct line *lines;$/;"	m	struct:thread_args	typeref:struct:thread_args::line	file:	access:public
lines_chunk_split	split.c	/^lines_chunk_split (uintmax_t k, uintmax_t n, char *buf, size_t bufsize,$/;"	f	file:	signature:(uintmax_t k, uintmax_t n, char *buf, size_t bufsize, off_t file_size)
lines_per_body	pr.c	/^static int lines_per_body;$/;"	v	file:
lines_per_footer	pr.c	/^enum { lines_per_footer = 5 };$/;"	e	enum:__anon13	file:
lines_per_header	pr.c	/^enum { lines_per_header = 5 };$/;"	e	enum:__anon12	file:
lines_per_page	pr.c	/^static int lines_per_page = 66;$/;"	v	file:
lines_required	csplit.c	/^  uintmax_t lines_required;	\/* Number of lines required. *\/$/;"	m	struct:control	file:	access:public
lines_rr	split.c	/^lines_rr (uintmax_t k, uintmax_t n, char *buf, size_t bufsize)$/;"	f	file:	signature:(uintmax_t k, uintmax_t n, char *buf, size_t bufsize)
lines_split	split.c	/^lines_split (uintmax_t n_lines, char *buf, size_t bufsize)$/;"	f	file:	signature:(uintmax_t n_lines, char *buf, size_t bufsize)
lines_stored	pr.c	/^    int lines_stored;		\/* Number of lines stored in buff. *\/$/;"	m	struct:COLUMN	file:	access:public
lines_to_print	pr.c	/^    int lines_to_print;		\/* No. lines stored or space left on page. *\/$/;"	m	struct:COLUMN	file:	access:public
linkmode	ls.c	/^    mode_t linkmode;$/;"	m	struct:fileinfo	file:	access:public
linkname	ls.c	/^    char *linkname;$/;"	m	struct:fileinfo	file:	access:public
linkok	ls.c	/^    bool linkok;$/;"	m	struct:fileinfo	file:	access:public
list_entries_users	users.c	/^list_entries_users (size_t n, const STRUCT_UTMP *this)$/;"	f	file:	signature:(size_t n, const STRUCT_UTMP *this)
list_entries_who	who.c	/^list_entries_who (size_t n, const STRUCT_UTMP *utmp_buf)$/;"	f	file:	signature:(size_t n, const STRUCT_UTMP *utmp_buf)
list_signals	kill.c	/^list_signals (bool table, char *const *argv)$/;"	f	file:	signature:(bool table, char *const *argv)
lo	cut.c	/^    size_t lo;$/;"	m	struct:range_pair	file:	access:public
lo	sort.c	/^  struct line *lo;              \/* Lines to merge from LO child node. *\/$/;"	m	struct:merge_node	typeref:struct:merge_node::line	file:	access:public
lo_child	sort.c	/^  struct merge_node *lo_child;  \/* LO child node. *\/$/;"	m	struct:merge_node	typeref:struct:merge_node::merge_node	file:	access:public
load_buffer	csplit.c	/^load_buffer (void)$/;"	f	file:	signature:(void)
local	stty.c	/^    control, input, output, local, combination$/;"	e	enum:mode_type	file:
locale_time_style	ls.c	/^    locale_time_style		\/* --time-style=locale *\/$/;"	e	enum:time_style	file:
lock	sort.c	/^  pthread_mutex_t lock;         \/* Lock for node operations. *\/$/;"	m	struct:merge_node	file:	access:public
lock_node	sort.c	/^lock_node (struct merge_node *node)$/;"	f	file:	signature:(struct merge_node *node)
logical	ln.c	/^static bool logical = !!LINK_FOLLOWS_SYMLINKS;$/;"	v	file:
logical	realpath.c	/^static bool logical;$/;"	v	file:
logical_getcwd	pwd.c	/^logical_getcwd (void)$/;"	f	file:	signature:(void)
long_double	sort.c	95;"	d	file:
long_double	sort.c	97;"	d	file:
long_double_format	seq.c	/^long_double_format (char const *fmt, struct layout *layout)$/;"	f	file:	signature:(char const *fmt, struct layout *layout)
long_format	ls.c	/^    long_format,		\/* -l and other options that imply -l *\/$/;"	e	enum:format	file:
long_iso_time_style	du.c	/^    long_iso_time_style,       \/* --time-style=long-iso *\/$/;"	e	enum:time_style	file:
long_iso_time_style	ls.c	/^    long_iso_time_style,	\/* --time-style=long-iso *\/$/;"	e	enum:time_style	file:
long_options	base64.c	/^static struct option const long_options[] =$/;"	v	file:
long_options	chcon.c	/^static struct option const long_options[] =$/;"	v	file:
long_options	chgrp.c	/^static struct option const long_options[] =$/;"	v	file:
long_options	chmod.c	/^static struct option const long_options[] =$/;"	v	file:
long_options	chown.c	/^static struct option const long_options[] =$/;"	v	file:
long_options	comm.c	/^static struct option const long_options[] =$/;"	v	file:
long_options	date.c	/^static struct option const long_options[] =$/;"	v	file:
long_options	df.c	/^static struct option const long_options[] =$/;"	v	file:
long_options	dircolors.c	/^static struct option const long_options[] =$/;"	v	file:
long_options	du.c	/^static struct option const long_options[] =$/;"	v	file:
long_options	factor.c	/^static struct option const long_options[] =$/;"	v	file:
long_options	fmt.c	/^static struct option const long_options[] =$/;"	v	file:
long_options	head.c	/^static struct option const long_options[] =$/;"	v	file:
long_options	install.c	/^static struct option const long_options[] =$/;"	v	file:
long_options	kill.c	/^static struct option const long_options[] =$/;"	v	file:
long_options	ln.c	/^static struct option const long_options[] =$/;"	v	file:
long_options	ls.c	/^static struct option const long_options[] =$/;"	v	file:
long_options	md5sum.c	/^static struct option const long_options[] =$/;"	v	file:
long_options	mv.c	/^static struct option const long_options[] =$/;"	v	file:
long_options	od.c	/^static struct option const long_options[] =$/;"	v	file:
long_options	pr.c	/^static struct option const long_options[] =$/;"	v	file:
long_options	ptx.c	/^static struct option const long_options[] =$/;"	v	file:
long_options	runcon.c	/^static struct option const long_options[] =$/;"	v	file:
long_options	seq.c	/^static struct option const long_options[] =$/;"	v	file:
long_options	sort.c	/^static struct option const long_options[] =$/;"	v	file:
long_options	stat.c	/^static struct option const long_options[] =$/;"	v	file:
long_options	tail.c	/^static struct option const long_options[] =$/;"	v	file:
long_options	tee.c	/^static struct option const long_options[] =$/;"	v	file:
long_options	timeout.c	/^static struct option const long_options[] =$/;"	v	file:
long_options	tr.c	/^static struct option const long_options[] =$/;"	v	file:
long_opts	chroot.c	/^static struct option const long_opts[] =$/;"	v	file:
long_opts	cp.c	/^static struct option const long_opts[] =$/;"	v	file:
long_opts	rm.c	/^static struct option const long_opts[] =$/;"	v	file:
long_opts	shred.c	/^static struct option const long_opts[] =$/;"	v	file:
long_opts	shuf.c	/^static struct option const long_opts[] =$/;"	v	file:
long_pinky	pinky.c	/^long_pinky (const int argc_names, char *const argv_names[])$/;"	f	file:	signature:(const int argc_names, char *const argv_names[])
long_time_expected_width	ls.c	/^long_time_expected_width (void)$/;"	f	file:	signature:(void)
long_time_format	ls.c	/^static char const *long_time_format[2] =$/;"	v	file:
longdiff	ls.c	131;"	d	file:
longopts	basename.c	/^static struct option const longopts[] =$/;"	v	file:
longopts	csplit.c	/^static struct option const longopts[] =$/;"	v	file:
longopts	cut.c	/^static struct option const longopts[] =$/;"	v	file:
longopts	dirname.c	/^static struct option const longopts[] =$/;"	v	file:
longopts	env.c	/^static struct option const longopts[] =$/;"	v	file:
longopts	expand.c	/^static struct option const longopts[] =$/;"	v	file:
longopts	fold.c	/^static struct option const longopts[] =$/;"	v	file:
longopts	groups.c	/^static struct option const longopts[] =$/;"	v	file:
longopts	id.c	/^static struct option const longopts[] =$/;"	v	file:
longopts	join.c	/^static struct option const longopts[] =$/;"	v	file:
longopts	mkdir.c	/^static struct option const longopts[] =$/;"	v	file:
longopts	mkfifo.c	/^static struct option const longopts[] =$/;"	v	file:
longopts	mknod.c	/^static struct option const longopts[] =$/;"	v	file:
longopts	mktemp.c	/^static struct option const longopts[] =$/;"	v	file:
longopts	nice.c	/^static struct option const longopts[] =$/;"	v	file:
longopts	nl.c	/^static struct option const longopts[] =$/;"	v	file:
longopts	nproc.c	/^static struct option const longopts[] =$/;"	v	file:
longopts	numfmt.c	/^static struct option const longopts[] =$/;"	v	file:
longopts	paste.c	/^static struct option const longopts[] =$/;"	v	file:
longopts	pathchk.c	/^static struct option const longopts[] =$/;"	v	file:
longopts	pinky.c	/^static struct option const longopts[] =$/;"	v	file:
longopts	printenv.c	/^static struct option const longopts[] =$/;"	v	file:
longopts	pwd.c	/^static struct option const longopts[] =$/;"	v	file:
longopts	readlink.c	/^static struct option const longopts[] =$/;"	v	file:
longopts	realpath.c	/^static struct option const longopts[] =$/;"	v	file:
longopts	rmdir.c	/^static struct option const longopts[] =$/;"	v	file:
longopts	split.c	/^static struct option const longopts[] =$/;"	v	file:
longopts	stdbuf.c	/^static struct option const longopts[] =$/;"	v	file:
longopts	stty.c	/^static struct option const longopts[] =$/;"	v	file:
longopts	sum.c	/^static struct option const longopts[] =$/;"	v	file:
longopts	tac.c	/^static struct option const longopts[] =$/;"	v	file:
longopts	touch.c	/^static struct option const longopts[] =$/;"	v	file:
longopts	truncate.c	/^static struct option const longopts[] =$/;"	v	file:
longopts	tty.c	/^static struct option const longopts[] =$/;"	v	file:
longopts	unexpand.c	/^static struct option const longopts[] =$/;"	v	file:
longopts	uniq.c	/^static struct option const longopts[] =$/;"	v	file:
longopts	wc.c	/^static struct option const longopts[] =$/;"	v	file:
longopts	who.c	/^static struct option const longopts[] =$/;"	v	file:
look_up_char_class	tr.c	/^look_up_char_class (char const *class_str, size_t len)$/;"	f	file:	signature:(char const *class_str, size_t len)
looks_like_integer	expr.c	/^looks_like_integer (char const *cp)$/;"	f	file:	signature:(char const *cp)
loop	tsort.c	/^static struct item *loop = NULL;$/;"	v	typeref:struct:item	file:
ls_codes	dircolors.c	/^static const char *const ls_codes[] =$/;"	v	file:
ls_mode	ls-dir.c	/^int ls_mode = LS_MULTI_COL;$/;"	v
ls_mode	ls-ls.c	/^int ls_mode = LS_LS;$/;"	v
ls_mode	ls-vdir.c	/^int ls_mode = LS_LONG_FORMAT;$/;"	v
lsc_obstack	dircolors.c	/^static struct obstack lsc_obstack;$/;"	v	typeref:struct:obstack	file:
lsh2	factor.c	320;"	d	file:
macro_name	ptx.c	/^static const char *macro_name = "xx";	\/* macro name for roff or TeX output *\/$/;"	v	file:
main	base64.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	basename.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	cat.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	chcon.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	chgrp.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	chmod.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	chown.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	chroot.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	cksum.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	cksum.c	/^main (void)$/;"	f	signature:(void)
main	comm.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	cp.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	csplit.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	cut.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	date.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	dd.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	df.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	dircolors.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	dirname.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	du.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	echo.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	env.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	expand.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	expr.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	factor.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	fmt.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	fold.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	getlimits.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	groups.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	head.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	hostid.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	hostname.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	id.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	install.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	join.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	kill.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	link.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	ln.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	logname.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	ls.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	make-prime-list.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	md5sum.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	mkdir.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	mkfifo.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	mknod.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	mktemp.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	mv.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	nice.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	nl.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	nohup.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	nproc.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	numfmt.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	od.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	paste.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	pathchk.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	pinky.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	pr.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	printenv.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	printf.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	ptx.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	pwd.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	readlink.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	realpath.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	rm.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	rmdir.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	runcon.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	seq.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	setuidgid.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	shred.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	shuf.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	sleep.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	sort.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	split.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	stat.c	/^main (int argc, char *argv[])$/;"	f	signature:(int argc, char *argv[])
main	stdbuf.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	stty.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	sum.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	sync.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	tac.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	tail.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	tee.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	test.c	/^main (int margc, char **margv)$/;"	f	signature:(int margc, char **margv)
main	test.c	799;"	d	file:
main	timeout.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	touch.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	tr.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	true.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	truncate.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	tsort.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	tty.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	uname.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	unexpand.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	uniq.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	unlink.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	uptime.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	users.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	wc.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	who.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	whoami.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	yes.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
major	system.h	72;"	d
major_device_number_width	ls.c	/^static int major_device_number_width;$/;"	v	file:
make_ancestor	install.c	/^make_ancestor (char const *dir, char const *component, void *options)$/;"	f	file:	signature:(char const *dir, char const *component, void *options)
make_ancestor	mkdir.c	/^make_ancestor (char const *dir, char const *component, void *options)$/;"	f	file:	signature:(char const *dir, char const *component, void *options)
make_ancestor_function	mkdir.c	/^  int (*make_ancestor_function) (char const *, char const *, void *);$/;"	m	struct:mkdir_options	file:	access:public
make_dir_parents_private	cp.c	/^make_dir_parents_private (char const *const_dir, size_t src_offset,$/;"	f	file:	signature:(char const *const_dir, size_t src_offset, char const *verbose_fmt_string, struct dir_attr **attr_list, bool *new_dst, const struct cp_options *x)
make_filename	csplit.c	/^make_filename (unsigned int num)$/;"	f	file:	signature:(unsigned int num)
make_format	stat.c	/^make_format (char *pformat, size_t prefix_len, char const *allowed_flags,$/;"	f	file:	signature:(char *pformat, size_t prefix_len, char const *allowed_flags, char const *suffix)
make_id_equals_comment	who.c	/^make_id_equals_comment (STRUCT_UTMP const *utmp_ent)$/;"	f	file:	signature:(STRUCT_UTMP const *utmp_ent)
make_link_name	ls.c	/^make_link_name (char const *name, char const *linkname)$/;"	f	file:	signature:(char const *name, char const *linkname)
make_link_name	ls.c	/^static char *make_link_name (char const *name, char const *linkname);$/;"	p	file:	signature:(char const *name, char const *linkname)
make_printable_char	tr.c	/^make_printable_char (unsigned char c)$/;"	f	file:	signature:(unsigned char c)
make_printable_str	tr.c	/^make_printable_str (char const *s, size_t len)$/;"	f	file:	signature:(char const *s, size_t len)
makedev	system.h	74;"	d
makedev	system.h	79;"	d
malloc	make-prime-list.c	32;"	d	file:
many_per_line	ls.c	/^    many_per_line,		\/* -C *\/$/;"	e	enum:format	file:
mark_ancestor_dirs	remove.c	/^mark_ancestor_dirs (FTSENT *ent)$/;"	f	file:	signature:(FTSENT *ent)
mark_key	sort.c	/^mark_key (size_t offset, size_t width)$/;"	f	file:	signature:(size_t offset, size_t width)
mark_printable_field	cut.c	/^mark_printable_field (size_t i)$/;"	f	file:	signature:(size_t i)
mark_range_start	cut.c	/^mark_range_start (size_t i)$/;"	f	file:	signature:(size_t i)
mask	stty.c	/^    unsigned long mask;		\/* Other bits to turn off for this mode.  *\/$/;"	m	struct:mode_info	file:	access:public
match_length	tac.c	/^static size_t match_length;$/;"	v	file:
matcher_error	ptx.c	/^matcher_error (void)$/;"	f	file:	signature:(void)
matchpathcon_init_prefix	install.c	68;"	d	file:
max_bytes	dd.c	/^static size_t max_bytes = 0;$/;"	v	file:
max_bytes_to_format	od.c	/^static uintmax_t max_bytes_to_format;$/;"	v	file:
max_col	stty.c	/^static int max_col;$/;"	v	file:
max_column_width	unexpand.c	/^static size_t max_column_width;$/;"	v	file:
max_depth	du.c	/^static size_t max_depth = SIZE_MAX;$/;"	v	file:
max_idx	ls.c	/^static size_t max_idx;$/;"	v	file:
max_line_length	wc.c	/^static uintmax_t max_line_length;$/;"	v	file:
max_n_unchanged_stats_between_opens	tail.c	/^static uintmax_t max_n_unchanged_stats_between_opens =$/;"	v	file:
max_out	csplit.c	/^max_out (char *format)$/;"	f	file:	signature:(char *format)
max_range_endpoint	cut.c	/^static size_t max_range_endpoint;$/;"	v	file:
max_records	dd.c	/^static uintmax_t max_records = (uintmax_t) -1;$/;"	v	file:
max_width	fmt.c	/^static int max_width;$/;"	v	file:
maximum_word_length	ptx.c	/^static int maximum_word_length;$/;"	v	file:
maybe_close_stdout	dd.c	/^maybe_close_stdout (void)$/;"	f	file:	signature:(void)
maybe_close_stdout	mktemp.c	/^maybe_close_stdout (void)$/;"	f	file:	signature:(void)
maybe_create_temp	sort.c	/^maybe_create_temp (FILE **pfp, bool survive_fd_exhaustion)$/;"	f	file:	signature:(FILE **pfp, bool survive_fd_exhaustion)
me	df.c	/^  struct mount_entry *me;$/;"	m	struct:devlist	typeref:struct:devlist::mount_entry	file:	access:public
merge	sort.c	/^merge (struct sortfile *files, size_t ntemps, size_t nfiles,$/;"	f	file:	signature:(struct sortfile *files, size_t ntemps, size_t nfiles, char const *output_file)
merge_buffer_size	sort.c	/^static size_t merge_buffer_size = MAX (MIN_MERGE_BUFFER_SIZE, 256 * 1024);$/;"	v	file:
merge_loop	sort.c	/^merge_loop (struct merge_node_queue *queue,$/;"	f	file:	signature:(struct merge_node_queue *queue, size_t total_lines, FILE *tfp, char const *temp_output)
merge_node	sort.c	/^struct merge_node$/;"	s	file:
merge_node::dest	sort.c	/^  struct line **dest;           \/* Pointer to destination of merge. *\/$/;"	m	struct:merge_node	typeref:struct:merge_node::line	file:	access:public
merge_node::end_hi	sort.c	/^  struct line *end_hi;          \/* End of available lines from HI. *\/$/;"	m	struct:merge_node	typeref:struct:merge_node::line	file:	access:public
merge_node::end_lo	sort.c	/^  struct line *end_lo;          \/* End of available lines from LO. *\/$/;"	m	struct:merge_node	typeref:struct:merge_node::line	file:	access:public
merge_node::hi	sort.c	/^  struct line *hi;              \/* Lines to merge from HI child ndoe. *\/$/;"	m	struct:merge_node	typeref:struct:merge_node::line	file:	access:public
merge_node::hi_child	sort.c	/^  struct merge_node *hi_child;  \/* HI child node. *\/$/;"	m	struct:merge_node	typeref:struct:merge_node::merge_node	file:	access:public
merge_node::level	sort.c	/^  unsigned int level;           \/* Level in merge tree. *\/$/;"	m	struct:merge_node	file:	access:public
merge_node::lo	sort.c	/^  struct line *lo;              \/* Lines to merge from LO child node. *\/$/;"	m	struct:merge_node	typeref:struct:merge_node::line	file:	access:public
merge_node::lo_child	sort.c	/^  struct merge_node *lo_child;  \/* LO child node. *\/$/;"	m	struct:merge_node	typeref:struct:merge_node::merge_node	file:	access:public
merge_node::lock	sort.c	/^  pthread_mutex_t lock;         \/* Lock for node operations. *\/$/;"	m	struct:merge_node	file:	access:public
merge_node::nhi	sort.c	/^  size_t nhi;                   \/* Total lines remaining from HI. *\/$/;"	m	struct:merge_node	file:	access:public
merge_node::nlo	sort.c	/^  size_t nlo;                   \/* Total Lines remaining from LO. *\/$/;"	m	struct:merge_node	file:	access:public
merge_node::parent	sort.c	/^  struct merge_node *parent;    \/* Parent node. *\/$/;"	m	struct:merge_node	typeref:struct:merge_node::merge_node	file:	access:public
merge_node::queued	sort.c	/^  bool queued;                  \/* Node is already in heap. *\/$/;"	m	struct:merge_node	file:	access:public
merge_node_queue	sort.c	/^struct merge_node_queue$/;"	s	file:
merge_node_queue::cond	sort.c	/^  pthread_cond_t cond;          \/* Conditional wait for empty queue to populate$/;"	m	struct:merge_node_queue	file:	access:public
merge_node_queue::mutex	sort.c	/^  pthread_mutex_t mutex;        \/* Lock for queue operations. *\/$/;"	m	struct:merge_node_queue	file:	access:public
merge_node_queue::priority_queue	sort.c	/^  struct heap *priority_queue;  \/* Priority queue of merge tree nodes. *\/$/;"	m	struct:merge_node_queue	typeref:struct:merge_node_queue::heap	file:	access:public
merge_tree_destroy	sort.c	/^merge_tree_destroy (struct merge_node *merge_tree)$/;"	f	file:	signature:(struct merge_node *merge_tree)
merge_tree_init	sort.c	/^merge_tree_init (size_t nthreads, size_t nlines, struct line *dest)$/;"	f	file:	signature:(size_t nthreads, size_t nlines, struct line *dest)
mergefiles	sort.c	/^mergefiles (struct sortfile *files, size_t ntemps, size_t nfiles,$/;"	f	file:	signature:(struct sortfile *files, size_t ntemps, size_t nfiles, FILE *ofp, char const *output_file)
mergefps	sort.c	/^mergefps (struct sortfile *files, size_t ntemps, size_t nfiles,$/;"	f	file:	signature:(struct sortfile *files, size_t ntemps, size_t nfiles, FILE *ofp, char const *output_file, FILE **fps)
mergelines	sort.c	/^mergelines (struct line *restrict t, size_t nlines,$/;"	f	file:	signature:(struct line *restrict t, size_t nlines, struct line const *restrict lo)
mergelines_node	sort.c	/^mergelines_node (struct merge_node *restrict node, size_t total_lines,$/;"	f	file:	signature:(struct merge_node *restrict node, size_t total_lines, FILE *tfp, char const *temp_output)
millerrabin	factor.c	/^millerrabin (uintmax_t n, uintmax_t ni, uintmax_t b, uintmax_t q,$/;"	f	file:	signature:(uintmax_t n, uintmax_t ni, uintmax_t b, uintmax_t q, unsigned int k, uintmax_t one)
millerrabin2	factor.c	/^millerrabin2 (const uintmax_t *np, uintmax_t ni, const uintmax_t *bp,$/;"	f	file:	signature:(const uintmax_t *np, uintmax_t ni, const uintmax_t *bp, const uintmax_t *qp, unsigned int k, const uintmax_t *one)
min	comm.c	41;"	d	file:
min	comm.c	42;"	d	file:
min_digest_line_length	md5sum.c	/^static size_t min_digest_line_length;$/;"	v	file:
minor	system.h	73;"	d
minor_device_number_width	ls.c	/^static int minor_device_number_width;$/;"	v	file:
mkdir_options	mkdir.c	/^struct mkdir_options$/;"	s	file:
mkdir_options::ancestor_mode	mkdir.c	/^  mode_t ancestor_mode;$/;"	m	struct:mkdir_options	file:	access:public
mkdir_options::created_directory_format	mkdir.c	/^  char const *created_directory_format;$/;"	m	struct:mkdir_options	file:	access:public
mkdir_options::make_ancestor_function	mkdir.c	/^  int (*make_ancestor_function) (char const *, char const *, void *);$/;"	m	struct:mkdir_options	file:	access:public
mkdir_options::mode	mkdir.c	/^  mode_t mode;$/;"	m	struct:mkdir_options	file:	access:public
mkdir_options::mode_bits	mkdir.c	/^  mode_t mode_bits;$/;"	m	struct:mkdir_options	file:	access:public
mkdtemp_len	mktemp.c	/^mkdtemp_len (char *tmpl, size_t suff_len, size_t x_len, bool dry_run)$/;"	f	file:	signature:(char *tmpl, size_t suff_len, size_t x_len, bool dry_run)
mkfifo	copy.c	88;"	d	file:
mkfifo	system.h	37;"	d
mkstemp_len	mktemp.c	/^mkstemp_len (char *tmpl, size_t suff_len, size_t x_len, bool dry_run)$/;"	f	file:	signature:(char *tmpl, size_t suff_len, size_t x_len, bool dry_run)
mod2	factor.c	/^mod2 (uintmax_t *r1, uintmax_t a1, uintmax_t a0, uintmax_t d1, uintmax_t d0)$/;"	f	file:	signature:(uintmax_t *r1, uintmax_t a1, uintmax_t a0, uintmax_t d1, uintmax_t d0)
mode	copy.h	/^  mode_t mode;$/;"	m	struct:cp_options	access:public
mode	install.c	/^static mode_t mode = DEFAULT_MODE;$/;"	v	file:
mode	mkdir.c	/^  mode_t mode;$/;"	m	struct:mkdir_options	file:	access:public
mode	tail.c	/^  mode_t mode;$/;"	m	struct:File_spec	file:	access:public
mode_bits	mkdir.c	/^  mode_t mode_bits;$/;"	m	struct:mkdir_options	file:	access:public
mode_changed	chmod.c	/^mode_changed (char const *file, mode_t old_mode, mode_t new_mode)$/;"	f	file:	signature:(char const *file, mode_t old_mode, mode_t new_mode)
mode_info	stty.c	/^static struct mode_info const mode_info[] =$/;"	v	file:
mode_info	stty.c	/^struct mode_info$/;"	s	file:
mode_info::bits	stty.c	/^    unsigned long bits;		\/* Bits to set for this mode.  *\/$/;"	m	struct:mode_info	file:	access:public
mode_info::flags	stty.c	/^    char flags;			\/* Setting and display options.  *\/$/;"	m	struct:mode_info	file:	access:public
mode_info::mask	stty.c	/^    unsigned long mask;		\/* Other bits to turn off for this mode.  *\/$/;"	m	struct:mode_info	file:	access:public
mode_info::name	stty.c	/^    const char *name;		\/* Name given on command line.  *\/$/;"	m	struct:mode_info	file:	access:public
mode_info::type	stty.c	/^    enum mode_type type;	\/* Which structure element to change. *\/$/;"	m	struct:mode_info	typeref:enum:mode_info::mode_type	file:	access:public
mode_type	stty.c	/^enum mode_type$/;"	g	file:
mode_type_flag	stty.c	/^mode_type_flag (enum mode_type type, struct termios *mode)$/;"	f	file:	signature:(enum mode_type type, struct termios *mode)
mode_type_flag	stty.c	/^static tcflag_t *mode_type_flag (enum mode_type type, struct termios *mode);$/;"	p	file:	signature:(enum mode_type type, struct termios *mode)
monitored_pid	timeout.c	/^static int monitored_pid;$/;"	v	file:
month	sort.c	/^  bool month;			\/* Flag for comparison by month name. *\/$/;"	m	struct:keyfield	file:	access:public
month	sort.c	/^struct month$/;"	s	file:
month::name	sort.c	/^  char const *name;$/;"	m	struct:month	file:	access:public
month::val	sort.c	/^  int val;$/;"	m	struct:month	file:	access:public
monthtab	sort.c	/^static struct month monthtab[] =$/;"	v	typeref:struct:month	file:
mount_list	df.c	/^static struct mount_entry *mount_list;$/;"	v	typeref:struct:mount_entry	file:
move_fd_or_die	sort.c	/^move_fd_or_die (int oldfd, int newfd)$/;"	f	file:	signature:(int oldfd, int newfd)
move_mode	copy.h	/^  bool move_mode;$/;"	m	struct:cp_options	access:public
movefile	mv.c	/^movefile (char *source, char *dest, bool dest_is_dir,$/;"	f	file:	signature:(char *source, char *dest, bool dest_is_dir, const struct cp_options *x)
mp_factor	factor.c	/^mp_factor (mpz_t t, struct mp_factors *factors)$/;"	f	file:	signature:(mpz_t t, struct mp_factors *factors)
mp_factor	factor.c	/^static void mp_factor (mpz_t, struct mp_factors *);$/;"	p	file:	signature:(mpz_t, struct mp_factors *)
mp_factor_clear	factor.c	/^mp_factor_clear (struct mp_factors *factors)$/;"	f	file:	signature:(struct mp_factors *factors)
mp_factor_init	factor.c	/^mp_factor_init (struct mp_factors *factors)$/;"	f	file:	signature:(struct mp_factors *factors)
mp_factor_insert	factor.c	/^mp_factor_insert (struct mp_factors *factors, mpz_t prime)$/;"	f	file:	signature:(struct mp_factors *factors, mpz_t prime)
mp_factor_insert_ui	factor.c	/^mp_factor_insert_ui (struct mp_factors *factors, unsigned long int prime)$/;"	f	file:	signature:(struct mp_factors *factors, unsigned long int prime)
mp_factor_using_division	factor.c	/^mp_factor_using_division (mpz_t t, struct mp_factors *factors)$/;"	f	file:	signature:(mpz_t t, struct mp_factors *factors)
mp_factor_using_pollard_rho	factor.c	/^mp_factor_using_pollard_rho (mpz_t n, unsigned long int a,$/;"	f	file:	signature:(mpz_t n, unsigned long int a, struct mp_factors *factors)
mp_factors	factor.c	/^struct mp_factors$/;"	s	file:
mp_factors::e	factor.c	/^  unsigned long int *e;$/;"	m	struct:mp_factors	file:	access:public
mp_factors::nfactors	factor.c	/^  unsigned long int nfactors;$/;"	m	struct:mp_factors	file:	access:public
mp_factors::p	factor.c	/^  mpz_t             *p;$/;"	m	struct:mp_factors	file:	access:public
mp_millerrabin	factor.c	/^mp_millerrabin (mpz_srcptr n, mpz_srcptr nm1, mpz_ptr x, mpz_ptr y,$/;"	f	file:	signature:(mpz_srcptr n, mpz_srcptr nm1, mpz_ptr x, mpz_ptr y, mpz_srcptr q, unsigned long int k)
mp_prime_p	factor.c	/^mp_prime_p (mpz_t n)$/;"	f	file:	signature:(mpz_t n)
mpn_udiv_qrnnd	longlong.h	/^extern UWtype mpn_udiv_qrnnd (UWtype *, UWtype, UWtype, UWtype);$/;"	p	signature:(UWtype *, UWtype, UWtype, UWtype)
mpn_udiv_qrnnd	longlong.h	1890;"	d
mpn_udiv_qrnnd_r	longlong.h	/^extern UWtype mpn_udiv_qrnnd_r (UWtype, UWtype, UWtype, UWtype *);$/;"	p	signature:(UWtype, UWtype, UWtype, UWtype *)
mpn_udiv_qrnnd_r	longlong.h	1904;"	d
mpn_umul_ppmm	longlong.h	/^extern UWtype mpn_umul_ppmm (UWtype *, UWtype, UWtype);$/;"	p	signature:(UWtype *, UWtype, UWtype)
mpn_umul_ppmm	longlong.h	1864;"	d
mpn_umul_ppmm_r	longlong.h	/^extern UWtype mpn_umul_ppmm_r (UWtype, UWtype, UWtype *);$/;"	p	signature:(UWtype, UWtype, UWtype *)
mpn_umul_ppmm_r	longlong.h	1877;"	d
mpz_add	expr.c	/^mpz_add (mpz_t r, mpz_t a0, mpz_t b0)$/;"	f	file:	signature:(mpz_t r, mpz_t a0, mpz_t b0)
mpz_clear	expr.c	/^static void mpz_clear (mpz_t z) { (void) z; }$/;"	f	file:	signature:(mpz_t z)
mpz_clears	factor.c	561;"	d	file:
mpz_fits_ulong_p	expr.c	/^mpz_fits_ulong_p (mpz_t z)$/;"	f	file:	signature:(mpz_t z)
mpz_get_str	expr.c	/^mpz_get_str (char const *str, int base, mpz_t z)$/;"	f	file:	signature:(char const *str, int base, mpz_t z)
mpz_get_ui	expr.c	/^mpz_get_ui (mpz_t z)$/;"	f	file:	signature:(mpz_t z)
mpz_init_set_str	expr.c	/^mpz_init_set_str (mpz_t z, char *s, int base)$/;"	f	file:	signature:(mpz_t z, char *s, int base)
mpz_init_set_ui	expr.c	/^static void mpz_init_set_ui (mpz_t z, unsigned long int i) { z[0] = i; }$/;"	f	file:	signature:(mpz_t z, unsigned long int i)
mpz_inits	factor.c	560;"	d	file:
mpz_mul	expr.c	/^mpz_mul (mpz_t r, mpz_t a0, mpz_t b0)$/;"	f	file:	signature:(mpz_t r, mpz_t a0, mpz_t b0)
mpz_out_str	expr.c	/^mpz_out_str (FILE *stream, int base, mpz_t z)$/;"	f	file:	signature:(FILE *stream, int base, mpz_t z)
mpz_sgn	expr.c	/^mpz_sgn (mpz_t z)$/;"	f	file:	signature:(mpz_t z)
mpz_sub	expr.c	/^mpz_sub (mpz_t r, mpz_t a0, mpz_t b0)$/;"	f	file:	signature:(mpz_t r, mpz_t a0, mpz_t b0)
mpz_t	expr.c	/^typedef intmax_t mpz_t[1];$/;"	t	file:
mpz_tdiv_q	expr.c	/^mpz_tdiv_q (mpz_t r, mpz_t a0, mpz_t b0)$/;"	f	file:	signature:(mpz_t r, mpz_t a0, mpz_t b0)
mpz_tdiv_r	expr.c	/^mpz_tdiv_r (mpz_t r, mpz_t a0, mpz_t b0)$/;"	f	file:	signature:(mpz_t r, mpz_t a0, mpz_t b0)
mpz_va_init	factor.c	/^mpz_va_init (void (*mpz_single_init)(mpz_t), ...)$/;"	f	file:	signature:(void (*mpz_single_init)(mpz_t), ...)
mtime	tail.c	/^  struct timespec mtime;$/;"	m	struct:File_spec	typeref:struct:File_spec::timespec	file:	access:public
mulredc	factor.c	/^mulredc (uintmax_t a, uintmax_t b, uintmax_t m, uintmax_t mi)$/;"	f	file:	signature:(uintmax_t a, uintmax_t b, uintmax_t m, uintmax_t mi)
mulredc2	factor.c	/^mulredc2 (uintmax_t *r1p,$/;"	f	file:	signature:(uintmax_t *r1p, uintmax_t a1, uintmax_t a0, uintmax_t b1, uintmax_t b0, uintmax_t m1, uintmax_t m0, uintmax_t mi)
multiple_bits_set	dd.c	/^multiple_bits_set (int i)$/;"	f	file:	signature:(int i)
multiple_files	head.c	/^  multiple_files, always, never$/;"	e	enum:header_mode	file:
multiple_files	tail.c	/^  multiple_files, always, never$/;"	e	enum:header_mode	file:
mutex	sort.c	/^  pthread_mutex_t mutex;        \/* Lock for queue operations. *\/$/;"	m	struct:merge_node_queue	file:	access:public
my_line_only	who.c	/^static bool my_line_only;$/;"	v	file:
n_alloc	pwd.c	/^  size_t n_alloc;$/;"	m	struct:file_name	file:	access:public
n_bufs	tac-pipe.c	/^  size_t n_bufs;$/;"	m	struct:Buf	file:	access:public
n_bytes_to_skip	od.c	/^static uintmax_t n_bytes_to_skip = 0;$/;"	v	file:
n_indefinite_repeats	tr.c	/^    size_t n_indefinite_repeats;$/;"	m	struct:Spec_list	file:	access:public
n_iterations	shred.c	/^  size_t n_iterations;	\/* -n flag: Number of iterations *\/$/;"	m	struct:Options	file:	access:public
n_open_pipes	split.c	/^static size_t n_open_pipes;$/;"	v	file:
n_specs	od.c	/^static size_t n_specs;$/;"	v	file:
n_specs_allocated	od.c	/^static size_t n_specs_allocated;$/;"	v	file:
n_strings	tsort.c	/^static size_t n_strings = 0;$/;"	v	file:
n_tabs_allocated	expand.c	/^static size_t n_tabs_allocated;$/;"	v	file:
n_tabs_allocated	unexpand.c	/^static size_t n_tabs_allocated;$/;"	v	file:
n_unchanged_stats	tail.c	/^  uintmax_t n_unchanged_stats;$/;"	m	struct:File_spec	file:	access:public
name	cp-hash.c	/^  char *name;$/;"	m	struct:Src_to_dest	file:	access:public
name	ls.c	/^    char *name;$/;"	m	struct:fileinfo	file:	access:public
name	ls.c	/^    char *name;$/;"	m	struct:pending	file:	access:public
name	pr.c	/^    char const *name;		\/* File name. *\/$/;"	m	struct:COLUMN	file:	access:public
name	sort.c	/^  char const *name;$/;"	m	struct:month	file:	access:public
name	sort.c	/^  char const *name;$/;"	m	struct:sortfile	file:	access:public
name	sort.c	/^  char name[1];  \/* Actual size is 1 + file name length.  *\/$/;"	m	struct:tempnode	file:	access:public
name	stty.c	/^    const char *name;		\/* Name given on command line.  *\/$/;"	m	struct:control_info	file:	access:public
name	stty.c	/^    const char *name;		\/* Name given on command line.  *\/$/;"	m	struct:mode_info	file:	access:public
name	tail.c	/^  char *name;$/;"	m	struct:File_spec	file:	access:public
nameset	shred.c	/^static char const nameset[] =$/;"	v	file:
nan_compare	sort.c	/^nan_compare (char const *sa, char const *sb)$/;"	f	file:	signature:(char const *sa, char const *sb)
ncolumns	df.c	/^static size_t ncolumns;$/;"	v	file:
need_boottime	who.c	/^static bool need_boottime;$/;"	v	file:
need_clockchange	who.c	/^static bool need_clockchange;$/;"	v	file:
need_copy	install.c	/^need_copy (const char *src_name, const char *dest_name,$/;"	f	file:	signature:(const char *src_name, const char *dest_name, const struct cp_options *x)
need_deadprocs	who.c	/^static bool need_deadprocs;$/;"	v	file:
need_initspawn	who.c	/^static bool need_initspawn;$/;"	v	file:
need_login	who.c	/^static bool need_login;$/;"	v	file:
need_runlevel	who.c	/^static bool need_runlevel;$/;"	v	file:
need_users	who.c	/^static bool need_users;$/;"	v	file:
neg_to_zero	stat.c	/^neg_to_zero (struct timespec ts)$/;"	f	file:	signature:(struct timespec ts)
negate_available	df.c	/^  bool negate_available;$/;"	m	struct:field_values_t	file:	access:public
negate_used	df.c	/^  bool negate_used;$/;"	m	struct:field_values_t	file:	access:public
never	head.c	/^  multiple_files, always, never$/;"	e	enum:header_mode	file:
never	tail.c	/^  multiple_files, always, never$/;"	e	enum:header_mode	file:
new_control_record	csplit.c	/^new_control_record (void)$/;"	f	file:	signature:(void)
new_item	tsort.c	/^new_item (const char *str)$/;"	f	file:	signature:(const char *str)
new_line_control	csplit.c	/^new_line_control (void)$/;"	f	file:	signature:(void)
newblocked	split.c	/^static sigset_t newblocked;$/;"	v	file:
newline_character	dd.c	/^static char newline_character = '\\n';$/;"	v	file:
newlines2	cat.c	/^static int newlines2 = 0;$/;"	v	file:
newtime	touch.c	/^static struct timespec newtime[2];$/;"	v	typeref:struct:timespec	file:
next	cp.c	/^  struct dir_attr *next;$/;"	m	struct:dir_attr	typeref:struct:dir_attr::dir_attr	file:	access:public
next	csplit.c	/^  struct buffer_record *next;$/;"	m	struct:buffer_record	typeref:struct:buffer_record::buffer_record	file:	access:public
next	csplit.c	/^  struct line *next;		\/* Next in linked list. *\/$/;"	m	struct:line	typeref:struct:line::line	file:	access:public
next	df.c	/^  struct devlist *next;$/;"	m	struct:devlist	typeref:struct:devlist::devlist	file:	access:public
next	join.c	/^    struct outlist *next;$/;"	m	struct:outlist	typeref:struct:outlist::outlist	file:	access:public
next	ls.c	/^    struct color_ext_type *next;	\/* Next in list *\/$/;"	m	struct:color_ext_type	typeref:struct:color_ext_type::color_ext_type	file:	access:public
next	ls.c	/^    struct ignore_pattern *next;$/;"	m	struct:ignore_pattern	typeref:struct:ignore_pattern::ignore_pattern	file:	access:public
next	ls.c	/^    struct pending *next;$/;"	m	struct:pending	typeref:struct:pending::pending	file:	access:public
next	sort.c	/^  struct keyfield *next;	\/* Next keyfield to try. *\/$/;"	m	struct:keyfield	typeref:struct:keyfield::keyfield	file:	access:public
next	sort.c	/^  struct tempnode *volatile next;$/;"	m	struct:tempnode	file:	access:public
next	tr.c	/^    struct List_element *next;$/;"	m	struct:List_element	typeref:struct:List_element::List_element	file:	access:public
next	tsort.c	/^  struct successor *next;$/;"	m	struct:successor	typeref:struct:successor::successor	file:	access:public
next_break	fmt.c	/^    WORD *next_break;		\/* break which achieves best_cost *\/$/;"	m	struct:Word	file:	access:public
next_char	fmt.c	/^static int next_char;$/;"	v	file:
next_file	expand.c	/^next_file (FILE *fp)$/;"	f	file:	signature:(FILE *fp)
next_file	unexpand.c	/^next_file (FILE *fp)$/;"	f	file:	signature:(FILE *fp)
next_file_name	split.c	/^next_file_name (void)$/;"	f	file:	signature:(void)
next_line	shuf.c	/^next_line (char *line, char eolbyte, size_t n)$/;"	f	file:	signature:(char *line, char eolbyte, size_t n)
next_line_num	cat.c	/^next_line_num (void)$/;"	f	file:	signature:(void)
next_prefix_indent	fmt.c	/^static int next_prefix_indent;$/;"	v	file:
nextarg	expr.c	/^nextarg (char const *str)$/;"	f	file:	signature:(char const *str)
nfactors	factor.c	/^  unsigned char nfactors;$/;"	m	struct:factors	file:	access:public
nfactors	factor.c	/^  unsigned long int nfactors;$/;"	m	struct:mp_factors	file:	access:public
nfields	join.c	/^    size_t nfields;		\/* Number of elements in 'fields'.  *\/$/;"	m	struct:line	file:	access:public
nfields_allocated	join.c	/^    size_t nfields_allocated;	\/* Number of elements allocated for 'fields'. *\/$/;"	m	struct:line	file:	access:public
nhi	sort.c	/^  size_t nhi;                   \/* Total lines remaining from HI. *\/$/;"	m	struct:merge_node	file:	access:public
nl_file	nl.c	/^nl_file (char const *file)$/;"	f	file:	signature:(char const *file)
nlines	sort.c	/^  size_t nlines;		\/* Number of lines in the line array.  *\/$/;"	m	struct:buffer	file:	access:public
nlink_width	ls.c	/^static int nlink_width;$/;"	v	file:
nlo	sort.c	/^  size_t nlo;                   \/* Total Lines remaining from LO. *\/$/;"	m	struct:merge_node	file:	access:public
nmerge	sort.c	/^static unsigned int nmerge = NMERGE_DEFAULT;$/;"	v	file:
no_create	touch.c	/^static bool no_create;$/;"	v	file:
no_create	truncate.c	/^static bool no_create;$/;"	v	file:
no_dereference	touch.c	/^static bool no_dereference;$/;"	v	file:
no_install__progs	cu-progs.mk	/^no_install__progs =$/;"	m
no_leading_hyphen	pathchk.c	/^no_leading_hyphen (char const *file)$/;"	f	file:	signature:(char const *file)
no_more_lines	csplit.c	/^no_more_lines (void)$/;"	f	file:	signature:(void)
no_newline	readlink.c	/^static bool no_newline;$/;"	v	file:
node	sort.c	/^  struct merge_node *const node;$/;"	m	struct:thread_args	file:	access:public
nodist_src_libver_a_SOURCES	local.mk	/^nodist_src_libver_a_SOURCES = src\/version.c src\/version.h$/;"	m
noinst_HEADERS	local.mk	/^noinst_HEADERS =		\\$/;"	m
noinst_PROGRAMS	local.mk	/^noinst_PROGRAMS =		\\$/;"	m
nomoreargs	expr.c	/^nomoreargs (void)$/;"	f	file:	signature:(void)
nomoreargs	expr.c	/^static bool nomoreargs (void);$/;"	p	file:	signature:(void)
nondictionary	sort.c	/^static bool nondictionary[UCHAR_LIM];$/;"	v	file:
none	ls.c	/^    none,	\/*     --indicator-style=none *\/$/;"	e	enum:indicator_style	file:
nonexistent_file_errno	remove.c	/^nonexistent_file_errno (int errnum)$/;"	f	file:	signature:(int errnum)
nonprinting	sort.c	/^static bool nonprinting[UCHAR_LIM];$/;"	v	file:
normal	ls.c	/^    normal,$/;"	e	enum:filetype	file:
normal_char	tr.c	/^        unsigned char normal_char;$/;"	m	union:List_element::__anon3	file:	access:public
nprocs	sort.c	/^static pid_t nprocs;$/;"	v	file:
nrows	df.c	/^static size_t nrows;$/;"	v	file:
nth_parent	pwd.c	/^nth_parent (size_t n)$/;"	f	file:	signature:(size_t n)
nthreads	sort.c	/^  size_t nthreads;$/;"	m	struct:thread_args	file:	access:public
null	expr.c	/^null (VALUE *v)$/;"	f	file:	signature:(VALUE *v)
null	expr.c	/^static bool null (VALUE *v);$/;"	p	file:	signature:(VALUE *v)
num_lines	csplit.c	/^  size_t num_lines;		\/* Number of complete lines in this buffer. *\/$/;"	m	struct:buffer_record	file:	access:public
number_buff	pr.c	/^static char *number_buff;$/;"	v	file:
number_input_files	ptx.c	/^static int number_input_files;	\/* number of text input files *\/$/;"	v	file:
number_of_occurs	ptx.c	/^static size_t number_of_occurs[1]; \/* number of used slots in occurs_table *\/$/;"	v	file:
number_separator	pr.c	/^static char number_separator = '\\t';$/;"	v	file:
number_width	pr.c	/^static int number_width;$/;"	v	file:
number_width	wc.c	/^static int number_width;$/;"	v	file:
numbered	pr.c	/^    bool numbered;$/;"	m	struct:COLUMN	file:	access:public
numbered_lines	pr.c	/^static bool numbered_lines = false;$/;"	v	file:
numcompare	sort.c	/^numcompare (char const *a, char const *b)$/;"	f	file:	signature:(char const *a, char const *b)
numeric	sort.c	/^  bool numeric;			\/* Flag for numeric comparison.  Handle$/;"	m	struct:keyfield	file:	access:public
numeric_ids	ls.c	/^static bool numeric_ids;$/;"	v	file:
numeric_suffix_start	split.c	/^static const char *numeric_suffix_start;$/;"	v	file:
o_nocache	dd.c	/^static bool i_nocache, o_nocache;$/;"	v	file:
obs	tac-pipe.c	/^  struct obstack obs;$/;"	m	struct:Buf	typeref:struct:Buf::obstack	file:	access:public
obsolete_used	sort.c	/^  bool obsolete_used;		\/* obsolescent key option format is used. *\/$/;"	m	struct:keyfield	file:	access:public
obstack_chunk_alloc	dircolors.c	37;"	d	file:
obstack_chunk_alloc	ls.c	126;"	d	file:
obstack_chunk_free	dircolors.c	38;"	d	file:
obstack_chunk_free	ls.c	127;"	d	file:
obuf	dd.c	/^static char *obuf;$/;"	v	file:
oc	dd.c	/^static size_t oc = 0;$/;"	v	file:
occurs_alloc	ptx.c	/^static size_t occurs_alloc[1];	\/* allocated size of occurs_table *\/$/;"	v	file:
occurs_table	ptx.c	/^static OCCURS *occurs_table[1];	\/* all words retained from the read text *\/$/;"	v	file:
octtobin	printf.c	68;"	d	file:
octtobin	stat.c	157;"	d	file:
of_info	split.c	/^typedef struct of_info$/;"	s	file:
of_info::of_name	split.c	/^  char *of_name;$/;"	m	struct:of_info	file:	access:public
of_info::ofd	split.c	/^  int ofd;$/;"	m	struct:of_info	file:	access:public
of_info::ofile	split.c	/^  FILE *ofile;$/;"	m	struct:of_info	file:	access:public
of_info::opid	split.c	/^  int opid;$/;"	m	struct:of_info	file:	access:public
of_name	split.c	/^  char *of_name;$/;"	m	struct:of_info	file:	access:public
of_t	split.c	/^} of_t;$/;"	t	typeref:struct:of_info	file:
ofd	split.c	/^  int ofd;$/;"	m	struct:of_info	file:	access:public
offset	csplit.c	/^  intmax_t offset;		\/* Offset from regexp to split at. *\/$/;"	m	struct:control	file:	access:public
offset	stty.c	/^    size_t offset;		\/* Offset in c_cc.  *\/$/;"	m	struct:control_info	file:	access:public
ofile	split.c	/^  FILE *ofile;$/;"	m	struct:of_info	file:	access:public
ofile_open	split.c	/^ofile_open (of_t *files, size_t i_check, size_t nfiles)$/;"	f	file:	signature:(of_t *files, size_t i_check, size_t nfiles)
ok	id.c	/^static bool ok = true;$/;"	v	file:
oldblocked	split.c	/^static sigset_t oldblocked;$/;"	v	file:
one_argument	test.c	/^one_argument (void)$/;"	f	file:	signature:(void)
one_file_system	copy.h	/^  bool one_file_system;$/;"	m	struct:cp_options	access:public
one_file_system	remove.h	/^  bool one_file_system;$/;"	m	struct:rm_options	access:public
one_past_end	tac-pipe.c	/^  char *one_past_end;$/;"	m	struct:B_pair	file:	access:public
one_per_line	ls.c	/^    one_per_line,		\/* -1 *\/$/;"	e	enum:format	file:
only_file	ptx.c	/^static const char *only_file = NULL;	\/* name of the 'Only words' file *\/$/;"	v	file:
only_file_1	comm.c	/^static bool only_file_1;$/;"	v	file:
only_file_2	comm.c	/^static bool only_file_2;$/;"	v	file:
only_table	ptx.c	/^static WORD_TABLE only_table;		\/* table of words to select *\/$/;"	v	file:
open_dangling_dest_symlink	copy.h	/^  bool open_dangling_dest_symlink;$/;"	m	struct:cp_options	access:public
open_file	pr.c	/^open_file (char *name, COLUMN *p)$/;"	f	file:	signature:(char *name, COLUMN *p)
open_file	pr.c	/^static bool open_file (char *name, COLUMN *p);$/;"	p	file:	signature:(char *name, COLUMN *p)
open_input_files	sort.c	/^open_input_files (struct sortfile *files, size_t nfiles, FILE ***pfps)$/;"	f	file:	signature:(struct sortfile *files, size_t nfiles, FILE ***pfps)
open_next_file	od.c	/^open_next_file (void)$/;"	f	file:	signature:(void)
open_pipes	split.c	/^static int *open_pipes;$/;"	v	file:
open_pipes_alloc	split.c	/^static size_t open_pipes_alloc;$/;"	v	file:
open_temp	sort.c	/^open_temp (struct tempnode *temp)$/;"	f	file:	signature:(struct tempnode *temp)
operand	seq.c	/^struct operand$/;"	s	file:
operand	seq.c	/^typedef struct operand operand;$/;"	t	typeref:struct:operand	file:
operand2sig	operand2sig.c	/^operand2sig (char const *operand, char *signame)$/;"	f	signature:(char const *operand, char *signame)
operand2sig	operand2sig.h	/^extern int operand2sig (char const *operand, char *signame);$/;"	p	signature:(char const *operand, char *signame)
operand::precision	seq.c	/^  int precision;$/;"	m	struct:operand	file:	access:public
operand::value	seq.c	/^  long double value;$/;"	m	struct:operand	file:	access:public
operand::width	seq.c	/^  size_t width;$/;"	m	struct:operand	file:	access:public
operand_is	dd.c	/^operand_is (char const *operand, char const *name)$/;"	f	file:	signature:(char const *operand, char const *name)
operand_matches	dd.c	/^operand_matches (char const *str, char const *pattern, char delim)$/;"	f	file:	signature:(char const *str, char const *pattern, char delim)
operand_status	join.c	/^enum operand_status$/;"	g	file:
operating_mode	cut.c	/^enum operating_mode$/;"	g	file:
operating_mode	cut.c	/^static enum operating_mode operating_mode;$/;"	v	typeref:enum:operating_mode	file:
opid	split.c	/^  int opid;$/;"	m	struct:of_info	file:	access:public
opt_all	du.c	/^static bool opt_all = false;$/;"	v	file:
opt_count_all	du.c	/^static bool opt_count_all = false;$/;"	v	file:
opt_nul_terminate_output	du.c	/^static bool opt_nul_terminate_output = false;$/;"	v	file:
opt_separate_dirs	du.c	/^static bool opt_separate_dirs = false;$/;"	v	file:
opt_threshold	du.c	/^static intmax_t opt_threshold = 0;$/;"	v	file:
opt_time	du.c	/^static bool opt_time = false;$/;"	v	file:
optarg	stdbuf.c	/^  char *optarg;$/;"	m	struct:__anon20	file:	access:public
optc	stdbuf.c	/^  int optc;$/;"	m	struct:__anon20	file:	access:public
optc_to_fileno	stdbuf.c	/^optc_to_fileno (int c)$/;"	f	file:	signature:(int c)
or	test.c	/^or (void)$/;"	f	file:	signature:(void)
or	test.c	/^static bool or (void);$/;"	p	file:	signature:(void)
other_indent	fmt.c	/^static int other_indent;$/;"	v	file:
out_column	fmt.c	/^static int out_column;$/;"	v	file:
out_epoch_sec	stat.c	/^out_epoch_sec (char *pformat, size_t prefix_len,$/;"	f	file:	signature:(char *pformat, size_t prefix_len, struct stat const *statbuf ATTRIBUTE_UNUSED, struct timespec arg)
out_file_context	stat.c	/^out_file_context (char *pformat, size_t prefix_len, char const *filename)$/;"	f	file:	signature:(char *pformat, size_t prefix_len, char const *filename)
out_int	stat.c	/^out_int (char *pformat, size_t prefix_len, intmax_t arg)$/;"	f	file:	signature:(char *pformat, size_t prefix_len, intmax_t arg)
out_minus_zero	stat.c	/^out_minus_zero (char *pformat, size_t prefix_len)$/;"	f	file:	signature:(char *pformat, size_t prefix_len)
out_mount_point	stat.c	/^out_mount_point (char const *filename, char *pformat, size_t prefix_len,$/;"	f	file:	signature:(char const *filename, char *pformat, size_t prefix_len, const struct stat *statp)
out_string	stat.c	/^out_string (char *pformat, size_t prefix_len, char const *arg)$/;"	f	file:	signature:(char *pformat, size_t prefix_len, char const *arg)
out_uint	stat.c	/^out_uint (char *pformat, size_t prefix_len, uintmax_t arg)$/;"	f	file:	signature:(char *pformat, size_t prefix_len, uintmax_t arg)
out_uint_o	stat.c	/^out_uint_o (char *pformat, size_t prefix_len, uintmax_t arg)$/;"	f	file:	signature:(char *pformat, size_t prefix_len, uintmax_t arg)
out_uint_x	stat.c	/^out_uint_x (char *pformat, size_t prefix_len, uintmax_t arg)$/;"	f	file:	signature:(char *pformat, size_t prefix_len, uintmax_t arg)
outbase	split.c	/^static char const *outbase;$/;"	v	file:
outfile	split.c	/^static char *outfile;$/;"	v	file:
outfile_mid	split.c	/^static char *outfile_mid;$/;"	v	file:
outlist	join.c	/^struct outlist$/;"	s	file:
outlist::field	join.c	/^    size_t field;$/;"	m	struct:outlist	file:	access:public
outlist::file	join.c	/^    int file;$/;"	m	struct:outlist	file:	access:public
outlist::next	join.c	/^    struct outlist *next;$/;"	m	struct:outlist	typeref:struct:outlist::outlist	file:	access:public
outlist_end	join.c	/^static struct outlist *outlist_end = &outlist_head;$/;"	v	typeref:struct:outlist	file:
outlist_head	join.c	/^static struct outlist outlist_head;$/;"	v	typeref:struct:outlist	file:
output	stty.c	/^    control, input, output, local, combination$/;"	e	enum:mode_type	file:
output	tac.c	/^output (const char *start, const char *past_end)$/;"	f	file:	signature:(const char *start, const char *past_end)
output_block_size	df.c	/^static uintmax_t output_block_size;$/;"	v	file:
output_block_size	du.c	/^static uintmax_t output_block_size;$/;"	v	file:
output_block_size	ls.c	/^static uintmax_t output_block_size;$/;"	v	file:
output_blocksize	dd.c	/^static size_t output_blocksize = 0;$/;"	v	file:
output_char	dd.c	82;"	d	file:
output_delimiter_length	cut.c	/^static size_t output_delimiter_length;$/;"	v	file:
output_delimiter_specified	cut.c	/^static bool output_delimiter_specified;$/;"	v	file:
output_delimiter_string	cut.c	/^static char *output_delimiter_string;$/;"	v	file:
output_desc	split.c	/^static int output_desc = -1;$/;"	v	file:
output_file	dd.c	/^static char const *output_file = NULL;$/;"	v	file:
output_filename	csplit.c	/^static char *output_filename = NULL;$/;"	v	file:
output_first_repeated	uniq.c	/^static bool output_first_repeated;$/;"	v	file:
output_flags	dd.c	/^static int output_flags = 0;$/;"	v	file:
output_format	od.c	/^enum output_format$/;"	g	file:
output_format	ptx.c	/^static enum Format output_format = UNKNOWN_FORMAT;$/;"	v	typeref:enum:Format	file:
output_later_repeated	uniq.c	/^static bool output_later_repeated;$/;"	v	file:
output_one_dumb_line	ptx.c	/^output_one_dumb_line (void)$/;"	f	file:	signature:(void)
output_one_roff_line	ptx.c	/^output_one_roff_line (void)$/;"	f	file:	signature:(void)
output_one_tex_line	ptx.c	/^output_one_tex_line (void)$/;"	f	file:	signature:(void)
output_position	pr.c	/^static int output_position;$/;"	v	file:
output_primes	make-prime-list.c	/^output_primes (const struct prime *primes, unsigned nprimes)$/;"	f	file:	signature:(const struct prime *primes, unsigned nprimes)
output_speed	stty.c	/^    input_speed, output_speed, both_speeds$/;"	e	enum:speed_setting	file:
output_stream	csplit.c	/^static FILE *output_stream = NULL;$/;"	v	file:
output_tab_char	pr.c	/^static char output_tab_char = '\\t';$/;"	v	file:
output_temp	sort.c	/^  char const *output_temp;$/;"	m	struct:thread_args	file:	access:public
output_type	stty.c	/^enum output_type$/;"	g	file:
output_unique	uniq.c	/^static bool output_unique;$/;"	v	file:
output_units	df.c	/^  uintmax_t output_units;$/;"	m	struct:field_values_t	file:	access:public
overwrite_prompt	copy.c	/^overwrite_prompt (char const *dst_name, struct stat const *dst_sb)$/;"	f	file:	signature:(char const *dst_name, struct stat const *dst_sb)
owner_failure_ok	copy.c	/^owner_failure_ok (struct cp_options const *x)$/;"	f	file:	signature:(struct cp_options const *x)
owner_failure_ok	copy.c	/^static bool owner_failure_ok (struct cp_options const *x);$/;"	p	file:	signature:(struct cp_options const *x)
owner_id	install.c	/^static uid_t owner_id;$/;"	v	file:
owner_name	install.c	/^static char *owner_name;$/;"	v	file:
owner_privileges	copy.h	/^  bool owner_privileges;$/;"	m	struct:cp_options	access:public
owner_width	ls.c	/^static int owner_width;$/;"	v	file:
p	factor.c	/^  mpz_t             *p;$/;"	m	struct:mp_factors	file:	access:public
p	factor.c	/^  uintmax_t     p[MAX_NFACTS];$/;"	m	struct:factors	file:	access:public
p	make-prime-list.c	/^  unsigned p;$/;"	m	struct:prime	file:	access:public
p	tac-pipe.c	/^  struct B_pair *p;$/;"	m	struct:Buf	typeref:struct:Buf::B_pair	file:	access:public
pad_across_to	pr.c	/^pad_across_to (int position)$/;"	f	file:	signature:(int position)
pad_across_to	pr.c	/^static void pad_across_to (int position);$/;"	p	file:	signature:(int position)
pad_down	pr.c	/^pad_down (int lines)$/;"	f	file:	signature:(int lines)
pad_down	pr.c	/^static void pad_down (int lines);$/;"	p	file:	signature:(int lines)
pad_vertically	pr.c	/^static bool pad_vertically;$/;"	v	file:
pad_width	od.c	/^    int pad_width; \/* Total padding to be divided among fields.  *\/$/;"	m	struct:tspec	file:	access:public
padding_alignment	numfmt.c	/^static mbs_align_t padding_alignment = MBS_ALIGN_RIGHT;$/;"	v	file:
padding_buffer	numfmt.c	/^static char *padding_buffer = NULL;$/;"	v	file:
padding_buffer_size	numfmt.c	/^static size_t padding_buffer_size = 0;$/;"	v	file:
padding_not_printed	pr.c	/^static int padding_not_printed;$/;"	v	file:
padding_width	numfmt.c	/^static long int padding_width = 0;$/;"	v	file:
page_incr	nl.c	/^static intmax_t page_incr = 1;$/;"	v	file:
page_number	pr.c	/^static uintmax_t page_number;$/;"	v	file:
page_size	dd.c	/^static size_t page_size;$/;"	v	file:
parabuf	fmt.c	/^static char parabuf[MAXCHARS];$/;"	v	file:
parallel_files	pr.c	/^static bool parallel_files = false;$/;"	v	file:
paren	fmt.c	/^    unsigned int paren:1;	\/* starts with open paren *\/$/;"	m	struct:Word	file:	access:public
parent	copy.c	/^  struct dir_list *parent;$/;"	m	struct:dir_list	typeref:struct:dir_list::dir_list	file:	access:public
parent	sort.c	/^  struct merge_node *parent;    \/* Parent node. *\/$/;"	m	struct:merge_node	typeref:struct:merge_node::merge_node	file:	access:public
parent_wd	tail.c	/^  int parent_wd;$/;"	m	struct:File_spec	file:	access:public
parents_option	cp.c	/^static bool parents_option = false;$/;"	v	file:
parse_chunk	split.c	/^parse_chunk (uintmax_t *k_units, uintmax_t *n_units, char *slash)$/;"	f	file:	signature:(uintmax_t *k_units, uintmax_t *n_units, char *slash)
parse_column_count	pr.c	/^parse_column_count (char const *s)$/;"	f	file:	signature:(char const *s)
parse_duration	timeout.c	/^parse_duration (const char* str)$/;"	f	file:	signature:(const char* str)
parse_field_count	sort.c	/^parse_field_count (char const *string, size_t *val, char const *msgid)$/;"	f	file:	signature:(char const *string, size_t *val, char const *msgid)
parse_format_string	numfmt.c	/^parse_format_string (char const *fmt)$/;"	f	file:	signature:(char const *fmt)
parse_group	chgrp.c	/^parse_group (const char *name)$/;"	f	file:	signature:(const char *name)
parse_human_number	numfmt.c	/^parse_human_number (const char *str, long double \/*output *\/ *value,$/;"	f	file:	signature:(const char *str, long double *value, size_t *precision)
parse_integer	dd.c	/^parse_integer (const char *str, bool *invalid)$/;"	f	file:	signature:(const char *str, bool *invalid)
parse_len	truncate.c	/^parse_len (char const *str, off_t *size)$/;"	f	file:	signature:(char const *str, off_t *size)
parse_line	dircolors.c	/^parse_line (char const *line, char **keyword, char **arg)$/;"	f	file:	signature:(char const *line, char **keyword, char **arg)
parse_ls_color	ls.c	/^parse_ls_color (void)$/;"	f	file:	signature:(void)
parse_ls_color	ls.c	/^static void parse_ls_color (void);$/;"	p	file:	signature:(void)
parse_obsolete_option	tail.c	/^parse_obsolete_option (int argc, char * const *argv, uintmax_t *n_units)$/;"	f	file:	signature:(int argc, char * const *argv, uintmax_t *n_units)
parse_old_offset	od.c	/^parse_old_offset (const char *s, uintmax_t *offset)$/;"	f	file:	signature:(const char *s, uintmax_t *offset)
parse_options	tail.c	/^parse_options (int argc, char **argv,$/;"	f	file:	signature:(int argc, char **argv, uintmax_t *n_units, enum header_mode *header_mode, double *sleep_interval)
parse_patterns	csplit.c	/^parse_patterns (int argc, int start, char **argv)$/;"	f	file:	signature:(int argc, int start, char **argv)
parse_repeat_count	csplit.c	/^parse_repeat_count (int argnum, struct control *p, char *str)$/;"	f	file:	signature:(int argnum, struct control *p, char *str)
parse_size	stdbuf.c	/^parse_size (char const *str, size_t *size)$/;"	f	file:	signature:(char const *str, size_t *size)
parse_state	ls.c	/^enum parse_state$/;"	g	file:
parse_str	tr.c	/^parse_str (char const *s, struct Spec_list *spec_list)$/;"	f	file:	signature:(char const *s, struct Spec_list *spec_list)
parse_symbols	dd.c	/^parse_symbols (char const *str, struct symbol_value const *table,$/;"	f	file:	signature:(char const *str, struct symbol_value const *table, char const *error_msgid)
parse_tab_stops	expand.c	/^parse_tab_stops (char const *stops)$/;"	f	file:	signature:(char const *stops)
parse_tab_stops	unexpand.c	/^parse_tab_stops (char const *stops)$/;"	f	file:	signature:(char const *stops)
passname	shred.c	/^passname (unsigned char const *data, char name[PASS_NAME_SIZE])$/;"	f	file:	signature:(unsigned char const *data, char name[PASS_NAME_SIZE])
paste_parallel	paste.c	/^paste_parallel (size_t nfiles, char **fnamptr)$/;"	f	file:	signature:(size_t nfiles, char **fnamptr)
paste_serial	paste.c	/^paste_serial (size_t nfiles, char **fnamptr)$/;"	f	file:	signature:(size_t nfiles, char **fnamptr)
path_common_prefix	relpath.c	/^path_common_prefix (const char *path1, const char *path2)$/;"	f	file:	signature:(const char *path1, const char *path2)
path_prefix	realpath.c	/^path_prefix (const char *prefix, const char *path)$/;"	f	file:	signature:(const char *prefix, const char *path)
pathconf	pathchk.c	60;"	d	file:
pattern	ls.c	/^    const char *pattern;$/;"	m	struct:ignore_pattern	file:	access:public
pattern	ptx.c	/^  struct re_pattern_buffer pattern;$/;"	m	struct:regex_data	typeref:struct:regex_data::re_pattern_buffer	file:	access:public
patterns	shred.c	/^  patterns[] =$/;"	v	file:
patterns_match	ls.c	/^patterns_match (struct ignore_pattern const *patterns, char const *file)$/;"	f	file:	signature:(struct ignore_pattern const *patterns, char const *file)
pending	ls.c	/^struct pending$/;"	s	file:
pending::command_line_arg	ls.c	/^    bool command_line_arg;$/;"	m	struct:pending	file:	access:public
pending::name	ls.c	/^    char *name;$/;"	m	struct:pending	file:	access:public
pending::next	ls.c	/^    struct pending *next;$/;"	m	struct:pending	typeref:struct:pending::pending	file:	access:public
pending::realname	ls.c	/^    char *realname;$/;"	m	struct:pending	file:	access:public
pending_dirs	ls.c	/^static struct pending *pending_dirs;$/;"	v	typeref:struct:pending	file:
perform_basename	basename.c	/^perform_basename (const char *string, const char *suffix, bool use_nuls)$/;"	f	file:	signature:(const char *string, const char *suffix, bool use_nuls)
period	fmt.c	/^    unsigned int period:1;	\/* ends in [.?!])* *\/$/;"	m	struct:Word	file:	access:public
perm_related_errno	nice.c	/^perm_related_errno (int err)$/;"	f	file:	signature:(int err)
pid	sort.c	/^  pid_t pid;     \/* The subprocess PID; undefined if state == UNCOMPRESSED.  *\/$/;"	m	struct:tempnode	file:	access:public
pid	tail.c	/^static pid_t pid;$/;"	v	file:
pinv	make-prime-list.c	/^  wide_uint pinv; \/* Inverse mod b = 2^{bitsize of wide_uint} *\/$/;"	m	struct:prime	file:	access:public
pipe_bytes	tail.c	/^pipe_bytes (const char *pretty_filename, int fd, uintmax_t n_bytes,$/;"	f	file:	signature:(const char *pretty_filename, int fd, uintmax_t n_bytes, uintmax_t *read_pos)
pipe_fork	sort.c	/^pipe_fork (int pipefds[2], size_t tries)$/;"	f	file:	signature:(int pipefds[2], size_t tries)
pipe_lines	tail.c	/^pipe_lines (const char *pretty_filename, int fd, uintmax_t n_lines,$/;"	f	file:	signature:(const char *pretty_filename, int fd, uintmax_t n_lines, uintmax_t *read_pos)
pkglibexec_PROGRAMS	local.mk	/^pkglibexec_PROGRAMS = @pkglibexec_PROGRAMS@$/;"	m
plain_read	tr.c	/^plain_read (char *buf, size_t size)$/;"	f	file:	signature:(char *buf, size_t size)
plarge	factor.c	/^  uintmax_t     plarge[2]; \/* Can have a single large factor *\/$/;"	m	struct:factors	file:	access:public
pm	local.mk	/^pm = progs-makefile$/;"	m
portable_chars_only	pathchk.c	/^portable_chars_only (char const *file, size_t filelen)$/;"	f	file:	signature:(char const *file, size_t filelen)
pos	test.c	/^static int pos;		\/* The offset of the current argument in ARGV. *\/$/;"	v	file:
posixly_correct	printf.c	/^static bool posixly_correct;$/;"	v	file:
posixtest	test.c	/^posixtest (int nargs)$/;"	f	file:	signature:(int nargs)
posixtest	test.c	/^static bool posixtest (int);$/;"	p	file:	signature:(int)
powerld	numfmt.c	/^powerld (long double base, unsigned int x)$/;"	f	file:	signature:(long double base, unsigned int x)
powm	factor.c	/^powm (uintmax_t b, uintmax_t e, uintmax_t n, uintmax_t ni, uintmax_t one)$/;"	f	file:	signature:(uintmax_t b, uintmax_t e, uintmax_t n, uintmax_t ni, uintmax_t one)
powm2	factor.c	/^powm2 (uintmax_t *r1m,$/;"	f	file:	signature:(uintmax_t *r1m, const uintmax_t *bp, const uintmax_t *ep, const uintmax_t *np, uintmax_t ni, const uintmax_t *one)
pr	local.mk	/^pr = progs-readme$/;"	m
precision	seq.c	/^  int precision;$/;"	m	struct:operand	file:	access:public
prefix	csplit.c	/^static char const *volatile prefix = NULL;$/;"	v	file:
prefix	fmt.c	/^static const char *prefix;$/;"	v	file:
prefix_full_length	fmt.c	/^static int prefix_full_length;$/;"	v	file:
prefix_indent	fmt.c	/^static int prefix_indent;$/;"	v	file:
prefix_lead_space	fmt.c	/^static int prefix_lead_space;$/;"	v	file:
prefix_len	seq.c	/^  size_t prefix_len;$/;"	m	struct:layout	file:	access:public
prefix_length	fmt.c	/^static int prefix_length;$/;"	v	file:
prep_non_filename_text	ls.c	/^prep_non_filename_text (void)$/;"	f	file:	signature:(void)
prep_non_filename_text	ls.c	/^static void prep_non_filename_text (void);$/;"	p	file:	signature:(void)
prepare_padded_number	numfmt.c	/^prepare_padded_number (const long double val, size_t precision)$/;"	f	file:	signature:(const long double val, size_t precision)
preserve_links	copy.h	/^  bool preserve_links;$/;"	m	struct:cp_options	access:public
preserve_mode	copy.h	/^  bool preserve_mode;$/;"	m	struct:cp_options	access:public
preserve_ownership	copy.h	/^  bool preserve_ownership;$/;"	m	struct:cp_options	access:public
preserve_security_context	copy.h	/^  bool preserve_security_context;$/;"	m	struct:cp_options	access:public
preserve_status	timeout.c	/^static bool preserve_status; \/* whether to use a timeout status or not.  *\/$/;"	v	file:
preserve_timestamps	copy.h	/^  bool preserve_timestamps;$/;"	m	struct:cp_options	access:public
preserve_xattr	copy.h	/^  bool preserve_xattr;$/;"	m	struct:cp_options	access:public
presume_input_pipe	head.c	/^static bool presume_input_pipe;$/;"	v	file:
presume_input_pipe	tail.c	/^static bool presume_input_pipe;$/;"	v	file:
pretty_name	tail.c	/^pretty_name (struct File_spec const *f)$/;"	f	file:	signature:(struct File_spec const *f)
prev_level	du.c	/^static size_t prev_level;$/;"	v	file:
prevline	join.c	/^static struct line *prevline[2] = {NULL, NULL};$/;"	v	typeref:struct:line	file:
prfield	join.c	/^prfield (size_t n, struct line const *line)$/;"	f	file:	signature:(size_t n, struct line const *line)
prfields	join.c	/^prfields (struct line const *line, size_t join_field, size_t autocount)$/;"	f	file:	signature:(struct line const *line, size_t join_field, size_t autocount)
prime	make-prime-list.c	/^struct prime$/;"	s	file:
prime2_p	factor.c	/^prime2_p (uintmax_t n1, uintmax_t n0)$/;"	f	file:	signature:(uintmax_t n1, uintmax_t n0)
prime::lim	make-prime-list.c	/^  wide_uint lim; \/* floor ((wide_uint) -1 \/ p) *\/$/;"	m	struct:prime	file:	access:public
prime::p	make-prime-list.c	/^  unsigned p;$/;"	m	struct:prime	file:	access:public
prime::pinv	make-prime-list.c	/^  wide_uint pinv; \/* Inverse mod b = 2^{bitsize of wide_uint} *\/$/;"	m	struct:prime	file:	access:public
prime_p	factor.c	/^prime_p (uintmax_t n)$/;"	f	file:	signature:(uintmax_t n)
primes_diff	factor.c	/^static const unsigned char primes_diff[] = {$/;"	v	file:
primes_diff8	factor.c	/^static const unsigned char primes_diff8[] = {$/;"	v	file:
primes_dtab	factor.c	/^static const struct primes_dtab primes_dtab[] = {$/;"	v	typeref:struct:primes_dtab	file:
primes_dtab	factor.c	/^struct primes_dtab$/;"	s	file:
primes_dtab::binv	factor.c	/^  uintmax_t binv, lim;$/;"	m	struct:primes_dtab	file:	access:public
primes_dtab::lim	factor.c	/^  uintmax_t binv, lim;$/;"	m	struct:primes_dtab	file:	access:public
print_a_FF	pr.c	/^static bool print_a_FF = false;$/;"	v	file:
print_a_header	pr.c	/^static bool print_a_header;$/;"	v	file:
print_across_flag	pr.c	/^static bool print_across_flag = false;$/;"	v	file:
print_ascii	od.c	/^print_ascii (size_t fields, size_t blank, void const *block,$/;"	f	file:	signature:(size_t fields, size_t blank, void const *block, const char *unused_fmt_string ATTRIBUTE_UNUSED, int width, int pad)
print_author	ls.c	/^static bool print_author;$/;"	v	file:
print_block_size	ls.c	/^static bool print_block_size;$/;"	v	file:
print_boottime	who.c	/^print_boottime (const STRUCT_UTMP *utmp_ent)$/;"	f	file:	signature:(const STRUCT_UTMP *utmp_ent)
print_bytes	wc.c	/^static bool print_lines, print_words, print_chars, print_bytes;$/;"	v	file:
print_char	pr.c	/^print_char (char c)$/;"	f	file:	signature:(char c)
print_char	pr.c	/^static void print_char (char c);$/;"	p	file:	signature:(char c)
print_chars	wc.c	/^static bool print_lines, print_words, print_chars, print_bytes;$/;"	v	file:
print_clockchange	who.c	/^print_clockchange (const STRUCT_UTMP *utmp_ent)$/;"	f	file:	signature:(const STRUCT_UTMP *utmp_ent)
print_clump	pr.c	/^print_clump (COLUMN *p, int n, char *clump)$/;"	f	file:	signature:(COLUMN *p, int n, char *clump)
print_color_indicator	ls.c	/^print_color_indicator (const struct fileinfo *f, bool symlink_target)$/;"	f	file:	signature:(const struct fileinfo *f, bool symlink_target)
print_color_indicator	ls.c	/^static bool print_color_indicator (const struct fileinfo *f,$/;"	p	file:	signature:(const struct fileinfo *f, bool symlink_target)
print_current_files	ls.c	/^print_current_files (void)$/;"	f	file:	signature:(void)
print_current_files	ls.c	/^static void print_current_files (void);$/;"	p	file:	signature:(void)
print_deadprocs	who.c	/^print_deadprocs (const STRUCT_UTMP *utmp_ent)$/;"	f	file:	signature:(const STRUCT_UTMP *utmp_ent)
print_dir	ls.c	/^print_dir (char const *name, char const *realname, bool command_line_arg)$/;"	f	file:	signature:(char const *name, char const *realname, bool command_line_arg)
print_dir	ls.c	/^static void print_dir (char const *name, char const *realname,$/;"	p	file:	signature:(char const *name, char const *realname, bool command_line_arg)
print_dir_name	ls.c	/^static bool print_dir_name;$/;"	v	file:
print_direc	printf.c	/^print_direc (const char *start, size_t length, char conversion,$/;"	f	file:	signature:(const char *start, size_t length, char conversion, bool have_field_width, int field_width, bool have_precision, int precision, char const *argument)
print_element	uname.c	/^print_element (char const *element)$/;"	f	file:	signature:(char const *element)
print_entry	pinky.c	/^print_entry (const STRUCT_UTMP *utmp_ent)$/;"	f	file:	signature:(const STRUCT_UTMP *utmp_ent)
print_esc	printf.c	/^print_esc (const char *escstart, bool octal_0)$/;"	f	file:	signature:(const char *escstart, bool octal_0)
print_esc_char	printf.c	/^print_esc_char (char c)$/;"	f	file:	signature:(char c)
print_esc_char	stat.c	/^print_esc_char (char c)$/;"	f	file:	signature:(char c)
print_esc_string	printf.c	/^print_esc_string (const char *str)$/;"	f	file:	signature:(const char *str)
print_factors	factor.c	/^print_factors (const char *input)$/;"	f	file:	signature:(const char *input)
print_factors_single	factor.c	/^print_factors_single (uintmax_t t1, uintmax_t t0)$/;"	f	file:	signature:(uintmax_t t1, uintmax_t t0)
print_field	ptx.c	/^print_field (BLOCK field)$/;"	f	file:	signature:(BLOCK field)
print_file_name_and_frills	ls.c	/^print_file_name_and_frills (const struct fileinfo *f, size_t start_col)$/;"	f	file:	signature:(const struct fileinfo *f, size_t start_col)
print_file_name_and_frills	ls.c	/^static size_t print_file_name_and_frills (const struct fileinfo *f,$/;"	p	file:	signature:(const struct fileinfo *f, size_t start_col)
print_filename	md5sum.c	/^print_filename (char const *file)$/;"	f	file:	signature:(char const *file)
print_files	pr.c	/^print_files (int number_of_files, char **av)$/;"	f	file:	signature:(int number_of_files, char **av)
print_files	pr.c	/^static void print_files (int number_of_files, char **av);$/;"	p	file:	signature:(int number_of_files, char **av)
print_float	getlimits.c	129;"	d	file:
print_formatted	printf.c	/^print_formatted (const char *format, int argc, char **argv)$/;"	f	file:	signature:(const char *format, int argc, char **argv)
print_full_info	id.c	/^print_full_info (const char *username)$/;"	f	file:	signature:(const char *username)
print_full_info	id.c	/^static void print_full_info (const char *username);$/;"	p	file:	signature:(const char *username)
print_func	pr.c	/^    bool (*print_func) (struct COLUMN *);$/;"	m	struct:COLUMN	file:	access:public
print_function	od.c	/^    void (*print_function) (size_t fields, size_t blank, void const *data,$/;"	m	struct:tspec	file:	access:public
print_grand_total	df.c	/^static bool print_grand_total;$/;"	v	file:
print_grand_total	du.c	/^static bool print_grand_total = false;$/;"	v	file:
print_group	group-list.c	/^print_group (gid_t gid, bool use_name)$/;"	f	signature:(gid_t gid, bool use_name)
print_group	group-list.h	/^bool print_group (gid_t, bool);$/;"	p	signature:(gid_t, bool)
print_group	ls.c	/^static bool print_group = true;$/;"	v	file:
print_group_list	group-list.c	/^print_group_list (const char *username,$/;"	f	signature:(const char *username, uid_t ruid, gid_t rgid, gid_t egid, bool use_names)
print_group_list	group-list.h	/^bool print_group_list (const char *, uid_t, gid_t, gid_t, bool);$/;"	p	signature:(const char *, uid_t, gid_t, gid_t, bool)
print_header	pr.c	/^print_header (void)$/;"	f	file:	signature:(void)
print_header	pr.c	/^static void print_header (void);$/;"	p	file:	signature:(void)
print_headers	head.c	/^static bool print_headers;$/;"	v	file:
print_headers	tail.c	/^static bool print_headers;$/;"	v	file:
print_heading	pinky.c	/^print_heading (void)$/;"	f	file:	signature:(void)
print_heading	who.c	/^print_heading (void)$/;"	f	file:	signature:(void)
print_horizontal	ls.c	/^print_horizontal (void)$/;"	f	file:	signature:(void)
print_horizontal	ls.c	/^static void print_horizontal (void);$/;"	p	file:	signature:(void)
print_initspawn	who.c	/^print_initspawn (const STRUCT_UTMP *utmp_ent)$/;"	f	file:	signature:(const STRUCT_UTMP *utmp_ent)
print_inode	ls.c	/^static bool print_inode;$/;"	v	file:
print_int	getlimits.c	118;"	d	file:
print_it	stat.c	/^print_it (char const *format, char const *filename,$/;"	f	file:	signature:(char const *format, char const *filename, bool (*print_func) (char *, size_t, unsigned int, char const *, void const *), void const *data)
print_kth	cut.c	/^print_kth (size_t k, bool *range_start)$/;"	f	file:	signature:(size_t k, bool *range_start)
print_line	tac-pipe.c	/^print_line (FILE *out_stream, const Buf *x,$/;"	f	file:	signature:(FILE *out_stream, const Buf *x, const Line_ptr *bol, const Line_ptr *bol_next)
print_line	who.c	/^print_line (int userlen, const char *user, const char state,$/;"	f	file:	signature:(int userlen, const char *user, const char state, int linelen, const char *line, const char *time_str, const char *idle, const char *pid, const char *comment, const char *exitstr)
print_linelength	wc.c	/^static bool print_linelength;$/;"	v	file:
print_lineno	nl.c	/^print_lineno (void)$/;"	f	file:	signature:(void)
print_lines	wc.c	/^static bool print_lines, print_words, print_chars, print_bytes;$/;"	v	file:
print_login	who.c	/^print_login (const STRUCT_UTMP *utmp_ent)$/;"	f	file:	signature:(const STRUCT_UTMP *utmp_ent)
print_long_entry	pinky.c	/^print_long_entry (const char name[])$/;"	f	file:	signature:(const char name[])
print_long_format	ls.c	/^print_long_format (const struct fileinfo *f)$/;"	f	file:	signature:(const struct fileinfo *f)
print_long_format	ls.c	/^static void print_long_format (const struct fileinfo *f);$/;"	p	file:	signature:(const struct fileinfo *f)
print_many_per_line	ls.c	/^print_many_per_line (void)$/;"	f	file:	signature:(void)
print_many_per_line	ls.c	/^static void print_many_per_line (void);$/;"	p	file:	signature:(void)
print_name_with_quoting	ls.c	/^print_name_with_quoting (const struct fileinfo *f,$/;"	f	file:	signature:(const struct fileinfo *f, bool symlink_target, struct obstack *stack, size_t start_col)
print_name_with_quoting	ls.c	/^static size_t print_name_with_quoting (const struct fileinfo *f,$/;"	p	file:	signature:(const struct fileinfo *f, bool symlink_target, struct obstack *stack, size_t start_col)
print_named_ascii	od.c	/^print_named_ascii (size_t fields, size_t blank, void const *block,$/;"	f	file:	signature:(size_t fields, size_t blank, void const *block, const char *unused_fmt_string ATTRIBUTE_UNUSED, int width, int pad)
print_no_line_fmt	nl.c	/^static char *print_no_line_fmt = NULL;$/;"	v	file:
print_numbers	seq.c	/^print_numbers (char const *fmt, struct layout layout,$/;"	f	file:	signature:(char const *fmt, struct layout layout, long double first, long double step, long double last)
print_only_size	du.c	/^print_only_size (uintmax_t n_bytes)$/;"	f	file:	signature:(uintmax_t n_bytes)
print_owner	ls.c	/^static bool print_owner = true;$/;"	v	file:
print_padded_number	numfmt.c	/^print_padded_number (void)$/;"	f	file:	signature:(void)
print_page	pr.c	/^print_page (void)$/;"	f	file:	signature:(void)
print_page	pr.c	/^static bool print_page (void);$/;"	p	file:	signature:(void)
print_pairables	join.c	/^static bool print_pairables;$/;"	v	file:
print_runlevel	who.c	/^print_runlevel (const STRUCT_UTMP *utmp_ent)$/;"	f	file:	signature:(const STRUCT_UTMP *utmp_ent)
print_scontext	ls.c	/^static bool print_scontext;$/;"	v	file:
print_sep_string	pr.c	/^print_sep_string (void)$/;"	f	file:	signature:(void)
print_sep_string	pr.c	/^static void print_sep_string (void);$/;"	p	file:	signature:(void)
print_size	du.c	/^print_size (const struct duinfo *pdui, const char *string)$/;"	f	file:	signature:(const struct duinfo *pdui, const char *string)
print_spaces	ptx.c	/^print_spaces (int number)$/;"	f	file:	signature:(int number)
print_stat	stat.c	/^print_stat (char *pformat, size_t prefix_len, unsigned int m,$/;"	f	file:	signature:(char *pformat, size_t prefix_len, unsigned int m, char const *filename, void const *data)
print_statfs	stat.c	/^print_statfs (char *pformat, size_t prefix_len, unsigned int m,$/;"	f	file:	signature:(char *pformat, size_t prefix_len, unsigned int m, char const *filename, void const *data)
print_stats	dd.c	/^print_stats (void)$/;"	f	file:	signature:(void)
print_stored	pr.c	/^print_stored (COLUMN *p)$/;"	f	file:	signature:(COLUMN *p)
print_stored	pr.c	/^static bool print_stored (COLUMN *p);$/;"	p	file:	signature:(COLUMN *p)
print_table	df.c	/^print_table (void)$/;"	f	file:	signature:(void)
print_table_row	kill.c	/^print_table_row (unsigned int num_width, int signum,$/;"	f	file:	signature:(unsigned int num_width, int signum, unsigned int name_width, char const *signame)
print_type	df.c	/^static bool print_type;$/;"	v	file:
print_type_indicator	ls.c	/^print_type_indicator (bool stat_ok, mode_t mode, enum filetype type)$/;"	f	file:	signature:(bool stat_ok, mode_t mode, enum filetype type)
print_type_indicator	ls.c	/^static bool print_type_indicator (bool stat_ok, mode_t mode,$/;"	p	file:	signature:(bool stat_ok, mode_t mode, enum filetype type)
print_uintmaxes	factor.c	/^print_uintmaxes (uintmax_t t1, uintmax_t t0)$/;"	f	file:	signature:(uintmax_t t1, uintmax_t t0)
print_unpairables_1	join.c	/^static bool print_unpairables_1, print_unpairables_2;$/;"	v	file:
print_unpairables_2	join.c	/^static bool print_unpairables_1, print_unpairables_2;$/;"	v	file:
print_uptime	uptime.c	/^print_uptime (size_t n, const STRUCT_UTMP *this)$/;"	f	file:	signature:(size_t n, const STRUCT_UTMP *this)
print_user	id.c	/^print_user (uid_t uid)$/;"	f	file:	signature:(uid_t uid)
print_user	id.c	/^static void print_user (uid_t uid);$/;"	p	file:	signature:(uid_t uid)
print_user	who.c	/^print_user (const STRUCT_UTMP *utmp_ent, time_t boottime)$/;"	f	file:	signature:(const STRUCT_UTMP *utmp_ent, time_t boottime)
print_white_space	pr.c	/^print_white_space (void)$/;"	f	file:	signature:(void)
print_wide_uint	make-prime-list.c	/^print_wide_uint (wide_uint n, int nesting, unsigned wide_uint_bits)$/;"	f	file:	signature:(wide_uint n, int nesting, unsigned wide_uint_bits)
print_with_color	ls.c	/^static bool print_with_color;$/;"	v	file:
print_with_commas	ls.c	/^print_with_commas (void)$/;"	f	file:	signature:(void)
print_with_commas	ls.c	/^static void print_with_commas (void);$/;"	p	file:	signature:(void)
print_words	wc.c	/^static bool print_lines, print_words, print_chars, print_bytes;$/;"	v	file:
printable_field	cut.c	/^static unsigned char *printable_field;$/;"	v	file:
printf_flags	stat.c	/^static char const printf_flags[] = "'-+ #0I";$/;"	v	file:
printv	expr.c	/^printv (VALUE *v)$/;"	f	file:	signature:(VALUE *v)
printv	expr.c	/^static void printv (VALUE *v);$/;"	p	file:	signature:(VALUE *v)
priority_queue	sort.c	/^  struct heap *priority_queue;  \/* Priority queue of merge tree nodes. *\/$/;"	m	struct:merge_node_queue	typeref:struct:merge_node_queue::heap	file:	access:public
prjoin	join.c	/^prjoin (struct line const *line1, struct line const *line2)$/;"	f	file:	signature:(struct line const *line1, struct line const *line2)
proc_body	nl.c	/^proc_body (void)$/;"	f	file:	signature:(void)
proc_footer	nl.c	/^proc_footer (void)$/;"	f	file:	signature:(void)
proc_header	nl.c	/^proc_header (void)$/;"	f	file:	signature:(void)
proc_text	nl.c	/^proc_text (void)$/;"	f	file:	signature:(void)
process_dir	install.c	/^process_dir (char *dir, struct savewd *wd, void *options)$/;"	f	file:	signature:(char *dir, struct savewd *wd, void *options)
process_dir	mkdir.c	/^process_dir (char *dir, struct savewd *wd, void *options)$/;"	f	file:	signature:(char *dir, struct savewd *wd, void *options)
process_file	chcon.c	/^process_file (FTS *fts, FTSENT *ent)$/;"	f	file:	signature:(FTS *fts, FTSENT *ent)
process_file	chmod.c	/^process_file (FTS *fts, FTSENT *ent)$/;"	f	file:	signature:(FTS *fts, FTSENT *ent)
process_file	du.c	/^process_file (FTS *fts, FTSENT *ent)$/;"	f	file:	signature:(FTS *fts, FTSENT *ent)
process_file	nl.c	/^process_file (FILE *fp)$/;"	f	file:	signature:(FILE *fp)
process_files	chcon.c	/^process_files (char **files, int bit_flags)$/;"	f	file:	signature:(char **files, int bit_flags)
process_files	chmod.c	/^process_files (char **files, int bit_flags)$/;"	f	file:	signature:(char **files, int bit_flags)
process_line	numfmt.c	/^process_line (char *line, bool newline)$/;"	f	file:	signature:(char *line, bool newline)
process_line_count	csplit.c	/^process_line_count (const struct control *p, uintmax_t repetition)$/;"	f	file:	signature:(const struct control *p, uintmax_t repetition)
process_path	realpath.c	/^process_path (const char *fname, int can_mode)$/;"	f	file:	signature:(const char *fname, int can_mode)
process_prime	make-prime-list.c	/^process_prime (struct prime *info, unsigned p)$/;"	f	file:	signature:(struct prime *info, unsigned p)
process_regexp	csplit.c	/^process_regexp (struct control *p, uintmax_t repetition)$/;"	f	file:	signature:(struct control *p, uintmax_t repetition)
process_signals	dd.c	/^process_signals (void)$/;"	f	file:	signature:(void)
process_signals	ls.c	/^process_signals (void)$/;"	f	file:	signature:(void)
process_suffixed_number	numfmt.c	/^process_suffixed_number (char *text, long double *result, size_t *precision)$/;"	f	file:	signature:(char *text, long double *result, size_t *precision)
proctab	sort.c	/^static Hash_table *proctab;$/;"	v	file:
proctab_comparator	sort.c	/^proctab_comparator (void const *e1, void const *e2)$/;"	f	file:	signature:(void const *e1, void const *e2)
proctab_hasher	sort.c	/^proctab_hasher (void const *entry, size_t tabsize)$/;"	f	file:	signature:(void const *entry, size_t tabsize)
prog_fprintf	prog-fprintf.c	/^prog_fprintf (FILE *fp, char const *fmt, ...)$/;"	f	signature:(FILE *fp, char const *fmt, ...)
prog_fprintf	prog-fprintf.h	/^extern void prog_fprintf (FILE *fp, char const *fmt, ...)$/;"	p	signature:(FILE *fp, char const *fmt, ...)
program_path	stdbuf.c	/^static char *program_path;$/;"	v	file:
prompt	remove.c	/^prompt (FTS const *fts, FTSENT const *ent, bool is_dir,$/;"	f	file:	signature:(FTS const *fts, FTSENT const *ent, bool is_dir, struct rm_options const *x, enum Prompt_action mode, Ternary *is_empty_p)
proper_name	system.h	366;"	d
pseudo_offset	od.c	/^static uintmax_t pseudo_offset;$/;"	v	file:
ptr	tac-pipe.c	/^  char *ptr;$/;"	m	struct:Line_ptr	file:	access:public
ptr_align	system.h	/^ptr_align (void const *ptr, size_t alignment)$/;"	f	signature:(void const *ptr, size_t alignment)
punct	fmt.c	/^    unsigned int punct:1;	\/* ends in punctuation *\/$/;"	m	struct:Word	file:	access:public
put_indicator	ls.c	/^put_indicator (const struct bin_str *ind)$/;"	f	file:	signature:(const struct bin_str *ind)
put_indicator	ls.c	/^static void put_indicator (const struct bin_str *ind);$/;"	p	file:	signature:(const struct bin_str *ind)
put_line	fmt.c	/^put_line (WORD *w, int indent)$/;"	f	file:	signature:(WORD *w, int indent)
put_line	fmt.c	/^static void put_line (WORD *w, int indent);$/;"	p	file:	signature:(WORD *w, int indent)
put_paragraph	fmt.c	/^put_paragraph (WORD *finish)$/;"	f	file:	signature:(WORD *finish)
put_paragraph	fmt.c	/^static void put_paragraph (WORD *finish);$/;"	p	file:	signature:(WORD *finish)
put_space	fmt.c	/^put_space (int space)$/;"	f	file:	signature:(int space)
put_space	fmt.c	/^static void put_space (int space);$/;"	p	file:	signature:(int space)
put_word	fmt.c	/^put_word (WORD *w)$/;"	f	file:	signature:(WORD *w)
put_word	fmt.c	/^static void put_word (WORD *w);$/;"	p	file:	signature:(WORD *w)
q_freq	factor.c	/^static unsigned int q_freq[Q_FREQ_SIZE + 1];$/;"	v	file:
qlink	tsort.c	/^  struct item *qlink;$/;"	m	struct:item	typeref:struct:item::item	file:	access:public
qmark_funny_chars	ls.c	/^static bool qmark_funny_chars;$/;"	v	file:
qsortFunc	ls.c	/^typedef int (*qsortFunc)(V a, V b);$/;"	t	file:
queue	sort.c	/^  struct merge_node_queue *const queue;$/;"	m	struct:thread_args	file:	access:public
queue_check_insert	sort.c	/^queue_check_insert (struct merge_node_queue *queue, struct merge_node *node)$/;"	f	file:	signature:(struct merge_node_queue *queue, struct merge_node *node)
queue_check_insert_parent	sort.c	/^queue_check_insert_parent (struct merge_node_queue *queue,$/;"	f	file:	signature:(struct merge_node_queue *queue, struct merge_node *node)
queue_destroy	sort.c	/^queue_destroy (struct merge_node_queue *queue)$/;"	f	file:	signature:(struct merge_node_queue *queue)
queue_directory	ls.c	/^queue_directory (char const *name, char const *realname, bool command_line_arg)$/;"	f	file:	signature:(char const *name, char const *realname, bool command_line_arg)
queue_directory	ls.c	/^static void queue_directory (char const *name, char const *realname,$/;"	p	file:	signature:(char const *name, char const *realname, bool command_line_arg)
queue_init	sort.c	/^queue_init (struct merge_node_queue *queue, size_t nthreads)$/;"	f	file:	signature:(struct merge_node_queue *queue, size_t nthreads)
queue_insert	sort.c	/^queue_insert (struct merge_node_queue *queue, struct merge_node *node)$/;"	f	file:	signature:(struct merge_node_queue *queue, struct merge_node *node)
queue_pop	sort.c	/^queue_pop (struct merge_node_queue *queue)$/;"	f	file:	signature:(struct merge_node_queue *queue)
queued	sort.c	/^  bool queued;                  \/* Node is already in heap. *\/$/;"	m	struct:merge_node	file:	access:public
quiet	md5sum.c	/^static bool quiet = false;$/;"	v	file:
quit	dd.c	/^quit (int code)$/;"	f	file:	signature:(int code)
quote_name	ls.c	/^quote_name (FILE *out, const char *name, struct quoting_options const *options,$/;"	f	file:	signature:(FILE *out, const char *name, struct quoting_options const *options, size_t *width)
quote_name	ls.c	/^static size_t quote_name (FILE *out, const char *name,$/;"	p	file:	signature:(FILE *out, const char *name, struct quoting_options const *options, size_t *width)
r	cksum.c	/^static uint_fast32_t r[8];$/;"	v	file:
r_full	dd.c	/^static uintmax_t r_full = 0;$/;"	v	file:
r_partial	dd.c	/^static uintmax_t r_partial = 0;$/;"	v	file:
r_truncate	dd.c	/^static uintmax_t r_truncate = 0;$/;"	v	file:
randint_source	shred.c	/^static struct randint_source *randint_source;$/;"	v	typeref:struct:randint_source	file:
random	sort.c	/^  bool random;			\/* Sort by random hash of key.  *\/$/;"	m	struct:keyfield	file:	access:public
random_md5_state	sort.c	/^static struct md5_ctx random_md5_state;$/;"	v	typeref:struct:md5_ctx	file:
random_md5_state_init	sort.c	/^random_md5_state_init (char const *random_source)$/;"	f	file:	signature:(char const *random_source)
range	tr.c	/^        range;$/;"	m	union:List_element::__anon3	typeref:struct:List_element::__anon3::__anon4	file:	access:public
range_pair	cut.c	/^struct range_pair$/;"	s	file:
range_pair::hi	cut.c	/^    size_t hi;$/;"	m	struct:range_pair	file:	access:public
range_pair::lo	cut.c	/^    size_t lo;$/;"	m	struct:range_pair	file:	access:public
range_start_ht	cut.c	/^static Hash_table *range_start_ht;$/;"	v	file:
re_compiled	csplit.c	/^  struct re_pattern_buffer re_compiled;	\/* Compiled regular expression. *\/$/;"	m	struct:control	typeref:struct:control::re_pattern_buffer	file:	access:public
re_protect	cp.c	/^re_protect (char const *const_dst_name, size_t src_offset,$/;"	f	file:	signature:(char const *const_dst_name, size_t src_offset, struct dir_attr *attr_list, const struct cp_options *x)
read_and_delete	tr.c	/^read_and_delete (char *buf, size_t size)$/;"	f	file:	signature:(char *buf, size_t size)
read_and_xlate	tr.c	/^read_and_xlate (char *buf, size_t size)$/;"	f	file:	signature:(char *buf, size_t size)
read_block	od.c	/^read_block (size_t n, char *block, size_t *n_bytes_in_buffer)$/;"	f	file:	signature:(size_t n, char *block, size_t *n_bytes_in_buffer)
read_char	od.c	/^read_char (int *c)$/;"	f	file:	signature:(int *c)
read_input	csplit.c	/^read_input (char *dest, size_t max_n_bytes)$/;"	f	file:	signature:(char *dest, size_t max_n_bytes)
read_input	shuf.c	/^read_input (FILE *in, char eolbyte, char ***pline)$/;"	f	file:	signature:(FILE *in, char eolbyte, char ***pline)
read_line	pr.c	/^read_line (COLUMN *p)$/;"	f	file:	signature:(COLUMN *p)
read_line	pr.c	/^static bool read_line (COLUMN *p);$/;"	p	file:	signature:(COLUMN *p)
read_rest_of_line	pr.c	/^read_rest_of_line (COLUMN *p)$/;"	f	file:	signature:(COLUMN *p)
read_rest_of_line	pr.c	/^static void read_rest_of_line (COLUMN *p);$/;"	p	file:	signature:(COLUMN *p)
read_size	tac.c	/^static size_t read_size;$/;"	v	file:
readdir_ignoring_dot_and_dotdot	system.h	/^readdir_ignoring_dot_and_dotdot (DIR *dirp)$/;"	f	signature:(DIR *dirp)
realname	ls.c	/^    char *realname;$/;"	m	struct:pending	file:	access:public
realpath_canon	realpath.c	/^realpath_canon (const char *fname, int can_mode)$/;"	f	file:	signature:(const char *fname, int can_mode)
reap	sort.c	/^reap (pid_t pid)$/;"	f	file:	signature:(pid_t pid)
reap_all	sort.c	/^reap_all (void)$/;"	f	file:	signature:(void)
reap_exited	sort.c	/^reap_exited (void)$/;"	f	file:	signature:(void)
reap_some	sort.c	/^reap_some (void)$/;"	f	file:	signature:(void)
recheck	tail.c	/^recheck (struct File_spec *f, bool blocking)$/;"	f	file:	signature:(struct File_spec *f, bool blocking)
record_line_starts	csplit.c	/^record_line_starts (struct buffer_record *b)$/;"	f	file:	signature:(struct buffer_record *b)
record_open_fd	tail.c	/^record_open_fd (struct File_spec *f, int fd,$/;"	f	file:	signature:(struct File_spec *f, int fd, off_t size, struct stat const *st, int blocking)
record_or_unlink_tempfile	tac.c	/^record_or_unlink_tempfile (char const *fn, FILE *fp ATTRIBUTE_UNUSED)$/;"	f	file:	signature:(char const *fn, FILE *fp ATTRIBUTE_UNUSED)
record_or_unlink_tempfile	tac.c	/^record_or_unlink_tempfile (char const *fn, FILE *fp)$/;"	f	file:	signature:(char const *fn, FILE *fp)
record_relation	tsort.c	/^record_relation (struct item *j, struct item *k)$/;"	f	file:	signature:(struct item *j, struct item *k)
recover_mode	stty.c	/^recover_mode (char const *arg, struct termios *mode)$/;"	f	file:	signature:(char const *arg, struct termios *mode)
recover_mode	stty.c	/^static bool recover_mode (char const *arg, struct termios *mode);$/;"	p	file:	signature:(char const *arg, struct termios *mode)
recoverable	stty.c	/^    changed, all, recoverable	\/* Default, -a, -g.  *\/$/;"	e	enum:output_type	file:
recurse	chcon.c	/^static bool recurse;$/;"	v	file:
recurse	chmod.c	/^static bool recurse;$/;"	v	file:
recurse	chown-core.h	/^  bool recurse;$/;"	m	struct:Chown_option	access:public
recurse_tree	tsort.c	/^recurse_tree (struct item *root, bool (*action) (struct item *))$/;"	f	file:	signature:(struct item *root, bool (*action) (struct item *))
recursive	copy.h	/^  bool recursive;$/;"	m	struct:cp_options	access:public
recursive	ls.c	/^static bool recursive;$/;"	v	file:
recursive	remove.h	/^  bool recursive;$/;"	m	struct:rm_options	access:public
redcify	factor.c	949;"	d	file:
redcify2	factor.c	956;"	d	file:
reduce_diagnostics	copy.h	/^  bool reduce_diagnostics;$/;"	m	struct:cp_options	access:public
ref_file	touch.c	/^static char *ref_file;$/;"	v	file:
ref_file	truncate.c	/^static char const *ref_file;$/;"	v	file:
reference	ptx.c	/^    int reference;		\/* reference descriptor *\/$/;"	m	struct:__anon32	file:	access:public
reference	ptx.c	/^static BLOCK reference;		\/* reference field for input reference mode *\/$/;"	v	file:
reference_file	chgrp.c	/^static char *reference_file;$/;"	v	file:
reference_file	chown.c	/^static char *reference_file;$/;"	v	file:
reference_max_width	ptx.c	/^static int reference_max_width;$/;"	v	file:
reflink_mode	copy.h	/^  enum Reflink_type reflink_mode;$/;"	m	struct:cp_options	typeref:enum:cp_options::Reflink_type	access:public
reflink_type	cp.c	/^static enum Reflink_type const reflink_type[] =$/;"	v	file:
reflink_type_string	cp.c	/^static char const *const reflink_type_string[] =$/;"	v	file:
regex_data	ptx.c	/^struct regex_data$/;"	s	file:
regex_data::fastmap	ptx.c	/^  char fastmap[UCHAR_MAX + 1];$/;"	m	struct:regex_data	file:	access:public
regex_data::pattern	ptx.c	/^  struct re_pattern_buffer pattern;$/;"	m	struct:regex_data	typeref:struct:regex_data::re_pattern_buffer	file:	access:public
regex_data::string	ptx.c	/^  char const *string;$/;"	m	struct:regex_data	file:	access:public
regexp_error	csplit.c	/^regexp_error (struct control *p, uintmax_t repetition, bool ignore)$/;"	f	file:	signature:(struct control *p, uintmax_t repetition, bool ignore)
regexpr	csplit.c	/^  bool regexpr;			\/* True if regular expression was used. *\/$/;"	m	struct:control	file:	access:public
register_proc	sort.c	/^register_proc (struct tempnode *temp)$/;"	f	file:	signature:(struct tempnode *temp)
regs	tac.c	/^static struct re_registers regs;$/;"	v	typeref:struct:re_registers	file:
rel_mode_t	truncate.c	/^{ rm_abs = 0, rm_rel, rm_min, rm_max, rm_rdn, rm_rup } rel_mode_t;$/;"	t	typeref:enum:__anon19	file:
relative	ln.c	/^static bool relative;$/;"	v	file:
relpath	relpath.c	/^relpath (const char *can_fname, const char *can_reldir, char *buf, size_t len)$/;"	f	signature:(const char *can_fname, const char *can_reldir, char *buf, size_t len)
relpath	relpath.h	/^relpath (const char *can_fname, const char *can_reldir, char *buf, size_t len);$/;"	p	signature:(const char *can_fname, const char *can_reldir, char *buf, size_t len)
remember_copied	cp-hash.c	/^remember_copied (const char *name, ino_t ino, dev_t dev)$/;"	f	signature:(const char *name, ino_t ino, dev_t dev)
remember_copied	cp-hash.h	/^char *remember_copied (const char *node, ino_t ino, dev_t dev);$/;"	p	signature:(const char *node, ino_t ino, dev_t dev)
remote	tail.c	/^  bool remote;$/;"	m	struct:File_spec	file:	access:public
remove_empty_directories	remove.h	/^  bool remove_empty_directories;$/;"	m	struct:rm_options	access:public
remove_empty_parents	rmdir.c	/^static bool remove_empty_parents;$/;"	v	file:
remove_existing_files	ln.c	/^static bool remove_existing_files;$/;"	v	file:
remove_file	shred.c	/^  bool remove_file;	\/* -u flag: remove file after shredding *\/$/;"	m	struct:Options	file:	access:public
remove_files	csplit.c	/^static bool volatile remove_files;$/;"	v	file:
remove_ldadd	local.mk	/^remove_ldadd =$/;"	m
remove_line	csplit.c	/^remove_line (void)$/;"	f	file:	signature:(void)
remove_parents	rmdir.c	/^remove_parents (char *dir)$/;"	f	file:	signature:(char *dir)
remove_suffix	basename.c	/^remove_suffix (char *name, const char *suffix)$/;"	f	file:	signature:(char *name, const char *suffix)
remove_trailing_slashes	cp.c	/^static bool remove_trailing_slashes;$/;"	v	file:
remove_trailing_slashes	mv.c	/^static bool remove_trailing_slashes;$/;"	v	file:
rename	copy.h	274;"	d
rename	copy.h	275;"	d
reopen_inaccessible_files	tail.c	/^static bool reopen_inaccessible_files;$/;"	v	file:
repeat	csplit.c	/^  uintmax_t repeat;		\/* Repeat count. *\/$/;"	m	struct:control	file:	access:public
repeat_count	tr.c	/^            count repeat_count;$/;"	m	struct:List_element::__anon3::__anon5	file:	access:public
repeat_forever	csplit.c	/^  bool repeat_forever;		\/* True if '*' used as a repeat count. *\/$/;"	m	struct:control	file:	access:public
repeated_char	tr.c	/^        repeated_char;$/;"	m	union:List_element::__anon3	typeref:struct:List_element::__anon3::__anon5	file:	access:public
require_preserve	copy.h	/^  bool require_preserve;$/;"	m	struct:cp_options	access:public
require_preserve_context	copy.h	/^  bool require_preserve_context;$/;"	m	struct:cp_options	access:public
require_preserve_xattr	copy.h	/^  bool require_preserve_xattr;$/;"	m	struct:cp_options	access:public
require_restore_cwd	remove.h	/^  bool require_restore_cwd;$/;"	m	struct:rm_options	access:public
require_sync	df.c	/^static bool require_sync;$/;"	v	file:
required_mon_width	ls.c	/^static size_t required_mon_width;$/;"	v	file:
reset_line	join.c	/^reset_line (struct line *line)$/;"	f	file:	signature:(struct line *line)
reset_numbers	nl.c	/^static bool reset_numbers = true;$/;"	v	file:
reset_status	pr.c	/^reset_status (void)$/;"	f	file:	signature:(void)
restore_default_color	ls.c	/^restore_default_color (void)$/;"	f	file:	signature:(void)
restore_default_fscreatecon_or_die	copy.c	/^restore_default_fscreatecon_or_die (void)$/;"	f	file:	signature:(void)
restore_mode	cp.c	/^  bool restore_mode;$/;"	m	struct:dir_attr	file:	access:public
restricted_chown	chown-core.c	/^restricted_chown (int cwd_fd, char const *file,$/;"	f	file:	signature:(int cwd_fd, char const *file, struct stat const *orig_st, uid_t uid, gid_t gid, uid_t required_uid, gid_t required_gid)
retrieve_index	csplit.c	/^  size_t retrieve_index;	\/* Next index to use when retrieving line. *\/$/;"	m	struct:line	file:	access:public
rev_xstrcoll_df_version	ls.c	/^static int rev_xstrcoll_df_version (V a, V b)$/;"	f	file:	signature:(V a, V b)
rev_xstrcoll_version	ls.c	/^static int rev_xstrcoll_version (V a, V b)$/;"	f	file:	signature:(V a, V b)
reverse	sort.c	/^  bool reverse;			\/* Reverse the sense of comparison. *\/$/;"	m	struct:keyfield	file:	access:public
reverse	sort.c	/^static bool reverse;$/;"	v	file:
rfc_2822_format	date.c	/^static char const rfc_2822_format[] = "%a, %d %b %Y %H:%M:%S %z";$/;"	v	file:
rgid	id.c	/^static gid_t rgid, egid;$/;"	v	file:
right	ptx.c	/^    DELTA right;		\/* distance to right context end *\/$/;"	m	struct:__anon32	file:	access:public
right	tsort.c	/^  struct item *left, *right;$/;"	m	struct:item	typeref:struct:item::	file:	access:public
right_reference	ptx.c	/^static bool right_reference = false;	\/* output refs after right context  *\/$/;"	v	file:
rlim_cur	sort.c	/^struct rlimit { size_t rlim_cur; };$/;"	m	struct:rlimit	file:	access:public
rlimit	sort.c	/^struct rlimit { size_t rlim_cur; };$/;"	s	file:
rlimit::rlim_cur	sort.c	/^struct rlimit { size_t rlim_cur; };$/;"	m	struct:rlimit	file:	access:public
rm	remove.c	/^rm (char *const *file, struct rm_options const *x)$/;"	f	signature:(char *const *file, struct rm_options const *x)
rm	remove.h	/^extern enum RM_status rm (char *const *file, struct rm_options const *x);$/;"	p	signature:(char *const *file, struct rm_options const *x)
rm_abs	truncate.c	/^{ rm_abs = 0, rm_rel, rm_min, rm_max, rm_rdn, rm_rup } rel_mode_t;$/;"	e	enum:__anon19	file:
rm_fts	remove.c	/^rm_fts (FTS *fts, FTSENT *ent, struct rm_options const *x)$/;"	f	file:	signature:(FTS *fts, FTSENT *ent, struct rm_options const *x)
rm_interactive	remove.h	/^enum rm_interactive$/;"	g
rm_max	truncate.c	/^{ rm_abs = 0, rm_rel, rm_min, rm_max, rm_rdn, rm_rup } rel_mode_t;$/;"	e	enum:__anon19	file:
rm_min	truncate.c	/^{ rm_abs = 0, rm_rel, rm_min, rm_max, rm_rdn, rm_rup } rel_mode_t;$/;"	e	enum:__anon19	file:
rm_option_init	mv.c	/^rm_option_init (struct rm_options *x)$/;"	f	file:	signature:(struct rm_options *x)
rm_option_init	rm.c	/^rm_option_init (struct rm_options *x)$/;"	f	file:	signature:(struct rm_options *x)
rm_options	remove.h	/^struct rm_options$/;"	s
rm_options::ignore_missing_files	remove.h	/^  bool ignore_missing_files;$/;"	m	struct:rm_options	access:public
rm_options::interactive	remove.h	/^  enum rm_interactive interactive;$/;"	m	struct:rm_options	typeref:enum:rm_options::rm_interactive	access:public
rm_options::one_file_system	remove.h	/^  bool one_file_system;$/;"	m	struct:rm_options	access:public
rm_options::recursive	remove.h	/^  bool recursive;$/;"	m	struct:rm_options	access:public
rm_options::remove_empty_directories	remove.h	/^  bool remove_empty_directories;$/;"	m	struct:rm_options	access:public
rm_options::require_restore_cwd	remove.h	/^  bool require_restore_cwd;$/;"	m	struct:rm_options	access:public
rm_options::root_dev_ino	remove.h	/^  struct dev_ino *root_dev_ino;$/;"	m	struct:rm_options	typeref:struct:rm_options::dev_ino	access:public
rm_options::stdin_tty	remove.h	/^  bool stdin_tty;$/;"	m	struct:rm_options	access:public
rm_options::verbose	remove.h	/^  bool verbose;$/;"	m	struct:rm_options	access:public
rm_rdn	truncate.c	/^{ rm_abs = 0, rm_rel, rm_min, rm_max, rm_rdn, rm_rup } rel_mode_t;$/;"	e	enum:__anon19	file:
rm_rel	truncate.c	/^{ rm_abs = 0, rm_rel, rm_min, rm_max, rm_rdn, rm_rup } rel_mode_t;$/;"	e	enum:__anon19	file:
rm_rup	truncate.c	/^{ rm_abs = 0, rm_rel, rm_min, rm_max, rm_rdn, rm_rup } rel_mode_t;$/;"	e	enum:__anon19	file:
robust_getcwd	pwd.c	/^robust_getcwd (struct file_name *file_name)$/;"	f	file:	signature:(struct file_name *file_name)
root_dev_ino	chcon.c	/^static struct dev_ino *root_dev_ino;$/;"	v	typeref:struct:dev_ino	file:
root_dev_ino	chmod.c	/^static struct dev_ino *root_dev_ino;$/;"	v	typeref:struct:dev_ino	file:
root_dev_ino	chown-core.h	/^  struct dev_ino *root_dev_ino;$/;"	m	struct:Chown_option	typeref:struct:Chown_option::dev_ino	access:public
root_dev_ino	remove.h	/^  struct dev_ino *root_dev_ino;$/;"	m	struct:rm_options	typeref:struct:rm_options::dev_ino	access:public
round_args	numfmt.c	/^static char const *const round_args[] =$/;"	v	file:
round_ceiling	numfmt.c	/^  round_ceiling,$/;"	e	enum:round_type	file:
round_floor	numfmt.c	/^  round_floor,$/;"	e	enum:round_type	file:
round_from_zero	numfmt.c	/^  round_from_zero,$/;"	e	enum:round_type	file:
round_nearest	numfmt.c	/^  round_nearest,$/;"	e	enum:round_type	file:
round_to_zero	numfmt.c	/^  round_to_zero,$/;"	e	enum:round_type	file:
round_type	numfmt.c	/^enum round_type$/;"	g	file:
round_types	numfmt.c	/^static enum round_type const round_types[] =$/;"	v	file:
rpl_mkfifo	copy.c	/^rpl_mkfifo (char const *file, mode_t mode)$/;"	f	file:	signature:(char const *file, mode_t mode)
rpl_rename	copy.h	/^int rpl_rename (const char *, const char *);$/;"	p	signature:(const char *, const char *)
rsh2	factor.c	314;"	d	file:
rshift_rhlc	longlong.h	1039;"	d
rshift_rhlc	longlong.h	1082;"	d
ruid	id.c	/^static uid_t ruid, euid;$/;"	v	file:
s	expr.c	/^    char *s;$/;"	m	union:valinfo::__anon61	file:	access:public
s	tr.c	/^  char *s;$/;"	m	struct:E_string	file:	access:public
same_file_ok	copy.c	/^same_file_ok (char const *src_name, struct stat const *src_sb,$/;"	f	file:	signature:(char const *src_name, struct stat const *src_sb, char const *dst_name, struct stat const *dst_sb, const struct cp_options *x, bool *return_now, bool *unlink_src)
same_para	fmt.c	/^same_para (int c)$/;"	f	file:	signature:(int c)
same_para	fmt.c	/^static bool same_para (int c);$/;"	p	file:	signature:(int c)
sane_mode	stty.c	/^sane_mode (struct termios *mode)$/;"	f	file:	signature:(struct termios *mode)
sane_mode	stty.c	/^static void sane_mode (struct termios *mode);$/;"	p	file:	signature:(struct termios *mode)
saneval	stty.c	/^    cc_t saneval;		\/* Value to set for 'stty sane'.  *\/$/;"	m	struct:control_info	file:	access:public
save_buffer	csplit.c	/^save_buffer (struct buffer_record *buf)$/;"	f	file:	signature:(struct buffer_record *buf)
save_line_to_file	csplit.c	/^save_line_to_file (const struct cstring *line)$/;"	f	file:	signature:(const struct cstring *line)
save_line_to_file	csplit.c	/^static void save_line_to_file (const struct cstring *line);$/;"	p	file:	signature:(const struct cstring *line)
save_to_hold_area	csplit.c	/^save_to_hold_area (char *start, size_t num)$/;"	f	file:	signature:(char *start, size_t num)
saved_char	dd.c	/^static char saved_char;$/;"	v	file:
saved_line	sort.c	/^static struct line saved_line;$/;"	v	typeref:struct:line	file:
scale_IEC	numfmt.c	/^  scale_IEC,$/;"	e	enum:scale_type	file:
scale_IEC_I	numfmt.c	/^  scale_IEC_I                   \/* 'i' suffix is required.  *\/$/;"	e	enum:scale_type	file:
scale_SI	numfmt.c	/^  scale_SI,$/;"	e	enum:scale_type	file:
scale_auto	numfmt.c	/^  scale_auto,                   \/* --from only.  *\/$/;"	e	enum:scale_type	file:
scale_from	numfmt.c	/^static enum scale_type scale_from = scale_none;$/;"	v	typeref:enum:scale_type	file:
scale_from_args	numfmt.c	/^static char const *const scale_from_args[] =$/;"	v	file:
scale_from_types	numfmt.c	/^static enum scale_type const scale_from_types[] =$/;"	v	file:
scale_none	numfmt.c	/^  scale_none,                   \/* the default: no scaling.  *\/$/;"	e	enum:scale_type	file:
scale_to	numfmt.c	/^static enum scale_type scale_to = scale_none;$/;"	v	typeref:enum:scale_type	file:
scale_to_args	numfmt.c	/^static char const *const scale_to_args[] =$/;"	v	file:
scale_to_types	numfmt.c	/^static enum scale_type const scale_to_types[] =$/;"	v	file:
scale_type	numfmt.c	/^enum scale_type$/;"	g	file:
scan_arg	seq.c	/^scan_arg (const char *arg)$/;"	f	file:	signature:(const char *arg)
scan_entries	pinky.c	/^scan_entries (size_t n, const STRUCT_UTMP *utmp_buf,$/;"	f	file:	signature:(size_t n, const STRUCT_UTMP *utmp_buf, const int argc_names, char *const argv_names[])
scan_entries	who.c	/^scan_entries (size_t n, const STRUCT_UTMP *utmp_buf)$/;"	f	file:	signature:(size_t n, const STRUCT_UTMP *utmp_buf)
scan_start	extent-scan.h	/^  off_t scan_start;$/;"	m	struct:extent_scan	access:public
scan_zeros	tsort.c	/^scan_zeros (struct item *k)$/;"	f	file:	signature:(struct item *k)
scanargs	dd.c	/^scanargs (int argc, char *const *argv)$/;"	f	file:	signature:(int argc, char *const *argv)
schar	sort.c	/^  size_t schar;			\/* Additional characters to skip. *\/$/;"	m	struct:keyfield	file:	access:public
scontext	ls.c	/^    security_context_t scontext;$/;"	m	struct:fileinfo	file:	access:public
scontext_width	ls.c	/^static int scontext_width;$/;"	v	file:
screen_columns	stty.c	/^screen_columns (void)$/;"	f	file:	signature:(void)
screen_columns	stty.c	/^static int screen_columns (void);$/;"	p	file:	signature:(void)
sdiv_qrnnd	longlong.h	1122;"	d
sdiv_qrnnd	longlong.h	1386;"	d
sdiv_qrnnd	longlong.h	1789;"	d
sdiv_qrnnd	longlong.h	793;"	d
search_item	tsort.c	/^search_item (struct item *root, const char *str)$/;"	f	file:	signature:(struct item *root, const char *str)
search_table	ptx.c	/^search_table (WORD *word, WORD_TABLE *table)$/;"	f	file:	signature:(WORD *word, WORD_TABLE *table)
second	ptx.c	542;"	d	file:
second	ptx.c	572;"	d	file:
second	ptx.c	585;"	d	file:
second	ptx.c	591;"	d	file:
section	nl.c	/^enum section$/;"	g	file:
section_del	nl.c	/^static char const *section_del = DEFAULT_SECTION_DELIMITERS;$/;"	v	file:
seek_bytes	dd.c	/^static uintmax_t seek_bytes = 0;$/;"	v	file:
seek_records	dd.c	/^static uintmax_t seek_records = 0;$/;"	v	file:
seen_unpairable	comm.c	/^static bool seen_unpairable;$/;"	v	file:
seen_unpairable	join.c	/^static bool seen_unpairable;$/;"	v	file:
select_plural	system.h	/^select_plural (uintmax_t n)$/;"	f	signature:(uintmax_t n)
selected_fstype	df.c	/^selected_fstype (const char *fstype)$/;"	f	file:	signature:(const char *fstype)
selinux_enabled	cp.c	/^static bool selinux_enabled;$/;"	v	file:
selinux_enabled	install.c	/^static int selinux_enabled = 0;$/;"	v	file:
send_sig	timeout.c	/^send_sig (int where, int sig)$/;"	f	file:	signature:(int where, int sig)
send_signals	kill.c	/^send_signals (int signum, char *const *argv)$/;"	f	file:	signature:(int signum, char *const *argv)
sentinel_length	tac.c	/^static size_t sentinel_length;$/;"	v	file:
separator	seq.c	/^static char const *separator;$/;"	v	file:
separator	tac.c	/^static char const *separator;$/;"	v	file:
separator_ends_record	tac.c	/^static bool separator_ends_record;$/;"	v	file:
separator_str	nl.c	/^static char const *separator_str = "\\t";$/;"	v	file:
separator_string	pr.c	/^separator_string (const char *optarg_S)$/;"	f	file:	signature:(const char *optarg_S)
separator_string	pr.c	/^static void separator_string (const char *optarg_S);$/;"	p	file:	signature:(const char *optarg_S)
separators_not_printed	pr.c	/^static int separators_not_printed;$/;"	v	file:
seq	join.c	/^struct seq$/;"	s	file:
seq	ls.c	/^    struct bin_str seq;		\/* The sequence to output when we do *\/$/;"	m	struct:color_ext_type	typeref:struct:color_ext_type::bin_str	file:	access:public
seq::alloc	join.c	/^    size_t alloc;			\/* Elements allocated in 'lines'.  *\/$/;"	m	struct:seq	file:	access:public
seq::count	join.c	/^    size_t count;			\/* Elements used in 'lines'.  *\/$/;"	m	struct:seq	file:	access:public
seq::lines	join.c	/^    struct line **lines;$/;"	m	struct:seq	typeref:struct:seq::line	file:	access:public
seq_fast	seq.c	/^seq_fast (char const *a, char const *b)$/;"	f	file:	signature:(char const *a, char const *b)
sequential_sort	sort.c	/^sequential_sort (struct line *restrict lines, size_t nlines,$/;"	f	file:	signature:(struct line *restrict lines, size_t nlines, struct line *restrict temp, bool to_temp)
serial_merge	paste.c	/^static bool serial_merge;$/;"	v	file:
set_LD_PRELOAD	stdbuf.c	/^set_LD_PRELOAD (void)$/;"	f	file:	signature:(void)
set_additional_groups	chroot.c	/^set_additional_groups (char const *groups)$/;"	f	file:	signature:(char const *groups)
set_author	copy.c	/^set_author (const char *dst_name, int dest_desc, const struct stat *src_sb)$/;"	f	file:	signature:(const char *dst_name, int dest_desc, const struct stat *src_sb)
set_control_char	stty.c	/^set_control_char (struct control_info const *info, const char *arg,$/;"	f	file:	signature:(struct control_info const *info, const char *arg, struct termios *mode)
set_control_char	stty.c	/^static void set_control_char (struct control_info const *info,$/;"	p	file:	signature:(struct control_info const *info, const char *arg, struct termios *mode)
set_exit_status	ls.c	/^set_exit_status (bool serious)$/;"	f	file:	signature:(bool serious)
set_fd_flags	dd.c	/^set_fd_flags (int fd, int add_flags, char const *name)$/;"	f	file:	signature:(int fd, int add_flags, char const *name)
set_fields	cut.c	/^set_fields (const char *fieldstr)$/;"	f	file:	signature:(const char *fieldstr)
set_initialize	tr.c	/^set_initialize (struct Spec_list *s, bool complement_this_set, bool *in_set)$/;"	f	file:	signature:(struct Spec_list *s, bool complement_this_set, bool *in_set)
set_input_file	csplit.c	/^set_input_file (const char *name)$/;"	f	file:	signature:(const char *name)
set_join_field	join.c	/^set_join_field (size_t *var, size_t val)$/;"	f	file:	signature:(size_t *var, size_t val)
set_libstdbuf_options	stdbuf.c	/^set_libstdbuf_options (void)$/;"	f	file:	signature:(void)
set_mode	copy.h	/^  bool set_mode;$/;"	m	struct:cp_options	access:public
set_mode	stty.c	/^set_mode (struct mode_info const *info, bool reversed, struct termios *mode)$/;"	f	file:	signature:(struct mode_info const *info, bool reversed, struct termios *mode)
set_mode	stty.c	/^static bool set_mode (struct mode_info const *info, bool reversed,$/;"	p	file:	signature:(struct mode_info const *info, bool reversed, struct termios *mode)
set_normal_color	ls.c	/^set_normal_color (void)$/;"	f	file:	signature:(void)
set_ordering	sort.c	/^set_ordering (char const *s, struct keyfield *key, enum blanktype blanktype)$/;"	f	file:	signature:(char const *s, struct keyfield *key, enum blanktype blanktype)
set_other_indent	fmt.c	/^set_other_indent (bool same_paragraph)$/;"	f	file:	signature:(bool same_paragraph)
set_owner	copy.c	/^set_owner (const struct cp_options *x, char const *dst_name, int dest_desc,$/;"	f	file:	signature:(const struct cp_options *x, char const *dst_name, int dest_desc, struct stat const *src_sb, bool new_dst, struct stat const *dst_sb)
set_prefix	fmt.c	/^set_prefix (char *p)$/;"	f	file:	signature:(char *p)
set_prefix	fmt.c	/^static void set_prefix (char *p);$/;"	p	file:	signature:(char *p)
set_program_path	stdbuf.c	/^set_program_path (const char *arg)$/;"	f	file:	signature:(const char *arg)
set_speed	stty.c	/^set_speed (enum speed_setting type, const char *arg, struct termios *mode)$/;"	f	file:	signature:(enum speed_setting type, const char *arg, struct termios *mode)
set_speed	stty.c	/^static void set_speed (enum speed_setting type, const char *arg,$/;"	p	file:	signature:(enum speed_setting type, const char *arg, struct termios *mode)
set_suffix_length	split.c	/^set_suffix_length (uintmax_t n_units, enum Split_type split_type)$/;"	f	file:	signature:(uintmax_t n_units, enum Split_type split_type)
set_window_size	stty.c	/^set_window_size (int rows, int cols, char const *device_name)$/;"	f	file:	signature:(int rows, int cols, char const *device_name)
set_window_size	stty.c	/^static void set_window_size (int rows, int cols, char const *device_name);$/;"	p	file:	signature:(int rows, int cols, char const *device_name)
setdefaultfilecon	install.c	/^setdefaultfilecon (char const *file)$/;"	f	file:	signature:(char const *file)
setgroups	chroot.c	/^setgroups (size_t size ATTRIBUTE_UNUSED, gid_t const *list ATTRIBUTE_UNUSED)$/;"	f	file:	signature:(size_t size ATTRIBUTE_UNUSED, gid_t const *list ATTRIBUTE_UNUSED)
sethostname	hostname.c	/^sethostname (char *name, size_t namelen)$/;"	f	file:	signature:(char *name, size_t namelen)
settimeout	timeout.c	/^settimeout (double duration)$/;"	f	file:	signature:(double duration)
setup_padding_buffer	numfmt.c	/^setup_padding_buffer (size_t min_size)$/;"	f	file:	signature:(size_t min_size)
short_list	who.c	/^static bool short_list;$/;"	v	file:
short_options	date.c	/^static char const short_options[] = "d:f:I::r:Rs:u";$/;"	v	file:
short_options	kill.c	/^static char const short_options[] =$/;"	v	file:
short_options	od.c	/^static char const short_options[] = "A:aBbcDdeFfHhIij:LlN:OoS:st:vw::Xx";$/;"	v	file:
short_options	pr.c	/^static char const short_options[] =$/;"	v	file:
short_options	sort.c	/^static char const short_options[] = "-bcCdfghik:mMno:rRsS:t:T:uVy:z";$/;"	v	file:
short_output	who.c	/^static bool short_output;$/;"	v	file:
short_pinky	pinky.c	/^short_pinky (const char *filename,$/;"	f	file:	signature:(const char *filename, const int argc_names, char *const argv_names[])
shortopts	expand.c	/^static char const shortopts[] = "it:0::1::2::3::4::5::6::7::8::9::";$/;"	v	file:
shortopts	fold.c	/^static char const shortopts[] = "bsw:0::1::2::3::4::5::6::7::8::9::";$/;"	v	file:
show_all_fs	df.c	/^static bool show_all_fs;$/;"	v	file:
show_date	date.c	/^show_date (const char *format, struct timespec when)$/;"	f	file:	signature:(const char *format, struct timespec when)
show_date	date.c	/^static bool show_date (const char *format, struct timespec when);$/;"	p	file:	signature:(const char *format, struct timespec when)
show_date	du.c	/^show_date (const char *format, struct timespec when)$/;"	f	file:	signature:(const char *format, struct timespec when)
show_listed_fs	df.c	/^static bool show_listed_fs;$/;"	v	file:
show_local_fs	df.c	/^static bool show_local_fs;$/;"	v	file:
sighandler	ls.c	/^sighandler (int sig)$/;"	f	file:	signature:(int sig)
sighandler	sort.c	/^sighandler (int sig)$/;"	f	file:	signature:(int sig)
siginfo_handler	dd.c	/^siginfo_handler (int sig)$/;"	f	file:	signature:(int sig)
siginterrupt	dd.c	55;"	d	file:
siginterrupt	ls.c	72;"	d	file:
siginterrupt	sort.c	81;"	d	file:
sigprocmask	dd.c	52;"	d	file:
sigprocmask	ls.c	69;"	d	file:
sigprocmask	sort.c	78;"	d	file:
sigs	sort.c	/^  sigset_t sigs;$/;"	m	struct:cs_status	file:	access:public
sigset_t	dd.c	53;"	d	file:
sigset_t	ls.c	70;"	d	file:
sigset_t	sort.c	79;"	d	file:
silent	tty.c	/^static bool silent;$/;"	v	file:
simple_cat	cat.c	/^simple_cat ($/;"	f	file:	signature:( char *buf, size_t bufsize)
simple_round	numfmt.c	/^simple_round (long double val, enum round_type t)$/;"	f	file:	signature:(long double val, enum round_type t)
simple_round_ceiling	numfmt.c	/^simple_round_ceiling (long double val)$/;"	f	file:	signature:(long double val)
simple_round_floor	numfmt.c	/^simple_round_floor (long double val)$/;"	f	file:	signature:(long double val)
simple_round_from_zero	numfmt.c	/^simple_round_from_zero (long double val)$/;"	f	file:	signature:(long double val)
simple_round_nearest	numfmt.c	/^simple_round_nearest (long double val)$/;"	f	file:	signature:(long double val)
simple_round_to_zero	numfmt.c	/^simple_round_to_zero (long double val)$/;"	f	file:	signature:(long double val)
simple_strtod_error	numfmt.c	/^enum simple_strtod_error$/;"	g	file:
simple_strtod_fatal	numfmt.c	/^simple_strtod_fatal (enum simple_strtod_error err, char const *input_str)$/;"	f	file:	signature:(enum simple_strtod_error err, char const *input_str)
simple_strtod_float	numfmt.c	/^simple_strtod_float (const char *input_str,$/;"	f	file:	signature:(const char *input_str, char **endptr, long double *value, size_t *precision)
simple_strtod_human	numfmt.c	/^simple_strtod_human (const char *input_str,$/;"	f	file:	signature:(const char *input_str, char **endptr, long double *value, size_t *precision, enum scale_type allowed_scaling)
simple_strtod_int	numfmt.c	/^simple_strtod_int (const char *input_str,$/;"	f	file:	signature:(const char *input_str, char **endptr, long double *value, bool *negative)
simple_strtoul	od.c	/^simple_strtoul (const char *s, const char **p, unsigned long int *val)$/;"	f	file:	signature:(const char *s, const char **p, unsigned long int *val)
size	du.c	/^  uintmax_t size;$/;"	m	struct:duinfo	file:	access:public
size	od.c	/^    enum size_spec size; \/* Type of input object.  *\/$/;"	m	struct:tspec	typeref:enum:tspec::size_spec	file:	access:public
size	ptx.c	/^    short int size;		\/* length of the region *\/$/;"	m	struct:__anon30	file:	access:public
size	shred.c	/^  off_t size;		\/* -s flag: size of file *\/$/;"	m	struct:Options	file:	access:public
size	stdbuf.c	/^  size_t size;$/;"	m	struct:__anon20	file:	access:public
size	tail.c	/^  off_t size;$/;"	m	struct:File_spec	file:	access:public
size_opt	uniq.c	/^size_opt (char const *opt, char const *msgid)$/;"	f	file:	signature:(char const *opt, char const *msgid)
size_spec	od.c	/^enum size_spec$/;"	g	file:
skip	dd.c	/^skip (int fdesc, char const *file, uintmax_t records, size_t blocksize,$/;"	f	file:	signature:(int fdesc, char const *file, uintmax_t records, size_t blocksize, size_t *bytes, char *buf)
skip	od.c	/^skip (uintmax_t n_skip)$/;"	f	file:	signature:(uintmax_t n_skip)
skip_bytes	dd.c	/^static size_t skip_bytes = 0;$/;"	v	file:
skip_chars	uniq.c	/^static size_t skip_chars;$/;"	v	file:
skip_construct	tr.c	/^skip_construct (struct Spec_list *s)$/;"	f	file:	signature:(struct Spec_list *s)
skip_count	pr.c	/^static bool skip_count = true;$/;"	v	file:
skip_fields	numfmt.c	/^skip_fields (char *buf, int fields)$/;"	f	signature:(char *buf, int fields)
skip_fields	uniq.c	/^static size_t skip_fields;$/;"	v	file:
skip_read	pr.c	/^skip_read (COLUMN *p, int column_number)$/;"	f	file:	signature:(COLUMN *p, int column_number)
skip_read	pr.c	/^static void skip_read (COLUMN *p, int column_number);$/;"	p	file:	signature:(COLUMN *p, int column_number)
skip_records	dd.c	/^static uintmax_t skip_records = 0;$/;"	v	file:
skip_to_page	pr.c	/^skip_to_page (uintmax_t page)$/;"	f	file:	signature:(uintmax_t page)
skip_to_page	pr.c	/^static bool skip_to_page (uintmax_t page);$/;"	p	file:	signature:(uintmax_t page)
skip_via_lseek	dd.c	/^skip_via_lseek (char const *filename, int fdesc, off_t offset, int whence)$/;"	f	file:	signature:(char const *filename, int fdesc, off_t offset, int whence)
skip_via_lseek	dd.c	1524;"	d	file:
skipeblanks	sort.c	/^  bool skipeblanks;		\/* Skip leading blanks when finding end.  *\/$/;"	m	struct:keyfield	file:	access:public
skipsblanks	sort.c	/^  bool skipsblanks;		\/* Skip leading blanks when finding start.  *\/$/;"	m	struct:keyfield	file:	access:public
slack_codes	dircolors.c	/^static const char *const slack_codes[] =$/;"	v	file:
slash	ls.c	/^    slash,	\/* -p, --indicator-style=slash *\/$/;"	e	enum:indicator_style	file:
slash_offset	cp.c	/^  size_t slash_offset;$/;"	m	struct:dir_attr	file:	access:public
smul_ppmm	longlong.h	1373;"	d
smul_ppmm	longlong.h	1383;"	d
smul_ppmm	longlong.h	1473;"	d
smul_ppmm	longlong.h	1516;"	d
smul_ppmm	longlong.h	1779;"	d
smul_ppmm	longlong.h	1994;"	d
smul_ppmm	longlong.h	475;"	d
smul_ppmm	longlong.h	569;"	d
smul_ppmm	longlong.h	595;"	d
smul_ppmm	longlong.h	782;"	d
sock	ls.c	/^    sock,$/;"	e	enum:filetype	file:
sort	sort.c	/^sort (char *const *files, size_t nfiles, char const *output_file,$/;"	f	file:	signature:(char *const *files, size_t nfiles, char const *output_file, size_t nthreads)
sort_args	ls.c	/^static char const *const sort_args[] =$/;"	v	file:
sort_args	sort.c	/^static char const *const sort_args[] =$/;"	v	file:
sort_buffer_size	sort.c	/^sort_buffer_size (FILE *const *fps, size_t nfps,$/;"	f	file:	signature:(FILE *const *fps, size_t nfps, char *const *files, size_t nfiles, size_t line_bytes)
sort_extension	ls.c	/^    sort_extension,		\/* -X *\/$/;"	e	enum:sort_type	file:
sort_files	ls.c	/^sort_files (void)$/;"	f	file:	signature:(void)
sort_files	ls.c	/^static void sort_files (void);$/;"	p	file:	signature:(void)
sort_found_occurs	ptx.c	/^sort_found_occurs (void)$/;"	f	file:	signature:(void)
sort_functions	ls.c	/^static qsortFunc const sort_functions[][2][2][2] =$/;"	v	file:
sort_name	ls.c	/^    sort_name,			\/* default *\/$/;"	e	enum:sort_type	file:
sort_none	ls.c	/^    sort_none = -1,		\/* -U *\/$/;"	e	enum:sort_type	file:
sort_numtypes	ls.c	/^    sort_numtypes		\/* the number of elements of this enum *\/$/;"	e	enum:sort_type	file:
sort_reverse	ls.c	/^static bool sort_reverse;$/;"	v	file:
sort_size	ls.c	/^    sort_size,			\/* -S *\/$/;"	e	enum:sort_type	file:
sort_size	sort.c	/^static size_t sort_size;$/;"	v	file:
sort_time	ls.c	/^    sort_time,			\/* -t *\/$/;"	e	enum:sort_type	file:
sort_type	ls.c	/^enum sort_type$/;"	g	file:
sort_type	ls.c	/^static enum sort_type sort_type;$/;"	v	typeref:enum:sort_type	file:
sort_types	ls.c	/^static enum sort_type const sort_types[] =$/;"	v	file:
sort_types	sort.c	/^static char const sort_types[] =$/;"	v	file:
sort_version	ls.c	/^    sort_version,		\/* -v *\/$/;"	e	enum:sort_type	file:
sorted_file	ls.c	/^static void **sorted_file;$/;"	v	file:
sorted_file_alloc	ls.c	/^static size_t sorted_file_alloc;$/;"	v	file:
sortfile	sort.c	/^struct sortfile$/;"	s	file:
sortfile::name	sort.c	/^  char const *name;$/;"	m	struct:sortfile	file:	access:public
sortfile::temp	sort.c	/^  struct tempnode *temp;$/;"	m	struct:sortfile	typeref:struct:sortfile::tempnode	file:	access:public
sortlines	sort.c	/^sortlines (struct line *restrict lines, size_t nthreads,$/;"	f	file:	signature:(struct line *restrict lines, size_t nthreads, size_t total_lines, struct merge_node *node, struct merge_node_queue *queue, FILE *tfp, char const *temp_output)
sortlines	sort.c	/^static void sortlines (struct line *restrict, size_t, size_t,$/;"	p	file:	signature:(struct line *restrict, size_t, size_t, struct merge_node *, struct merge_node_queue *, FILE *, char const *)
sortlines_thread	sort.c	/^sortlines_thread (void *data)$/;"	f	file:	signature:(void *data)
space	fmt.c	/^    int space;			\/* the size of the following space *\/$/;"	m	struct:Word	file:	access:public
space_character	dd.c	/^static char space_character = ' ';$/;"	v	file:
spaces_not_printed	pr.c	/^static int spaces_not_printed;$/;"	v	file:
spareline	join.c	/^static struct line *spareline[2] = {NULL, NULL};$/;"	v	typeref:struct:line	file:
sparse_copy	copy.c	/^sparse_copy (int src_fd, int dest_fd, char *buf, size_t buf_size,$/;"	f	file:	signature:(int src_fd, int dest_fd, char *buf, size_t buf_size, bool make_holes, char const *src_name, char const *dst_name, uintmax_t max_n_read, off_t *total_n_read, bool *last_write_made_hole)
sparse_mode	copy.h	/^  enum Sparse_type sparse_mode;$/;"	m	struct:cp_options	typeref:enum:cp_options::Sparse_type	access:public
sparse_type	cp.c	/^static enum Sparse_type const sparse_type[] =$/;"	v	file:
sparse_type_string	cp.c	/^static char const *const sparse_type_string[] =$/;"	v	file:
spec	od.c	/^static struct tspec *spec;$/;"	v	typeref:struct:tspec	file:
spec_init	tr.c	/^spec_init (struct Spec_list *spec_list)$/;"	f	file:	signature:(struct Spec_list *spec_list)
specified_context	chcon.c	/^static char const *specified_context;$/;"	v	file:
specified_range	chcon.c	/^static char const *specified_range;$/;"	v	file:
specified_role	chcon.c	/^static char const *specified_role;$/;"	v	file:
specified_type	chcon.c	/^static char const *specified_type;$/;"	v	file:
specified_user	chcon.c	/^static char const *specified_user;$/;"	v	file:
specify_nmerge	sort.c	/^specify_nmerge (int oi, char c, char const *s)$/;"	f	file:	signature:(int oi, char c, char const *s)
specify_nthreads	sort.c	/^specify_nthreads (int oi, char c, char const *s)$/;"	f	file:	signature:(int oi, char c, char const *s)
specify_sort_size	sort.c	/^specify_sort_size (int oi, char c, char const *s)$/;"	f	file:	signature:(int oi, char c, char const *s)
speed	stty.c	/^  speed_t speed;		\/* Internal form. *\/$/;"	m	struct:speed_map	file:	access:public
speed_map	stty.c	/^struct speed_map$/;"	s	file:
speed_map::speed	stty.c	/^  speed_t speed;		\/* Internal form. *\/$/;"	m	struct:speed_map	file:	access:public
speed_map::string	stty.c	/^  const char *string;		\/* ASCII representation. *\/$/;"	m	struct:speed_map	file:	access:public
speed_map::value	stty.c	/^  unsigned long int value;	\/* Numeric value. *\/$/;"	m	struct:speed_map	file:	access:public
speed_setting	stty.c	/^enum speed_setting$/;"	g	file:
speeds	stty.c	/^static struct speed_map const speeds[] =$/;"	v	file:
split	fmt.c	/^static bool split;$/;"	v	file:
split_3	md5sum.c	/^split_3 (char *s, size_t s_len,$/;"	f	file:	signature:(char *s, size_t s_len, unsigned char **hex_digest, int *binary, char **file_name)
split_file	csplit.c	/^split_file (void)$/;"	f	file:	signature:(void)
squeeze_filter	tr.c	/^squeeze_filter (char *buf, size_t size, size_t (*reader) (char *, size_t))$/;"	f	file:	signature:(char *buf, size_t size, size_t (*reader) (char *, size_t))
squeeze_repeats	tr.c	/^static bool squeeze_repeats = false;$/;"	v	file:
src___LDADD	local.mk	/^src___LDADD = $(src_test_LDADD)$/;"	m
src___SOURCES	local.mk	/^src___SOURCES = src\/lbracket.c$/;"	m
src_arch_LDADD	local.mk	/^src_arch_LDADD = $(LDADD)$/;"	m
src_arch_SOURCES	local.mk	/^src_arch_SOURCES = src\/uname.c src\/uname-arch.c$/;"	m
src_base64_LDADD	local.mk	/^src_base64_LDADD = $(LDADD)$/;"	m
src_basename_LDADD	local.mk	/^src_basename_LDADD = $(LDADD)$/;"	m
src_cat_LDADD	local.mk	/^src_cat_LDADD = $(LDADD)$/;"	m
src_chcon_LDADD	local.mk	/^src_chcon_LDADD = $(LDADD)$/;"	m
src_chgrp_LDADD	local.mk	/^src_chgrp_LDADD = $(LDADD)$/;"	m
src_chgrp_SOURCES	local.mk	/^src_chgrp_SOURCES = src\/chgrp.c src\/chown-core.c$/;"	m
src_chmod_LDADD	local.mk	/^src_chmod_LDADD = $(LDADD)$/;"	m
src_chown_LDADD	local.mk	/^src_chown_LDADD = $(LDADD)$/;"	m
src_chown_SOURCES	local.mk	/^src_chown_SOURCES = src\/chown.c src\/chown-core.c$/;"	m
src_chroot_LDADD	local.mk	/^src_chroot_LDADD = $(LDADD)$/;"	m
src_cksum_LDADD	local.mk	/^src_cksum_LDADD = $(LDADD)$/;"	m
src_comm_LDADD	local.mk	/^src_comm_LDADD = $(LDADD)$/;"	m
src_cp_LDADD	local.mk	/^src_cp_LDADD = $(LDADD)$/;"	m
src_cp_SOURCES	local.mk	/^src_cp_SOURCES = src\/cp.c $(copy_sources)$/;"	m
src_csplit_LDADD	local.mk	/^src_csplit_LDADD = $(LDADD)$/;"	m
src_cut_LDADD	local.mk	/^src_cut_LDADD = $(LDADD)$/;"	m
src_date_LDADD	local.mk	/^src_date_LDADD = $(LDADD)$/;"	m
src_dd_LDADD	local.mk	/^src_dd_LDADD = $(LDADD)$/;"	m
src_df_LDADD	local.mk	/^src_df_LDADD = $(LDADD)$/;"	m
src_df_SOURCES	local.mk	/^src_df_SOURCES = src\/df.c src\/find-mount-point.c$/;"	m
src_dir_LDADD	local.mk	/^src_dir_LDADD = $(src_ls_LDADD)$/;"	m
src_dir_SOURCES	local.mk	/^src_dir_SOURCES = src\/ls.c src\/ls-dir.c$/;"	m
src_dircolors_LDADD	local.mk	/^src_dircolors_LDADD = $(LDADD)$/;"	m
src_dirname_LDADD	local.mk	/^src_dirname_LDADD = $(LDADD)$/;"	m
src_du_LDADD	local.mk	/^src_du_LDADD = $(LDADD)$/;"	m
src_echo_LDADD	local.mk	/^src_echo_LDADD = $(LDADD)$/;"	m
src_env_LDADD	local.mk	/^src_env_LDADD = $(LDADD)$/;"	m
src_expand_LDADD	local.mk	/^src_expand_LDADD = $(LDADD)$/;"	m
src_expr_LDADD	local.mk	/^src_expr_LDADD = $(LDADD)$/;"	m
src_factor_LDADD	local.mk	/^src_factor_LDADD = $(LDADD)$/;"	m
src_false_LDADD	local.mk	/^src_false_LDADD = $(LDADD)$/;"	m
src_fmt_LDADD	local.mk	/^src_fmt_LDADD = $(LDADD)$/;"	m
src_fold_LDADD	local.mk	/^src_fold_LDADD = $(LDADD)$/;"	m
src_getlimits_LDADD	local.mk	/^src_getlimits_LDADD = $(LDADD)$/;"	m
src_ginstall_CPPFLAGS	local.mk	/^src_ginstall_CPPFLAGS = -DENABLE_MATCHPATHCON=1 $(AM_CPPFLAGS)$/;"	m
src_ginstall_LDADD	local.mk	/^src_ginstall_LDADD = $(LDADD)$/;"	m
src_ginstall_SOURCES	local.mk	/^src_ginstall_SOURCES = src\/install.c src\/prog-fprintf.c $(copy_sources)$/;"	m
src_groups_LDADD	local.mk	/^src_groups_LDADD = $(LDADD)$/;"	m
src_groups_SOURCES	local.mk	/^src_groups_SOURCES = src\/groups.c src\/group-list.c$/;"	m
src_head_LDADD	local.mk	/^src_head_LDADD = $(LDADD)$/;"	m
src_hostid_LDADD	local.mk	/^src_hostid_LDADD = $(LDADD)$/;"	m
src_hostname_LDADD	local.mk	/^src_hostname_LDADD = $(LDADD)$/;"	m
src_id_LDADD	local.mk	/^src_id_LDADD = $(LDADD)$/;"	m
src_id_SOURCES	local.mk	/^src_id_SOURCES = src\/id.c src\/group-list.c$/;"	m
src_info	copy.h	/^  Hash_table *src_info;$/;"	m	struct:cp_options	access:public
src_info_init	copy.c	/^src_info_init (struct cp_options *x)$/;"	f	signature:(struct cp_options *x)
src_info_init	copy.h	/^void src_info_init (struct cp_options *);$/;"	p	signature:(struct cp_options *)
src_join_LDADD	local.mk	/^src_join_LDADD = $(LDADD)$/;"	m
src_kill_LDADD	local.mk	/^src_kill_LDADD = $(LDADD)$/;"	m
src_kill_SOURCES	local.mk	/^src_kill_SOURCES = src\/kill.c src\/operand2sig.c$/;"	m
src_libstdbuf_so_CFLAGS	local.mk	/^src_libstdbuf_so_CFLAGS = -fPIC $(AM_CFLAGS)$/;"	m
src_libstdbuf_so_LDADD	local.mk	/^src_libstdbuf_so_LDADD =$/;"	m
src_libstdbuf_so_LDFLAGS	local.mk	/^src_libstdbuf_so_LDFLAGS = -shared$/;"	m
src_link_LDADD	local.mk	/^src_link_LDADD = $(LDADD)$/;"	m
src_ln_LDADD	local.mk	/^src_ln_LDADD = $(LDADD)$/;"	m
src_ln_SOURCES	local.mk	/^src_ln_SOURCES = src\/ln.c src\/relpath.c src\/relpath.h$/;"	m
src_logname_LDADD	local.mk	/^src_logname_LDADD = $(LDADD)$/;"	m
src_ls_LDADD	local.mk	/^src_ls_LDADD = $(LDADD)$/;"	m
src_ls_SOURCES	local.mk	/^src_ls_SOURCES = src\/ls.c src\/ls-ls.c$/;"	m
src_make_prime_list_LDADD	local.mk	/^src_make_prime_list_LDADD =$/;"	m
src_md5sum_CPPFLAGS	local.mk	/^src_md5sum_CPPFLAGS = -DHASH_ALGO_MD5=1 $(AM_CPPFLAGS)$/;"	m
src_md5sum_LDADD	local.mk	/^src_md5sum_LDADD = $(LDADD)$/;"	m
src_mkdir_LDADD	local.mk	/^src_mkdir_LDADD = $(LDADD)$/;"	m
src_mkdir_SOURCES	local.mk	/^src_mkdir_SOURCES = src\/mkdir.c src\/prog-fprintf.c$/;"	m
src_mkfifo_LDADD	local.mk	/^src_mkfifo_LDADD = $(LDADD)$/;"	m
src_mknod_LDADD	local.mk	/^src_mknod_LDADD = $(LDADD)$/;"	m
src_mktemp_LDADD	local.mk	/^src_mktemp_LDADD = $(LDADD)$/;"	m
src_mv_LDADD	local.mk	/^src_mv_LDADD = $(LDADD)$/;"	m
src_mv_SOURCES	local.mk	/^src_mv_SOURCES = src\/mv.c src\/remove.c $(copy_sources)$/;"	m
src_nice_LDADD	local.mk	/^src_nice_LDADD = $(LDADD)$/;"	m
src_nl_LDADD	local.mk	/^src_nl_LDADD = $(LDADD)$/;"	m
src_nohup_LDADD	local.mk	/^src_nohup_LDADD = $(LDADD)$/;"	m
src_nproc_LDADD	local.mk	/^src_nproc_LDADD = $(LDADD)$/;"	m
src_od_LDADD	local.mk	/^src_od_LDADD = $(LDADD)$/;"	m
src_paste_LDADD	local.mk	/^src_paste_LDADD = $(LDADD)$/;"	m
src_pathchk_LDADD	local.mk	/^src_pathchk_LDADD = $(LDADD)$/;"	m
src_pinky_LDADD	local.mk	/^src_pinky_LDADD = $(LDADD)$/;"	m
src_pr_LDADD	local.mk	/^src_pr_LDADD = $(LDADD)$/;"	m
src_printenv_LDADD	local.mk	/^src_printenv_LDADD = $(LDADD)$/;"	m
src_printf_LDADD	local.mk	/^src_printf_LDADD = $(LDADD)$/;"	m
src_ptx_LDADD	local.mk	/^src_ptx_LDADD = $(LDADD)$/;"	m
src_pwd_LDADD	local.mk	/^src_pwd_LDADD = $(LDADD)$/;"	m
src_readlink_LDADD	local.mk	/^src_readlink_LDADD = $(LDADD)$/;"	m
src_realpath_LDADD	local.mk	/^src_realpath_LDADD = $(LDADD)$/;"	m
src_realpath_SOURCES	local.mk	/^src_realpath_SOURCES = src\/realpath.c src\/relpath.c src\/relpath.h$/;"	m
src_rm_LDADD	local.mk	/^src_rm_LDADD = $(LDADD)$/;"	m
src_rm_SOURCES	local.mk	/^src_rm_SOURCES = src\/rm.c src\/remove.c$/;"	m
src_rmdir_LDADD	local.mk	/^src_rmdir_LDADD = $(LDADD)$/;"	m
src_rmdir_SOURCES	local.mk	/^src_rmdir_SOURCES = src\/rmdir.c src\/prog-fprintf.c$/;"	m
src_runcon_LDADD	local.mk	/^src_runcon_LDADD = $(LDADD)$/;"	m
src_seq_LDADD	local.mk	/^src_seq_LDADD = $(LDADD)$/;"	m
src_setuidgid_LDADD	local.mk	/^src_setuidgid_LDADD = $(LDADD)$/;"	m
src_sha1sum_CPPFLAGS	local.mk	/^src_sha1sum_CPPFLAGS = -DHASH_ALGO_SHA1=1 $(AM_CPPFLAGS)$/;"	m
src_sha1sum_LDADD	local.mk	/^src_sha1sum_LDADD = $(LDADD)$/;"	m
src_sha1sum_SOURCES	local.mk	/^src_sha1sum_SOURCES = src\/md5sum.c$/;"	m
src_sha224sum_CPPFLAGS	local.mk	/^src_sha224sum_CPPFLAGS = -DHASH_ALGO_SHA224=1 $(AM_CPPFLAGS)$/;"	m
src_sha224sum_LDADD	local.mk	/^src_sha224sum_LDADD = $(LDADD)$/;"	m
src_sha224sum_SOURCES	local.mk	/^src_sha224sum_SOURCES = src\/md5sum.c$/;"	m
src_sha256sum_CPPFLAGS	local.mk	/^src_sha256sum_CPPFLAGS = -DHASH_ALGO_SHA256=1 $(AM_CPPFLAGS)$/;"	m
src_sha256sum_LDADD	local.mk	/^src_sha256sum_LDADD = $(LDADD)$/;"	m
src_sha256sum_SOURCES	local.mk	/^src_sha256sum_SOURCES = src\/md5sum.c$/;"	m
src_sha384sum_CPPFLAGS	local.mk	/^src_sha384sum_CPPFLAGS = -DHASH_ALGO_SHA384=1 $(AM_CPPFLAGS)$/;"	m
src_sha384sum_LDADD	local.mk	/^src_sha384sum_LDADD = $(LDADD)$/;"	m
src_sha384sum_SOURCES	local.mk	/^src_sha384sum_SOURCES = src\/md5sum.c$/;"	m
src_sha512sum_CPPFLAGS	local.mk	/^src_sha512sum_CPPFLAGS = -DHASH_ALGO_SHA512=1 $(AM_CPPFLAGS)$/;"	m
src_sha512sum_LDADD	local.mk	/^src_sha512sum_LDADD = $(LDADD)$/;"	m
src_sha512sum_SOURCES	local.mk	/^src_sha512sum_SOURCES = src\/md5sum.c$/;"	m
src_shred_LDADD	local.mk	/^src_shred_LDADD = $(LDADD)$/;"	m
src_shuf_LDADD	local.mk	/^src_shuf_LDADD = $(LDADD)$/;"	m
src_sleep_LDADD	local.mk	/^src_sleep_LDADD = $(LDADD)$/;"	m
src_sort_LDADD	local.mk	/^src_sort_LDADD = $(LDADD)$/;"	m
src_split_LDADD	local.mk	/^src_split_LDADD = $(LDADD)$/;"	m
src_stat_LDADD	local.mk	/^src_stat_LDADD = $(LDADD)$/;"	m
src_stat_SOURCES	local.mk	/^src_stat_SOURCES = src\/stat.c src\/find-mount-point.c$/;"	m
src_stdbuf_LDADD	local.mk	/^src_stdbuf_LDADD = $(LDADD)$/;"	m
src_stty_LDADD	local.mk	/^src_stty_LDADD = $(LDADD)$/;"	m
src_sum_LDADD	local.mk	/^src_sum_LDADD = $(LDADD)$/;"	m
src_sync_LDADD	local.mk	/^src_sync_LDADD = $(LDADD)$/;"	m
src_tac_LDADD	local.mk	/^src_tac_LDADD = $(LDADD)$/;"	m
src_tail_LDADD	local.mk	/^src_tail_LDADD = $(LDADD)$/;"	m
src_tee_LDADD	local.mk	/^src_tee_LDADD = $(LDADD)$/;"	m
src_test_LDADD	local.mk	/^src_test_LDADD = $(LDADD)$/;"	m
src_timeout_LDADD	local.mk	/^src_timeout_LDADD = $(LDADD)$/;"	m
src_timeout_SOURCES	local.mk	/^src_timeout_SOURCES = src\/timeout.c src\/operand2sig.c$/;"	m
src_to_dest	cp-hash.c	/^static Hash_table *src_to_dest;$/;"	v	file:
src_to_dest_compare	cp-hash.c	/^src_to_dest_compare (void const *x, void const *y)$/;"	f	file:	signature:(void const *x, void const *y)
src_to_dest_free	cp-hash.c	/^src_to_dest_free (void *x)$/;"	f	file:	signature:(void *x)
src_to_dest_hash	cp-hash.c	/^src_to_dest_hash (void const *x, size_t table_size)$/;"	f	file:	signature:(void const *x, size_t table_size)
src_to_dest_lookup	cp-hash.c	/^src_to_dest_lookup (ino_t ino, dev_t dev)$/;"	f	signature:(ino_t ino, dev_t dev)
src_to_dest_lookup	cp-hash.h	/^char *src_to_dest_lookup (ino_t ino, dev_t dev);$/;"	p	signature:(ino_t ino, dev_t dev)
src_touch_LDADD	local.mk	/^src_touch_LDADD = $(LDADD)$/;"	m
src_tr_LDADD	local.mk	/^src_tr_LDADD = $(LDADD)$/;"	m
src_true_LDADD	local.mk	/^src_true_LDADD = $(LDADD)$/;"	m
src_truncate_LDADD	local.mk	/^src_truncate_LDADD = $(LDADD)$/;"	m
src_tsort_LDADD	local.mk	/^src_tsort_LDADD = $(LDADD)$/;"	m
src_tty_LDADD	local.mk	/^src_tty_LDADD = $(LDADD)$/;"	m
src_uname_LDADD	local.mk	/^src_uname_LDADD = $(LDADD)$/;"	m
src_uname_SOURCES	local.mk	/^src_uname_SOURCES = src\/uname.c src\/uname-uname.c$/;"	m
src_unexpand_LDADD	local.mk	/^src_unexpand_LDADD = $(LDADD)$/;"	m
src_uniq_LDADD	local.mk	/^src_uniq_LDADD = $(LDADD)$/;"	m
src_unlink_LDADD	local.mk	/^src_unlink_LDADD = $(LDADD)$/;"	m
src_uptime_LDADD	local.mk	/^src_uptime_LDADD = $(LDADD)$/;"	m
src_users_LDADD	local.mk	/^src_users_LDADD = $(LDADD)$/;"	m
src_vdir_LDADD	local.mk	/^src_vdir_LDADD = $(src_ls_LDADD)$/;"	m
src_vdir_SOURCES	local.mk	/^src_vdir_SOURCES = src\/ls.c src\/ls-vdir.c$/;"	m
src_wc_LDADD	local.mk	/^src_wc_LDADD = $(LDADD)$/;"	m
src_who_LDADD	local.mk	/^src_who_LDADD = $(LDADD)$/;"	m
src_whoami_LDADD	local.mk	/^src_whoami_LDADD = $(LDADD)$/;"	m
src_yes_LDADD	local.mk	/^src_yes_LDADD = $(LDADD)$/;"	m
st	cp.c	/^  struct stat st;$/;"	m	struct:dir_attr	typeref:struct:dir_attr::stat	file:	access:public
st	wc.c	/^  struct stat st;$/;"	m	struct:fstatus	typeref:struct:fstatus::stat	file:	access:public
st_author	ls.c	154;"	d	file:
st_dev	cp-hash.c	/^  dev_t st_dev;$/;"	m	struct:Src_to_dest	file:	access:public
st_ino	cp-hash.c	/^  ino_t st_ino;$/;"	m	struct:Src_to_dest	file:	access:public
stable	sort.c	/^static bool stable;$/;"	v	file:
star_digits_closebracket	tr.c	/^star_digits_closebracket (const struct E_string *es, size_t idx)$/;"	f	file:	signature:(const struct E_string *es, size_t idx)
start	ptx.c	/^    WORD *start;		\/* array of WORDs *\/$/;"	m	struct:__anon31	file:	access:public
start	ptx.c	/^    char *start;		\/* pointer to beginning of region *\/$/;"	m	struct:__anon29	file:	access:public
start	ptx.c	/^    char *start;		\/* pointer to beginning of region *\/$/;"	m	struct:__anon30	file:	access:public
start	pwd.c	/^  char *start;$/;"	m	struct:file_name	file:	access:public
start	tac-pipe.c	/^  char *start;$/;"	m	struct:B_pair	file:	access:public
start_bytes	tail.c	/^start_bytes (const char *pretty_filename, int fd, uintmax_t n_bytes,$/;"	f	file:	signature:(const char *pretty_filename, int fd, uintmax_t n_bytes, uintmax_t *read_pos)
start_line	csplit.c	/^  uintmax_t start_line;		\/* First line number in this buffer. *\/$/;"	m	struct:buffer_record	file:	access:public
start_line_num	pr.c	/^static int start_line_num = 1;$/;"	v	file:
start_lines	tail.c	/^start_lines (const char *pretty_filename, int fd, uintmax_t n_lines,$/;"	f	file:	signature:(const char *pretty_filename, int fd, uintmax_t n_lines, uintmax_t *read_pos)
start_position	pr.c	/^    int start_position;		\/* Horizontal position of first char. *\/$/;"	m	struct:COLUMN	file:	access:public
start_time	dd.c	/^static xtime_t start_time;$/;"	v	file:
starting_line_number	nl.c	/^static intmax_t starting_line_number = 1;$/;"	v	file:
starts	csplit.c	/^  struct cstring starts[CTRL_SIZE]; \/* Lines in the data area. *\/$/;"	m	struct:line	typeref:struct:line::cstring	file:	access:public
stat	ls.c	/^    struct stat stat;$/;"	m	struct:fileinfo	typeref:struct:fileinfo::stat	file:	access:public
stat_ok	ls.c	/^    bool stat_ok;$/;"	m	struct:fileinfo	file:	access:public
state	sort.c	/^  char state;$/;"	m	struct:tempnode	file:	access:public
state	tr.c	/^    count state;$/;"	m	struct:Spec_list	file:	access:public
statfs	stat.c	/^statfs (char const *filename, struct fs_info *buf)$/;"	f	file:	signature:(char const *filename, struct fs_info *buf)
status	pr.c	/^    status;			\/* Status of the file pointer. *\/$/;"	m	struct:COLUMN	typeref:enum:COLUMN::__anon11	file:	access:public
status_flags	dd.c	/^static int status_flags = 0;$/;"	v	file:
status_only	md5sum.c	/^static bool status_only = false;$/;"	v	file:
statuses	dd.c	/^static struct symbol_value const statuses[] =$/;"	v	file:
stdbuf	libstdbuf.c	/^stdbuf (void)$/;"	f	file:	signature:(void)
stdbuf	stdbuf.c	/^} stdbuf[3];$/;"	v	typeref:struct:__anon20	file:
stdin_argv	expand.c	/^static char *stdin_argv[] =$/;"	v	file:
stdin_argv	unexpand.c	/^static char *stdin_argv[] =$/;"	v	file:
stdin_tty	copy.h	/^  bool stdin_tty;$/;"	m	struct:cp_options	access:public
stdin_tty	remove.h	/^  bool stdin_tty;$/;"	m	struct:rm_options	access:public
stdout_closed	mktemp.c	/^static bool stdout_closed;$/;"	v	file:
stop_signal_count	ls.c	/^static sig_atomic_t volatile stop_signal_count;$/;"	v	file:
stophandler	ls.c	/^stophandler (int sig)$/;"	f	file:	signature:(int sig)
store_char	pr.c	/^static void store_char (char c);$/;"	p	file:	signature:(char c)
store_char	pr.c	/^store_char (char c)$/;"	f	file:	signature:(char c)
store_columns	pr.c	/^static void store_columns (void);$/;"	p	file:	signature:(void)
store_columns	pr.c	/^store_columns (void)$/;"	f	file:	signature:(void)
storing_columns	pr.c	/^static bool storing_columns = true;$/;"	v	file:
str	csplit.c	/^  char *str;$/;"	m	struct:cstring	file:	access:public
str	tsort.c	/^  const char *str;$/;"	m	struct:item	file:	access:public
str_value	expr.c	/^str_value (char const *s)$/;"	f	file:	signature:(char const *s)
stream_open	sort.c	/^stream_open (char const *file, char const *how)$/;"	f	file:	signature:(char const *file, char const *how)
strerror	make-prime-list.c	33;"	d	file:
strict	md5sum.c	/^static bool strict = false;$/;"	v	file:
string	expr.c	/^  string$/;"	e	enum:valtype	file:
string	ls.c	/^    const char *string;		\/* Pointer to the same *\/$/;"	m	struct:bin_str	file:	access:public
string	ptx.c	/^  char const *string;$/;"	m	struct:regex_data	file:	access:public
string	stty.c	/^  const char *string;		\/* ASCII representation. *\/$/;"	m	struct:speed_map	file:	access:public
string2_extend	tr.c	/^string2_extend (const struct Spec_list *s1, struct Spec_list *s2)$/;"	f	file:	signature:(const struct Spec_list *s1, struct Spec_list *s2)
string_min	od.c	/^static size_t string_min;$/;"	v	file:
string_to_baud	stty.c	/^static speed_t string_to_baud (const char *arg);$/;"	p	file:	signature:(const char *arg)
string_to_baud	stty.c	/^string_to_baud (const char *arg)$/;"	f	file:	signature:(const char *arg)
string_to_integer	head.c	/^string_to_integer (bool count_lines, const char *n_string)$/;"	f	file:	signature:(bool count_lines, const char *n_string)
string_to_join_field	join.c	/^string_to_join_field (char const *str)$/;"	f	file:	signature:(char const *str)
strip	install.c	/^strip (char const *name)$/;"	f	file:	signature:(char const *name)
strip_files	install.c	/^static bool strip_files;$/;"	v	file:
strip_program	install.c	/^static char const *strip_program = "strip";$/;"	v	file:
strsignal	kill.c	44;"	d	file:
strsignal	kill.c	49;"	d	file:
strto2uintmax	factor.c	/^strto2uintmax (uintmax_t *hip, uintmax_t *lop, const char *s)$/;"	f	file:	signature:(uintmax_t *hip, uintmax_t *lop, const char *s)
strtold	sort.c	98;"	d	file:
strtold	sort.c	99;"	d	file:
strtoul_cc_t	stty.c	/^strtoul_cc_t (char const *s, int base, char **p, cc_t *result, char delim)$/;"	f	file:	signature:(char const *s, int base, char **p, cc_t *result, char delim)
strtoul_tcflag_t	stty.c	/^strtoul_tcflag_t (char const *s, int base, char **p, tcflag_t *result,$/;"	f	file:	signature:(char const *s, int base, char **p, tcflag_t *result, char delim)
struct_month_cmp	sort.c	/^struct_month_cmp (void const *m1, void const *m2)$/;"	f	file:	signature:(void const *m1, void const *m2)
stzncpy	system.h	/^stzncpy (char *restrict dest, char const *restrict src, size_t len)$/;"	f	signature:(char *restrict dest, char const *restrict src, size_t len)
sub_ddmmss	factor.c	333;"	d	file:
sub_ddmmss	longlong.h	1008;"	d
sub_ddmmss	longlong.h	1049;"	d
sub_ddmmss	longlong.h	1101;"	d
sub_ddmmss	longlong.h	1180;"	d
sub_ddmmss	longlong.h	1333;"	d
sub_ddmmss	longlong.h	1413;"	d
sub_ddmmss	longlong.h	1489;"	d
sub_ddmmss	longlong.h	1511;"	d
sub_ddmmss	longlong.h	1570;"	d
sub_ddmmss	longlong.h	1757;"	d
sub_ddmmss	longlong.h	1774;"	d
sub_ddmmss	longlong.h	1816;"	d
sub_ddmmss	longlong.h	1932;"	d
sub_ddmmss	longlong.h	300;"	d
sub_ddmmss	longlong.h	382;"	d
sub_ddmmss	longlong.h	416;"	d
sub_ddmmss	longlong.h	431;"	d
sub_ddmmss	longlong.h	536;"	d
sub_ddmmss	longlong.h	612;"	d
sub_ddmmss	longlong.h	635;"	d
sub_ddmmss	longlong.h	686;"	d
sub_ddmmss	longlong.h	705;"	d
sub_ddmmss	longlong.h	819;"	d
sub_ddmmss	longlong.h	867;"	d
subdir	du.c	/^  struct duinfo subdir;$/;"	m	struct:dulevel	typeref:struct:dulevel::duinfo	file:	access:public
subdired_obstack	ls.c	/^static struct obstack subdired_obstack;$/;"	v	typeref:struct:obstack	file:
submod	factor.c	370;"	d	file:
submod2	factor.c	388;"	d	file:
suc	tsort.c	/^  struct item *suc;$/;"	m	struct:successor	typeref:struct:successor::item	file:	access:public
successor	tsort.c	/^struct successor$/;"	s	file:
successor::next	tsort.c	/^  struct successor *next;$/;"	m	struct:successor	typeref:struct:successor::successor	file:	access:public
successor::suc	tsort.c	/^  struct item *suc;$/;"	m	struct:successor	typeref:struct:successor::item	file:	access:public
suffix	csplit.c	/^static char *volatile suffix = NULL;$/;"	v	file:
suffix	numfmt.c	/^static const char *suffix = NULL;$/;"	v	file:
suffix_alphabet	split.c	/^static char const *suffix_alphabet = "abcdefghijklmnopqrstuvwxyz";$/;"	v	file:
suffix_auto	split.c	/^static bool suffix_auto = true;$/;"	v	file:
suffix_len	seq.c	/^  size_t suffix_len;$/;"	m	struct:layout	file:	access:public
suffix_length	split.c	/^static size_t suffix_length;$/;"	v	file:
suffix_power	numfmt.c	/^suffix_power (const char suf)$/;"	f	file:	signature:(const char suf)
suffix_power_character	numfmt.c	/^suffix_power_character (unsigned int power)$/;"	f	file:	signature:(unsigned int power)
suppress_count	csplit.c	/^static bool suppress_count;$/;"	v	file:
suppress_non_delimited	cut.c	/^static bool suppress_non_delimited;$/;"	v	file:
swab_buffer	dd.c	/^swab_buffer (char *buf, size_t *nread)$/;"	f	file:	signature:(char *buf, size_t *nread)
swallow_file_in_memory	ptx.c	/^swallow_file_in_memory (const char *file_name, BLOCK *block)$/;"	f	file:	signature:(const char *file_name, BLOCK *block)
sword	sort.c	/^  size_t sword;			\/* Zero-origin 'word' to start at. *\/$/;"	m	struct:keyfield	file:	access:public
symbol	dd.c	/^  char symbol[sizeof LONGEST_SYMBOL];$/;"	m	struct:symbol_value	file:	access:public
symbol_value	dd.c	/^struct symbol_value$/;"	s	file:
symbol_value::symbol	dd.c	/^  char symbol[sizeof LONGEST_SYMBOL];$/;"	m	struct:symbol_value	file:	access:public
symbol_value::value	dd.c	/^  int value;$/;"	m	struct:symbol_value	file:	access:public
symbolic_link	copy.h	/^  bool symbolic_link;$/;"	m	struct:cp_options	access:public
symbolic_link	ln.c	/^static bool symbolic_link;$/;"	v	file:
symbolic_link	ls.c	/^    symbolic_link,$/;"	e	enum:filetype	file:
sync	system.h	456;"	d
syntax_error	expr.c	/^syntax_error (void)$/;"	f	file:	signature:(void)
sys_siglist	kill.c	38;"	d	file:
sys_siglist	kill.c	40;"	d	file:
sysv_sum_file	sum.c	/^sysv_sum_file (const char *file, int print_name)$/;"	f	file:	signature:(const char *file, int print_name)
tab	join.c	/^static int tab = -1;$/;"	v	file:
tab	sort.c	/^static int tab = TAB_DEFAULT;$/;"	v	file:
tab_list	expand.c	/^static uintmax_t *tab_list;$/;"	v	file:
tab_list	unexpand.c	/^static uintmax_t *tab_list;$/;"	v	file:
tab_size	expand.c	/^static uintmax_t tab_size;$/;"	v	file:
tab_size	unexpand.c	/^static size_t tab_size;$/;"	v	file:
tabify_output	pr.c	/^static bool tabify_output = false;$/;"	v	file:
table	df.c	/^static char ***table;$/;"	v	file:
tabs	fmt.c	/^static bool tabs;$/;"	v	file:
tabsize	ls.c	/^static size_t tabsize;$/;"	v	file:
tac_file	tac.c	/^tac_file (const char *filename)$/;"	f	file:	signature:(const char *filename)
tac_mem	tac-pipe.c	/^tac_mem ()$/;"	f	file:
tac_nonseekable	tac.c	/^tac_nonseekable (int input_fd, const char *file)$/;"	f	file:	signature:(int input_fd, const char *file)
tac_seekable	tac.c	/^tac_seekable (int input_fd, const char *file)$/;"	f	file:	signature:(int input_fd, const char *file)
tagged	fmt.c	/^static bool tagged;$/;"	v	file:
tail	ptx.c	/^static BLOCK tail;		\/* tail field *\/$/;"	v	file:
tail	tail.c	/^tail (const char *filename, int fd, uintmax_t n_units,$/;"	f	file:	signature:(const char *filename, int fd, uintmax_t n_units, uintmax_t *read_pos)
tail	tr.c	/^    struct List_element *tail;$/;"	m	struct:Spec_list	typeref:struct:Spec_list::List_element	file:	access:public
tail_bytes	tail.c	/^tail_bytes (const char *pretty_filename, int fd, uintmax_t n_bytes,$/;"	f	file:	signature:(const char *pretty_filename, int fd, uintmax_t n_bytes, uintmax_t *read_pos)
tail_file	tail.c	/^tail_file (struct File_spec *f, uintmax_t n_units)$/;"	f	file:	signature:(struct File_spec *f, uintmax_t n_units)
tail_forever	tail.c	/^tail_forever (struct File_spec *f, size_t n_files, double sleep_interval)$/;"	f	file:	signature:(struct File_spec *f, size_t n_files, double sleep_interval)
tail_forever_inotify	tail.c	/^tail_forever_inotify (int wd, struct File_spec *f, size_t n_files,$/;"	f	file:	signature:(int wd, struct File_spec *f, size_t n_files, double sleep_interval)
tail_lines	tail.c	/^tail_lines (const char *pretty_filename, int fd, uintmax_t n_lines,$/;"	f	file:	signature:(const char *pretty_filename, int fd, uintmax_t n_lines, uintmax_t *read_pos)
tail_truncation	ptx.c	/^static int tail_truncation;	\/* flag truncation after the tail field *\/$/;"	v	file:
tailable	tail.c	/^  bool tailable;$/;"	m	struct:File_spec	file:	access:public
tailable_stdin	tail.c	/^tailable_stdin (const struct File_spec *f, size_t n_files)$/;"	f	file:	signature:(const struct File_spec *f, size_t n_files)
target_directory_operand	cp.c	/^target_directory_operand (char const *file, struct stat *st, bool *new_dst)$/;"	f	file:	signature:(char const *file, struct stat *st, bool *new_dst)
target_directory_operand	install.c	/^target_directory_operand (char const *file)$/;"	f	file:	signature:(char const *file)
target_directory_operand	ln.c	/^target_directory_operand (char const *file)$/;"	f	file:	signature:(char const *file)
target_directory_operand	mv.c	/^target_directory_operand (char const *file)$/;"	f	file:	signature:(char const *file)
tcgetpgrp	ls.c	238;"	d	file:
tee_files	tee.c	/^static bool tee_files (int nfiles, const char **files);$/;"	p	file:	signature:(int nfiles, const char **files)
tee_files	tee.c	/^tee_files (int nfiles, const char **files)$/;"	f	file:	signature:(int nfiles, const char **files)
temp	sort.c	/^  struct tempnode *temp;$/;"	m	struct:sortfile	typeref:struct:sortfile::tempnode	file:	access:public
temp_dir_alloc	sort.c	/^static size_t temp_dir_alloc;$/;"	v	file:
temp_dir_count	sort.c	/^static size_t temp_dir_count;$/;"	v	file:
temp_dirs	sort.c	/^static char const **temp_dirs;$/;"	v	file:
temp_stream	tac.c	/^temp_stream (FILE **fp, char **file_name)$/;"	f	file:	signature:(FILE **fp, char **file_name)
temphead	sort.c	/^static struct tempnode *volatile temphead;$/;"	v	file:
tempnode	sort.c	/^struct tempnode$/;"	s	file:
tempnode::name	sort.c	/^  char name[1];  \/* Actual size is 1 + file name length.  *\/$/;"	m	struct:tempnode	file:	access:public
tempnode::next	sort.c	/^  struct tempnode *volatile next;$/;"	m	struct:tempnode	file:	access:public
tempnode::pid	sort.c	/^  pid_t pid;     \/* The subprocess PID; undefined if state == UNCOMPRESSED.  *\/$/;"	m	struct:tempnode	file:	access:public
tempnode::state	sort.c	/^  char state;$/;"	m	struct:tempnode	file:	access:public
temptail	sort.c	/^static struct tempnode *volatile *temptail = &temphead;$/;"	v	file:
term	test.c	/^static bool term (void);$/;"	p	file:	signature:(void)
term	test.c	/^term (void)$/;"	f	file:	signature:(void)
term_signal	timeout.c	/^static int term_signal = SIGTERM;  \/* same default as kill command.  *\/$/;"	v	file:
terminator	seq.c	/^static char const terminator[] = "\\n";$/;"	v	file:
test_error_return	test.c	/^   static int test_error_return = 0;$/;"	v	file:
test_exit	test.c	59;"	d	file:
test_exit	test.c	63;"	d	file:
test_exit_buf	test.c	/^   static jmp_buf test_exit_buf;$/;"	v	file:
test_syntax_error	test.c	/^test_syntax_error (char const *format, char const *arg)$/;"	f	file:	signature:(char const *format, char const *arg)
test_unop	test.c	/^static bool test_unop (char const *s);$/;"	p	file:	signature:(char const *s)
test_unop	test.c	/^test_unop (char const *op)$/;"	f	file:	signature:(char const *op)
text	fmt.c	/^    const char *text;		\/* the text of the word *\/$/;"	m	struct:Word	file:	access:public
text	sort.c	/^  char *text;			\/* Text of the line. *\/$/;"	m	struct:line	file:	access:public
text_buffer	ptx.c	/^static BLOCK text_buffer;	\/* file to study *\/$/;"	v	file:
textdomain	system.h	169;"	d
textdomain	system.h	170;"	d
tfp	sort.c	/^  FILE *tfp;$/;"	m	struct:thread_args	file:	access:public
the_repeated_char	tr.c	/^            unsigned char the_repeated_char;$/;"	m	struct:List_element::__anon3::__anon5	file:	access:public
thousands_sep	sort.c	/^static int thousands_sep;$/;"	v	file:
thread_args	sort.c	/^struct thread_args$/;"	s	file:
thread_args::lines	sort.c	/^  struct line *lines;$/;"	m	struct:thread_args	typeref:struct:thread_args::line	file:	access:public
thread_args::node	sort.c	/^  struct merge_node *const node;$/;"	m	struct:thread_args	file:	access:public
thread_args::nthreads	sort.c	/^  size_t nthreads;$/;"	m	struct:thread_args	file:	access:public
thread_args::output_temp	sort.c	/^  char const *output_temp;$/;"	m	struct:thread_args	file:	access:public
thread_args::queue	sort.c	/^  struct merge_node_queue *const queue;$/;"	m	struct:thread_args	file:	access:public
thread_args::tfp	sort.c	/^  FILE *tfp;$/;"	m	struct:thread_args	file:	access:public
thread_args::total_lines	sort.c	/^  size_t const total_lines;$/;"	m	struct:thread_args	file:	access:public
three_arguments	test.c	/^static bool three_arguments (void);$/;"	p	file:	signature:(void)
three_arguments	test.c	/^three_arguments (void)$/;"	f	file:	signature:(void)
time_args	du.c	/^static char const *const time_args[] =$/;"	v	file:
time_args	ls.c	/^static char const *const time_args[] =$/;"	v	file:
time_args	touch.c	/^static char const* const time_args[] =$/;"	v	file:
time_atime	du.c	/^    time_atime$/;"	e	enum:time_type	file:
time_atime	ls.c	/^    time_atime,			\/* -u *\/$/;"	e	enum:time_type	file:
time_ctime	du.c	/^    time_ctime,$/;"	e	enum:time_type	file:
time_ctime	ls.c	/^    time_ctime,			\/* -c *\/$/;"	e	enum:time_type	file:
time_format	du.c	/^static char const *time_format = NULL;$/;"	v	file:
time_format	pinky.c	/^static char const *time_format;$/;"	v	file:
time_format	who.c	/^static char const *time_format;$/;"	v	file:
time_format_width	pinky.c	/^static int time_format_width;$/;"	v	file:
time_format_width	who.c	/^static int time_format_width;$/;"	v	file:
time_masks	touch.c	/^static int const time_masks[] =$/;"	v	file:
time_mtime	du.c	/^    time_mtime,			\/* default *\/$/;"	e	enum:time_type	file:
time_mtime	ls.c	/^    time_mtime,			\/* default *\/$/;"	e	enum:time_type	file:
time_numtypes	ls.c	/^    time_numtypes		\/* the number of elements of this enum *\/$/;"	e	enum:time_type	file:
time_spec	date.c	/^static enum Time_spec const time_spec[] =$/;"	v	file:
time_spec_string	date.c	/^static char const *const time_spec_string[] =$/;"	v	file:
time_string	pinky.c	/^time_string (const STRUCT_UTMP *utmp_ent)$/;"	f	file:	signature:(const STRUCT_UTMP *utmp_ent)
time_string	who.c	/^time_string (const STRUCT_UTMP *utmp_ent)$/;"	f	file:	signature:(const STRUCT_UTMP *utmp_ent)
time_style	du.c	/^enum time_style$/;"	g	file:
time_style	du.c	/^static char const *time_style = NULL;$/;"	v	file:
time_style	ls.c	/^enum time_style$/;"	g	file:
time_style_args	du.c	/^static char const *const time_style_args[] =$/;"	v	file:
time_style_args	ls.c	/^static char const *const time_style_args[] =$/;"	v	file:
time_style_types	du.c	/^static enum time_style const time_style_types[] =$/;"	v	file:
time_style_types	ls.c	/^static enum time_style const time_style_types[] =$/;"	v	file:
time_type	du.c	/^enum time_type$/;"	g	file:
time_type	du.c	/^static enum time_type time_type = time_mtime;$/;"	v	typeref:enum:time_type	file:
time_type	ls.c	/^enum time_type$/;"	g	file:
time_type	ls.c	/^static enum time_type time_type;$/;"	v	typeref:enum:time_type	file:
time_types	du.c	/^static enum time_type const time_types[] =$/;"	v	file:
time_types	ls.c	/^static enum time_type const time_types[] =$/;"	v	file:
timed_out	timeout.c	/^static int timed_out;$/;"	v	file:
timetostr	system.h	/^timetostr (time_t t, char *buf)$/;"	f	signature:(time_t t, char *buf)
tmax	du.c	/^  struct timespec tmax;$/;"	m	struct:duinfo	typeref:struct:duinfo::timespec	file:	access:public
to_uchar	system.h	/^static inline unsigned char to_uchar (char ch) { return ch; }$/;"	f	signature:(char ch)
to_unit_size	numfmt.c	/^static uintmax_t to_unit_size = 1;$/;"	v	file:
toarith	expr.c	/^toarith (VALUE *v)$/;"	f	file:	signature:(VALUE *v)
top	tsort.c	/^  struct successor *top;$/;"	m	struct:item	typeref:struct:item::successor	file:	access:public
top_level_dst_name	copy.c	/^static char const *top_level_dst_name;$/;"	v	file:
top_level_src_name	copy.c	/^static char const *top_level_src_name;$/;"	v	file:
tostring	expr.c	/^tostring (VALUE *v)$/;"	f	file:	signature:(VALUE *v)
tot_dui	du.c	/^static struct duinfo tot_dui;$/;"	v	typeref:struct:duinfo	file:
total	df.c	/^  uintmax_t total;$/;"	m	struct:field_values_t	file:	access:public
total_bytes	wc.c	/^static uintmax_t total_bytes;$/;"	v	file:
total_chars	wc.c	/^static uintmax_t total_chars;$/;"	v	file:
total_files	pr.c	/^static int total_files = 0;$/;"	v	file:
total_line_count	ptx.c	/^static int total_line_count;	\/* total number of lines seen so far *\/$/;"	v	file:
total_lines	sort.c	/^  size_t const total_lines;$/;"	m	struct:thread_args	file:	access:public
total_lines	wc.c	/^static uintmax_t total_lines;$/;"	v	file:
total_words	wc.c	/^static uintmax_t total_words;$/;"	v	file:
touch	touch.c	/^touch (const char *file)$/;"	f	file:	signature:(const char *file)
trace	expr.c	/^trace (fxn)$/;"	f	file:
traditional	od.c	/^static bool traditional;$/;"	v	file:
trailing_delim	stat.c	/^static char const *trailing_delim = "";$/;"	v	file:
trans_table	dd.c	/^static unsigned char trans_table[256];$/;"	v	file:
transform	local.mk	/^transform = s\/ginstall\/install\/; $(program_transform_name)$/;"	m
translate	sort.c	/^  char const *translate;	\/* Translation applied to characters. *\/$/;"	m	struct:keyfield	file:	access:public
translate_buffer	dd.c	/^translate_buffer (char *buf, size_t nread)$/;"	f	file:	signature:(char *buf, size_t nread)
translate_charset	dd.c	/^translate_charset (char const *new_trans)$/;"	f	file:	signature:(char const *new_trans)
translating	tr.c	/^static bool translating;$/;"	v	file:
translation_needed	dd.c	/^static bool translation_needed = false;$/;"	v	file:
trim_leading_zeros	seq.c	/^trim_leading_zeros (char const *s)$/;"	f	file:	signature:(char const *s)
truncate_lines	pr.c	/^static bool truncate_lines = false;$/;"	v	file:
truncate_set1	tr.c	/^static bool truncate_set1 = false;$/;"	v	file:
truncation_string	ptx.c	/^static const char *truncation_string = "\/";$/;"	v	file:
truncation_string_length	ptx.c	/^static int truncation_string_length;\/* length of string that flags truncation *\/$/;"	v	file:
tsort	tsort.c	/^tsort (const char *file)$/;"	f	file:	signature:(const char *file)
tspec	od.c	/^struct tspec$/;"	s	file:
tspec::field_width	od.c	/^    int field_width; \/* Minimum width of a field, excluding leading space.  *\/$/;"	m	struct:tspec	file:	access:public
tspec::fmt	od.c	/^    enum output_format fmt;$/;"	m	struct:tspec	typeref:enum:tspec::output_format	file:	access:public
tspec::fmt_string	od.c	/^    char fmt_string[FMT_BYTES_ALLOCATED]; \/* Of the style "%*d".  *\/$/;"	m	struct:tspec	file:	access:public
tspec::hexl_mode_trailer	od.c	/^    bool hexl_mode_trailer;$/;"	m	struct:tspec	file:	access:public
tspec::pad_width	od.c	/^    int pad_width; \/* Total padding to be divided among fields.  *\/$/;"	m	struct:tspec	file:	access:public
tspec::print_function	od.c	/^    void (*print_function) (size_t fields, size_t blank, void const *data,$/;"	m	struct:tspec	file:	access:public
tspec::size	od.c	/^    enum size_spec size; \/* Type of input object.  *\/$/;"	m	struct:tspec	typeref:enum:tspec::size_spec	file:	access:public
ttyname	pinky.c	/^char *ttyname (int);$/;"	p	file:	signature:(int)
ttyname	system.h	/^char *ttyname ();$/;"	p	signature:()
ttyname	who.c	/^char *ttyname (int);$/;"	p	file:	signature:(int)
two_arguments	test.c	/^static bool two_arguments (void);$/;"	p	file:	signature:(void)
two_arguments	test.c	/^two_arguments (void)$/;"	f	file:	signature:(void)
type	expr.c	/^  TYPE type;			\/* Which kind. *\/$/;"	m	struct:valinfo	file:	access:public
type	stty.c	/^    enum mode_type type;	\/* Which structure element to change. *\/$/;"	m	struct:mode_info	typeref:enum:mode_info::mode_type	file:	access:public
type	tr.c	/^    enum Range_element_type type;$/;"	m	struct:List_element	typeref:enum:List_element::Range_element_type	file:	access:public
type_bytes	split.c	/^  type_undef, type_bytes, type_byteslines, type_lines, type_digits,$/;"	e	enum:Split_type	file:
type_byteslines	split.c	/^  type_undef, type_bytes, type_byteslines, type_lines, type_digits,$/;"	e	enum:Split_type	file:
type_chunk_bytes	split.c	/^  type_chunk_bytes, type_chunk_lines, type_rr$/;"	e	enum:Split_type	file:
type_chunk_lines	split.c	/^  type_chunk_bytes, type_chunk_lines, type_rr$/;"	e	enum:Split_type	file:
type_digits	split.c	/^  type_undef, type_bytes, type_byteslines, type_lines, type_digits,$/;"	e	enum:Split_type	file:
type_lines	split.c	/^  type_undef, type_bytes, type_byteslines, type_lines, type_digits,$/;"	e	enum:Split_type	file:
type_rr	split.c	/^  type_chunk_bytes, type_chunk_lines, type_rr$/;"	e	enum:Split_type	file:
type_undef	split.c	/^  type_undef, type_bytes, type_byteslines, type_lines, type_digits,$/;"	e	enum:Split_type	file:
u	expr.c	/^  } u;$/;"	m	struct:valinfo	typeref:union:valinfo::__anon61	file:	access:public
u	tr.c	/^    u;$/;"	m	struct:List_element	typeref:union:List_element::__anon3	file:	access:public
udiv_qrnnd	factor.c	280;"	d	file:
udiv_qrnnd	factor.c	281;"	d	file:
udiv_qrnnd	longlong.h	/^extern UWtype __MPN(udiv_qrnnd) (UWtype *, UWtype, UWtype, UWtype);$/;"	p	signature:(UWtype *, UWtype, UWtype, UWtype)
udiv_qrnnd	longlong.h	1017;"	d
udiv_qrnnd	longlong.h	1064;"	d
udiv_qrnnd	longlong.h	1117;"	d
udiv_qrnnd	longlong.h	1201;"	d
udiv_qrnnd	longlong.h	1282;"	d
udiv_qrnnd	longlong.h	1591;"	d
udiv_qrnnd	longlong.h	1616;"	d
udiv_qrnnd	longlong.h	1634;"	d
udiv_qrnnd	longlong.h	1734;"	d
udiv_qrnnd	longlong.h	1895;"	d
udiv_qrnnd	longlong.h	1909;"	d
udiv_qrnnd	longlong.h	2048;"	d
udiv_qrnnd	longlong.h	204;"	d
udiv_qrnnd	longlong.h	2060;"	d
udiv_qrnnd	longlong.h	286;"	d
udiv_qrnnd	longlong.h	353;"	d
udiv_qrnnd	longlong.h	396;"	d
udiv_qrnnd	longlong.h	478;"	d
udiv_qrnnd	longlong.h	507;"	d
udiv_qrnnd	longlong.h	621;"	d
udiv_qrnnd	longlong.h	770;"	d
udiv_qrnnd	longlong.h	836;"	d
udiv_qrnnd	longlong.h	876;"	d
udiv_w_sdiv	longlong.h	/^__GMP_DECLSPEC UWtype __MPN(udiv_w_sdiv) (UWtype *, UWtype, UWtype, UWtype);$/;"	p	signature:(UWtype *, UWtype, UWtype, UWtype)
uid_to_name	chown-core.c	/^uid_to_name (uid_t uid)$/;"	f	signature:(uid_t uid)
uid_to_name	chown-core.h	/^uid_to_name (uid_t);$/;"	p	signature:(uid_t)
uidtostr	id.c	297;"	d	file:
uidtostr_ptr	id.c	/^uidtostr_ptr (uid_t const *uid)$/;"	f	file:	signature:(uid_t const *uid)
umask_value	chmod.c	/^static mode_t umask_value;$/;"	v	file:
umul_ppmm	factor.c	250;"	d	file:
umul_ppmm	longlong.h	1013;"	d
umul_ppmm	longlong.h	1053;"	d
umul_ppmm	longlong.h	1112;"	d
umul_ppmm	longlong.h	1127;"	d
umul_ppmm	longlong.h	1192;"	d
umul_ppmm	longlong.h	1219;"	d
umul_ppmm	longlong.h	1227;"	d
umul_ppmm	longlong.h	1231;"	d
umul_ppmm	longlong.h	1241;"	d
umul_ppmm	longlong.h	1250;"	d
umul_ppmm	longlong.h	1254;"	d
umul_ppmm	longlong.h	1263;"	d
umul_ppmm	longlong.h	1268;"	d
umul_ppmm	longlong.h	1357;"	d
umul_ppmm	longlong.h	1365;"	d
umul_ppmm	longlong.h	1465;"	d
umul_ppmm	longlong.h	1495;"	d
umul_ppmm	longlong.h	1558;"	d
umul_ppmm	longlong.h	1587;"	d
umul_ppmm	longlong.h	1607;"	d
umul_ppmm	longlong.h	1631;"	d
umul_ppmm	longlong.h	1687;"	d
umul_ppmm	longlong.h	177;"	d
umul_ppmm	longlong.h	1821;"	d
umul_ppmm	longlong.h	1843;"	d
umul_ppmm	longlong.h	184;"	d
umul_ppmm	longlong.h	1869;"	d
umul_ppmm	longlong.h	1882;"	d
umul_ppmm	longlong.h	1944;"	d
umul_ppmm	longlong.h	1965;"	d
umul_ppmm	longlong.h	196;"	d
umul_ppmm	longlong.h	262;"	d
umul_ppmm	longlong.h	279;"	d
umul_ppmm	longlong.h	314;"	d
umul_ppmm	longlong.h	345;"	d
umul_ppmm	longlong.h	386;"	d
umul_ppmm	longlong.h	472;"	d
umul_ppmm	longlong.h	488;"	d
umul_ppmm	longlong.h	549;"	d
umul_ppmm	longlong.h	561;"	d
umul_ppmm	longlong.h	586;"	d
umul_ppmm	longlong.h	617;"	d
umul_ppmm	longlong.h	640;"	d
umul_ppmm	longlong.h	717;"	d
umul_ppmm	longlong.h	740;"	d
umul_ppmm	longlong.h	826;"	d
umul_ppmm	longlong.h	872;"	d
uname_long_options	uname.c	/^static struct option const uname_long_options[] =$/;"	v	file:
uname_mode	uname-arch.c	/^int uname_mode = UNAME_ARCH;$/;"	v
uname_mode	uname-uname.c	/^int uname_mode = UNAME_UNAME;$/;"	v
unary_advance	test.c	/^unary_advance (void)$/;"	f	file:	signature:(void)
unary_operator	test.c	/^static bool unary_operator (void);$/;"	p	file:	signature:(void)
unary_operator	test.c	/^unary_operator (void)$/;"	f	file:	signature:(void)
unblock_signal	timeout.c	/^unblock_signal (int sig)$/;"	f	file:	signature:(int sig)
unbuffered	split.c	/^static bool unbuffered;$/;"	v	file:
undefined_mode	cut.c	/^    undefined_mode,$/;"	e	enum:operating_mode	file:
unexpand	unexpand.c	/^unexpand (void)$/;"	f	file:	signature:(void)
uni_blank	join.c	/^static struct line uni_blank;$/;"	v	typeref:struct:line	file:
uniform	fmt.c	/^static bool uniform;$/;"	v	file:
unique	sort.c	/^static bool unique;$/;"	v	file:
unit_order	sort.c	/^static char const unit_order[UCHAR_LIM] =$/;"	v	file:
unit_to_umax	numfmt.c	/^unit_to_umax (const char *n_string)$/;"	f	file:	signature:(const char *n_string)
unknown	ls.c	/^    unknown,$/;"	e	enum:filetype	file:
unlink_dest_after_failed_open	copy.h	/^  bool unlink_dest_after_failed_open;$/;"	m	struct:cp_options	access:public
unlink_dest_before_opening	copy.h	/^  bool unlink_dest_before_opening;$/;"	m	struct:cp_options	access:public
unlink_tempfile	tac.c	/^unlink_tempfile (void)$/;"	f	file:	signature:(void)
unlock_node	sort.c	/^unlock_node (struct merge_node *node)$/;"	f	file:	signature:(struct merge_node *node)
unquote	tr.c	/^unquote (char const *s, struct E_string *es)$/;"	f	file:	signature:(char const *s, struct E_string *es)
unsigned_file_size	ls.c	/^unsigned_file_size (off_t size)$/;"	f	file:	signature:(off_t size)
unsigned_long_long_int	od.c	/^typedef unsigned long int unsigned_long_long_int;$/;"	t	file:
unsigned_long_long_int	od.c	/^typedef unsigned long long int unsigned_long_long_int;$/;"	t	file:
untabify_input	pr.c	/^static bool untabify_input = false;$/;"	v	file:
update	copy.h	/^  bool update;$/;"	m	struct:cp_options	access:public
uptime	uptime.c	/^uptime (const char *filename, int options)$/;"	f	file:	signature:(const char *filename, int options)
usable_st_size	system.h	/^usable_st_size (struct stat const *sb)$/;"	f	signature:(struct stat const *sb)
usage	base64.c	/^usage (int status)$/;"	f	signature:(int status)
usage	basename.c	/^usage (int status)$/;"	f	signature:(int status)
usage	cat.c	/^usage (int status)$/;"	f	signature:(int status)
usage	chcon.c	/^usage (int status)$/;"	f	signature:(int status)
usage	chgrp.c	/^usage (int status)$/;"	f	signature:(int status)
usage	chmod.c	/^usage (int status)$/;"	f	signature:(int status)
usage	chown.c	/^usage (int status)$/;"	f	signature:(int status)
usage	chroot.c	/^usage (int status)$/;"	f	signature:(int status)
usage	cksum.c	/^usage (int status)$/;"	f	signature:(int status)
usage	comm.c	/^usage (int status)$/;"	f	signature:(int status)
usage	cp.c	/^usage (int status)$/;"	f	signature:(int status)
usage	csplit.c	/^usage (int status)$/;"	f	signature:(int status)
usage	cut.c	/^usage (int status)$/;"	f	signature:(int status)
usage	date.c	/^usage (int status)$/;"	f	signature:(int status)
usage	dd.c	/^usage (int status)$/;"	f	signature:(int status)
usage	df.c	/^usage (int status)$/;"	f	signature:(int status)
usage	dircolors.c	/^usage (int status)$/;"	f	signature:(int status)
usage	dirname.c	/^usage (int status)$/;"	f	signature:(int status)
usage	du.c	/^usage (int status)$/;"	f	signature:(int status)
usage	echo.c	/^usage (int status)$/;"	f	signature:(int status)
usage	env.c	/^usage (int status)$/;"	f	signature:(int status)
usage	expand.c	/^usage (int status)$/;"	f	signature:(int status)
usage	expr.c	/^usage (int status)$/;"	f	signature:(int status)
usage	factor.c	/^usage (int status)$/;"	f	signature:(int status)
usage	fmt.c	/^usage (int status)$/;"	f	signature:(int status)
usage	fold.c	/^usage (int status)$/;"	f	signature:(int status)
usage	getlimits.c	/^usage (int status)$/;"	f	signature:(int status)
usage	groups.c	/^usage (int status)$/;"	f	signature:(int status)
usage	head.c	/^usage (int status)$/;"	f	signature:(int status)
usage	hostid.c	/^usage (int status)$/;"	f	signature:(int status)
usage	hostname.c	/^usage (int status)$/;"	f	signature:(int status)
usage	id.c	/^usage (int status)$/;"	f	signature:(int status)
usage	install.c	/^usage (int status)$/;"	f	signature:(int status)
usage	join.c	/^usage (int status)$/;"	f	signature:(int status)
usage	kill.c	/^usage (int status)$/;"	f	signature:(int status)
usage	link.c	/^usage (int status)$/;"	f	signature:(int status)
usage	ln.c	/^usage (int status)$/;"	f	signature:(int status)
usage	logname.c	/^usage (int status)$/;"	f	signature:(int status)
usage	ls.c	/^usage (int status)$/;"	f	signature:(int status)
usage	md5sum.c	/^usage (int status)$/;"	f	signature:(int status)
usage	mkdir.c	/^usage (int status)$/;"	f	signature:(int status)
usage	mkfifo.c	/^usage (int status)$/;"	f	signature:(int status)
usage	mknod.c	/^usage (int status)$/;"	f	signature:(int status)
usage	mktemp.c	/^usage (int status)$/;"	f	signature:(int status)
usage	mv.c	/^usage (int status)$/;"	f	signature:(int status)
usage	nice.c	/^usage (int status)$/;"	f	signature:(int status)
usage	nl.c	/^usage (int status)$/;"	f	signature:(int status)
usage	nohup.c	/^usage (int status)$/;"	f	signature:(int status)
usage	nproc.c	/^usage (int status)$/;"	f	signature:(int status)
usage	numfmt.c	/^usage (int status)$/;"	f	signature:(int status)
usage	od.c	/^usage (int status)$/;"	f	signature:(int status)
usage	paste.c	/^usage (int status)$/;"	f	signature:(int status)
usage	pathchk.c	/^usage (int status)$/;"	f	signature:(int status)
usage	pinky.c	/^usage (int status)$/;"	f	signature:(int status)
usage	pr.c	/^usage (int status)$/;"	f	signature:(int status)
usage	printenv.c	/^usage (int status)$/;"	f	signature:(int status)
usage	printf.c	/^usage (int status)$/;"	f	signature:(int status)
usage	ptx.c	/^usage (int status)$/;"	f	signature:(int status)
usage	pwd.c	/^usage (int status)$/;"	f	signature:(int status)
usage	readlink.c	/^usage (int status)$/;"	f	signature:(int status)
usage	realpath.c	/^usage (int status)$/;"	f	signature:(int status)
usage	rm.c	/^usage (int status)$/;"	f	signature:(int status)
usage	rmdir.c	/^usage (int status)$/;"	f	signature:(int status)
usage	runcon.c	/^usage (int status)$/;"	f	signature:(int status)
usage	seq.c	/^usage (int status)$/;"	f	signature:(int status)
usage	setuidgid.c	/^usage (int status)$/;"	f	signature:(int status)
usage	shred.c	/^usage (int status)$/;"	f	signature:(int status)
usage	shuf.c	/^usage (int status)$/;"	f	signature:(int status)
usage	sleep.c	/^usage (int status)$/;"	f	signature:(int status)
usage	sort.c	/^usage (int status)$/;"	f	signature:(int status)
usage	split.c	/^usage (int status)$/;"	f	signature:(int status)
usage	stat.c	/^usage (int status)$/;"	f	signature:(int status)
usage	stdbuf.c	/^usage (int status)$/;"	f	signature:(int status)
usage	stty.c	/^usage (int status)$/;"	f	signature:(int status)
usage	sum.c	/^usage (int status)$/;"	f	signature:(int status)
usage	sync.c	/^usage (int status)$/;"	f	signature:(int status)
usage	tac.c	/^usage (int status)$/;"	f	signature:(int status)
usage	tail.c	/^usage (int status)$/;"	f	signature:(int status)
usage	tee.c	/^usage (int status)$/;"	f	signature:(int status)
usage	test.c	/^usage (int status)$/;"	f	signature:(int status)
usage	timeout.c	/^usage (int status)$/;"	f	signature:(int status)
usage	touch.c	/^usage (int status)$/;"	f	signature:(int status)
usage	tr.c	/^usage (int status)$/;"	f	signature:(int status)
usage	true.c	/^usage (int status)$/;"	f	signature:(int status)
usage	truncate.c	/^usage (int status)$/;"	f	signature:(int status)
usage	tsort.c	/^usage (int status)$/;"	f	signature:(int status)
usage	tty.c	/^usage (int status)$/;"	f	signature:(int status)
usage	uname.c	/^usage (int status)$/;"	f	signature:(int status)
usage	unexpand.c	/^usage (int status)$/;"	f	signature:(int status)
usage	uniq.c	/^usage (int status)$/;"	f	signature:(int status)
usage	unlink.c	/^usage (int status)$/;"	f	signature:(int status)
usage	uptime.c	/^usage (int status)$/;"	f	signature:(int status)
usage	users.c	/^usage (int status)$/;"	f	signature:(int status)
usage	wc.c	/^usage (int status)$/;"	f	signature:(int status)
usage	who.c	/^usage (int status)$/;"	f	signature:(int status)
usage	whoami.c	/^usage (int status)$/;"	f	signature:(int status)
usage	yes.c	/^usage (int status)$/;"	f	signature:(int status)
use_cntrl_prefix	pr.c	/^static bool use_cntrl_prefix = false;$/;"	v	file:
use_col_separator	pr.c	/^static bool use_col_separator = false;$/;"	v	file:
use_default_selinux_context	install.c	/^static bool use_default_selinux_context = true;$/;"	v	file:
use_esc_sequence	pr.c	/^static bool use_esc_sequence = false;$/;"	v	file:
use_form_feed	pr.c	/^static bool use_form_feed = false;$/;"	v	file:
use_name	id.c	/^static bool use_name = false;$/;"	v	file:
use_nuls	realpath.c	/^static bool use_nuls;$/;"	v	file:
use_ref	touch.c	/^static bool use_ref;$/;"	v	file:
used	csplit.c	/^  size_t used;			\/* Number of offsets used in this struct. *\/$/;"	m	struct:line	file:	access:public
used	df.c	/^  bool used;$/;"	m	struct:field_data_t	file:	access:public
used	df.c	/^  uintmax_t used;$/;"	m	struct:field_values_t	file:	access:public
used	sort.c	/^  size_t used;			\/* Number of bytes used for input data.  *\/$/;"	m	struct:buffer	file:	access:public
used_color	ls.c	/^static bool used_color = false;$/;"	v	file:
user_group_str	chown-core.c	/^user_group_str (char const *user, char const *group)$/;"	f	file:	signature:(char const *user, char const *group)
user_name	chown-core.h	/^  char *user_name;$/;"	m	struct:Chown_option	access:public
userid_compare	users.c	/^userid_compare (const void *v_a, const void *v_b)$/;"	f	file:	signature:(const void *v_a, const void *v_b)
users	users.c	/^users (const char *filename, int options)$/;"	f	file:	signature:(const char *filename, int options)
utimens_symlink	copy.c	/^utimens_symlink (char const *file, struct timespec const *timespec)$/;"	f	file:	signature:(char const *file, struct timespec const *timespec)
v	dd.c	/^    v = ~(0$/;"	e	enum:__anon90	file:
v2	dd.c	/^    v2 = v ^ O_FULLBLOCK,$/;"	e	enum:__anon90	file:
v3	dd.c	/^    v3 = v2 ^ O_NOCACHE,$/;"	e	enum:__anon90	file:
v4	dd.c	/^    v4 = v3 ^ O_COUNT_BYTES,$/;"	e	enum:__anon90	file:
v5	dd.c	/^    v5 = v4 ^ O_SKIP_BYTES,$/;"	e	enum:__anon90	file:
val	sort.c	/^  int val;$/;"	m	struct:month	file:	access:public
valid	sort.c	/^  bool valid;$/;"	m	struct:cs_status	file:	access:public
valid_file_spec	tail.c	/^valid_file_spec (struct File_spec const *f)$/;"	f	file:	signature:(struct File_spec const *f)
valid_len	ls.c	/^  bool valid_len;$/;"	m	struct:column_info	file:	access:public
valid_options	copy.c	/^valid_options (const struct cp_options *co)$/;"	f	file:	signature:(const struct cp_options *co)
valid_suffix	numfmt.c	/^valid_suffix (const char suf)$/;"	f	file:	signature:(const char suf)
validate	tr.c	/^validate (struct Spec_list *s1, struct Spec_list *s2)$/;"	f	file:	signature:(struct Spec_list *s1, struct Spec_list *s2)
validate_case_classes	tr.c	/^validate_case_classes (struct Spec_list *s1, struct Spec_list *s2)$/;"	f	file:	signature:(struct Spec_list *s1, struct Spec_list *s2)
validate_file_name	pathchk.c	/^static bool validate_file_name (char *, bool, bool);$/;"	p	file:	signature:(char *, bool, bool)
validate_file_name	pathchk.c	/^validate_file_name (char *file, bool check_basic_portability,$/;"	f	file:	signature:(char *file, bool check_basic_portability, bool check_extra_portability)
validate_tab_stops	expand.c	/^validate_tab_stops (uintmax_t const *tabs, size_t entries)$/;"	f	file:	signature:(uintmax_t const *tabs, size_t entries)
validate_tab_stops	unexpand.c	/^validate_tab_stops (uintmax_t const *tabs, size_t entries)$/;"	f	file:	signature:(uintmax_t const *tabs, size_t entries)
valinfo	expr.c	/^struct valinfo$/;"	s	file:
valinfo::__anon61::i	expr.c	/^    mpz_t i;$/;"	m	union:valinfo::__anon61	file:	access:public
valinfo::__anon61::s	expr.c	/^    char *s;$/;"	m	union:valinfo::__anon61	file:	access:public
valinfo::type	expr.c	/^  TYPE type;			\/* Which kind. *\/$/;"	m	struct:valinfo	file:	access:public
valinfo::u	expr.c	/^  } u;$/;"	m	struct:valinfo	typeref:union:valinfo::__anon61	file:	access:public
valtype	expr.c	/^enum valtype$/;"	g	file:
value	dd.c	/^  int value;$/;"	m	struct:symbol_value	file:	access:public
value	seq.c	/^  long double value;$/;"	m	struct:operand	file:	access:public
value	stty.c	/^  unsigned long int value;	\/* Numeric value. *\/$/;"	m	struct:speed_map	file:	access:public
verbose	chcon.c	/^static bool verbose;$/;"	v	file:
verbose	copy.h	/^  bool verbose;$/;"	m	struct:cp_options	access:public
verbose	ln.c	/^static bool verbose;$/;"	v	file:
verbose	readlink.c	/^static bool verbose;$/;"	v	file:
verbose	realpath.c	/^static bool verbose = true;$/;"	v	file:
verbose	remove.h	/^  bool verbose;$/;"	m	struct:rm_options	access:public
verbose	rmdir.c	/^static bool verbose;$/;"	v	file:
verbose	shred.c	/^  bool verbose;		\/* -v flag: Print progress *\/$/;"	m	struct:Options	file:	access:public
verbose	split.c	/^static bool verbose;$/;"	v	file:
verbosity	chmod.c	/^static enum Verbosity verbosity = V_off;$/;"	v	typeref:enum:Verbosity	file:
verbosity	chown-core.h	/^  enum Verbosity verbosity;$/;"	m	struct:Chown_option	typeref:enum:Chown_option::Verbosity	access:public
verify_numeric	printf.c	/^verify_numeric (const char *s, const char *end)$/;"	f	file:	signature:(const char *s, const char *end)
version	sort.c	/^  bool version;			\/* sort by version number *\/$/;"	m	struct:keyfield	file:	access:public
visible	stty.c	/^static char const *visible (cc_t ch);$/;"	p	file:	signature:(cc_t ch)
visible	stty.c	/^visible (cc_t ch)$/;"	f	file:	signature:(cc_t ch)
visit_dir	ls.c	/^visit_dir (dev_t dev, ino_t ino)$/;"	f	file:	signature:(dev_t dev, ino_t ino)
w_bytes	dd.c	/^static uintmax_t w_bytes = 0;$/;"	v	file:
w_full	dd.c	/^static uintmax_t w_full = 0;$/;"	v	file:
w_partial	dd.c	/^static uintmax_t w_partial = 0;$/;"	v	file:
wait_proc	sort.c	/^wait_proc (pid_t pid)$/;"	f	file:	signature:(pid_t pid)
walk_tree	tsort.c	/^walk_tree (struct item *root, bool (*action) (struct item *))$/;"	f	file:	signature:(struct item *root, bool (*action) (struct item *))
warn	md5sum.c	/^static bool warn = false;$/;"	v	file:
warn_partial_read	dd.c	/^static bool warn_partial_read;$/;"	v	file:
wc	wc.c	/^wc (int fd, char const *file_x, struct fstatus *fstatus)$/;"	f	file:	signature:(int fd, char const *file_x, struct fstatus *fstatus)
wc_file	wc.c	/^wc_file (char const *file, struct fstatus *fstatus)$/;"	f	file:	signature:(char const *file, struct fstatus *fstatus)
wd	tail.c	/^  int wd;$/;"	m	struct:File_spec	file:	access:public
wd_comparator	tail.c	/^wd_comparator (const void *e1, const void *e2)$/;"	f	file:	signature:(const void *e1, const void *e2)
wd_hasher	tail.c	/^wd_hasher (const void *entry, size_t tabsize)$/;"	f	file:	signature:(const void *entry, size_t tabsize)
whiteout	ls.c	/^    whiteout,$/;"	e	enum:filetype	file:
who	who.c	/^who (const char *filename, int options)$/;"	f	file:	signature:(const char *filename, int options)
wide_uint	make-prime-list.c	/^typedef uintmax_t wide_uint;$/;"	t	file:
wide_uint	make-prime-list.c	/^typedef unsigned __int128 wide_uint;$/;"	t	file:
width	df.c	/^  size_t width;       \/* Auto adjusted (up) widths used to align columns.  *\/$/;"	m	struct:field_data_t	file:	access:public
width	seq.c	/^  size_t width;$/;"	m	struct:operand	file:	access:public
width_bytes	od.c	/^static const int width_bytes[] =$/;"	v	file:
wipefd	shred.c	/^wipefd (int fd, char const *qname, struct randint_source *s,$/;"	f	file:	signature:(int fd, char const *qname, struct randint_source *s, struct Options const *flags)
wipefile	shred.c	/^wipefile (char *name, char const *qname,$/;"	f	file:	signature:(char *name, char const *qname, struct randint_source *s, struct Options const *flags)
wipename	shred.c	/^wipename (char *oldname, char const *qoldname, struct Options const *flags)$/;"	f	file:	signature:(char *oldname, char const *qoldname, struct Options const *flags)
with_commas	ls.c	/^    with_commas			\/* -m *\/$/;"	e	enum:format	file:
word	fmt.c	/^static WORD word[MAXWORDS];$/;"	v	file:
word	fmt.c	27;"	d	file:
word_fastmap	ptx.c	/^static char word_fastmap[CHAR_SET_SIZE];$/;"	v	file:
word_limit	fmt.c	/^static WORD *word_limit;$/;"	v	file:
word_regex	ptx.c	/^static struct regex_data word_regex;	\/* keyword *\/$/;"	v	typeref:struct:regex_data	file:
word_regs	ptx.c	/^static struct re_registers word_regs;$/;"	v	typeref:struct:re_registers	file:
wptr	fmt.c	/^static char *wptr;$/;"	v	file:
wrap_write	base64.c	/^wrap_write (const char *buffer, size_t len,$/;"	f	file:	signature:(const char *buffer, size_t len, uintmax_t wrap_column, size_t *current_column, FILE *out)
wrapf	stty.c	/^static void wrapf (const char *message, ...)$/;"	p	file:	signature:(const char *message, ...)
wrapf	stty.c	/^wrapf (const char *message,...)$/;"	f	file:	signature:(const char *message,...)
writable_destination	copy.c	/^writable_destination (char const *file, mode_t mode)$/;"	f	file:	signature:(char const *file, mode_t mode)
write_block	od.c	/^write_block (uintmax_t current_offset, size_t n_bytes,$/;"	f	file:	signature:(uintmax_t current_offset, size_t n_bytes, const char *prev_block, const char *curr_block)
write_counts	wc.c	/^write_counts (uintmax_t lines,$/;"	f	file:	signature:(uintmax_t lines, uintmax_t words, uintmax_t chars, uintmax_t bytes, uintmax_t linelength, const char *file)
write_error	paste.c	/^write_error (void)$/;"	f	file:	signature:(void)
write_header	head.c	/^write_header (const char *filename)$/;"	f	file:	signature:(const char *filename)
write_header	tail.c	/^write_header (const char *pretty_filename)$/;"	f	file:	signature:(const char *pretty_filename)
write_line	sort.c	/^write_line (struct line const *line, FILE *fp, char const *output_file)$/;"	f	file:	signature:(struct line const *line, FILE *fp, char const *output_file)
write_output	dd.c	/^write_output (void)$/;"	f	file:	signature:(void)
write_pending	cat.c	/^write_pending (char *outbuf, char **bpout)$/;"	f	file:	signature:(char *outbuf, char **bpout)
write_permuted_output	shuf.c	/^write_permuted_output (size_t n_lines, char * const *line, size_t lo_input,$/;"	f	file:	signature:(size_t n_lines, char * const *line, size_t lo_input, size_t const *permutation, char eolbyte)
write_protected_non_symlink	remove.c	/^write_protected_non_symlink (int fd_cwd,$/;"	f	file:	signature:(int fd_cwd, char const *file, struct stat *buf)
write_to_file	csplit.c	/^write_to_file (uintmax_t last_line, bool ignore, int argnum)$/;"	f	file:	signature:(uintmax_t last_line, bool ignore, int argnum)
write_unique	sort.c	/^write_unique (struct line const *line, FILE *tfp, char const *temp_output)$/;"	f	file:	signature:(struct line const *line, FILE *tfp, char const *temp_output)
write_zeros	copy.c	/^write_zeros (int fd, uint64_t n_bytes)$/;"	f	file:	signature:(int fd, uint64_t n_bytes)
writeline	comm.c	/^writeline (struct linebuffer const *line, FILE *stream, int class)$/;"	f	file:	signature:(struct linebuffer const *line, FILE *stream, int class)
writeline	uniq.c	/^writeline (struct linebuffer const *line,$/;"	f	file:	signature:(struct linebuffer const *line, bool match, uintmax_t linecount)
xalloc	make-prime-list.c	/^xalloc (size_t s)$/;"	f	file:	signature:(size_t s)
xalloc_die	csplit.c	/^xalloc_die (void)$/;"	f	signature:(void)
xfclose	sort.c	/^xfclose (FILE *fp, char const *file)$/;"	f	file:	signature:(FILE *fp, char const *file)
xfields	join.c	/^xfields (struct line *line)$/;"	f	file:	signature:(struct line *line)
xfopen	sort.c	/^xfopen (char const *file, char const *how)$/;"	f	file:	signature:(char const *file, char const *how)
xlate	tr.c	/^static char xlate[N_CHARS];$/;"	v	file:
xlseek	tail.c	/^xlseek (int fd, off_t offset, int whence, char const *filename)$/;"	f	file:	signature:(int fd, off_t offset, int whence, char const *filename)
xputchar	paste.c	/^xputchar (char c)$/;"	f	file:	signature:(char c)
xstrcoll	ls.c	/^xstrcoll (char const *a, char const *b)$/;"	f	file:	signature:(char const *a, char const *b)
xstrcoll_df_version	ls.c	/^static int xstrcoll_df_version (V a, V b)$/;"	f	file:	signature:(V a, V b)
xstrcoll_version	ls.c	/^static int xstrcoll_version (V a, V b)$/;"	f	file:	signature:(V a, V b)
xstrxfrm	sort.c	/^xstrxfrm (char *restrict dest, char const *restrict src, size_t destsize)$/;"	f	file:	signature:(char *restrict dest, char const *restrict src, size_t destsize)
xwrite_stdout	tail.c	/^xwrite_stdout (char const *buffer, size_t n_bytes)$/;"	f	file:	signature:(char const *buffer, size_t n_bytes)
zaptemp	sort.c	/^zaptemp (char const *name)$/;"	f	file:	signature:(char const *name)
zero_fill	shred.c	/^  bool zero_fill;	\/* -z flag: Add a final zero pass *\/$/;"	m	struct:Options	file:	access:public
zeros	tsort.c	/^static struct item *zeros = NULL;$/;"	v	typeref:struct:item	file:
